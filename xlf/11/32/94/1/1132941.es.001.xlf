<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/1132941">
    <body>
      <group id="1132941">
        <trans-unit id="b69b153d9b8b6ca5cc39aae8241344dc670096ea" translate="yes" xml:space="preserve">
          <source>&quot;All functions with this problem &lt;strong&gt;suffer also from similar side effect problem on the actual parameter&lt;/strong&gt;,&quot;</source>
          <target state="translated">&quot;Todas las funciones con este problema &lt;strong&gt;tambi&amp;eacute;n sufren un&lt;/strong&gt; problema &lt;strong&gt;similar de efectos secundarios en el par&amp;aacute;metro real&lt;/strong&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="626c5410f93ad070237bab8024217f1cdd086983" translate="yes" xml:space="preserve">
          <source>... we assign the argument &lt;code&gt;a&lt;/code&gt; to an &lt;em&gt;unnamed&lt;/em&gt; list, if the caller does not pass the value of a.</source>
          <target state="translated">... asignamos el argumento &lt;code&gt;a&lt;/code&gt; a una lista &lt;em&gt;sin nombre&lt;/em&gt; , si la persona que llama no pasa el valor de a.</target>
        </trans-unit>
        <trans-unit id="d6ae47a54ed3aae922aa9b755c46be05126dc9cc" translate="yes" xml:space="preserve">
          <source>...all variables found outside of the innermost scope are
  read-only (&lt;strong&gt;&lt;em&gt;an attempt to write to such a variable will simply create a
  new local variable in the innermost scope, leaving the identically
  named outer variable unchanged&lt;/em&gt;&lt;/strong&gt;).</source>
          <target state="translated">... todas las variables que se encuentran fuera del &amp;aacute;mbito m&amp;aacute;s interno son de solo lectura ( &lt;strong&gt;&lt;em&gt;un intento de escribir en una variable de este tipo simplemente crear&amp;aacute; una nueva variable local en el &amp;aacute;mbito m&amp;aacute;s interno, dejando la variable externa con el mismo nombre sin cambios&lt;/em&gt;&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="ce4a03df48f71c59cb88d1614e04c355fe07eb41" translate="yes" xml:space="preserve">
          <source>1)  The so-called problem of &quot;Mutable Default Argument&quot; is in general a special example demonstrating that:</source>
          <target state="translated">1)El llamado problema del &quot;Argumento de Defecto Múltiple&quot; es en general un ejemplo especial que demuestra que:</target>
        </trans-unit>
        <trans-unit id="7ae49a8787afe33029393476223d3e6b04a350d7" translate="yes" xml:space="preserve">
          <source>3) In some cases is &lt;a href=&quot;http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults&quot;&gt;the mutable behavior of default parameters useful&lt;/a&gt;.</source>
          <target state="translated">3) En algunos casos es &lt;a href=&quot;http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults&quot;&gt;&amp;uacute;til el comportamiento mutable de los par&amp;aacute;metros predeterminados&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="349e3dc6e53ca45e7b264f3f4ece59155e2a0d64" translate="yes" xml:space="preserve">
          <source>5 points in defense of Python</source>
          <target state="translated">5 puntos en defensa de Python</target>
        </trans-unit>
        <trans-unit id="5619d3a6ff41fedee09fe44cfec87d091658e509" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#&lt;/code&gt;1</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt;1</target>
        </trans-unit>
        <trans-unit id="f9a7d25963aa0148809943888747c7bfdbad1397" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#&lt;/code&gt;2</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt;2</target>
        </trans-unit>
        <trans-unit id="f2848d4bf5368cd6cc2a23c96bcb460686851bd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[]&lt;/code&gt; is an object, so is &lt;code&gt;None&lt;/code&gt; (the former is mutable while the latter is immutable. But the mutability has nothing to do with the question). None is somewhere in the space but we know it's there and there is only one copy of None there. So every time foo is invoked, items is evaluated (as opposed to some answer that it is only evaluated once) to be None, to be clear, the reference (or the address) of None. Then in the foo, item is changed to [], i.e., points to another object which has a different address.</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; es un objeto, tambi&amp;eacute;n lo es &lt;code&gt;None&lt;/code&gt; (el primero es mutable mientras que el segundo es inmutable. Pero la mutabilidad no tiene nada que ver con la pregunta). None est&amp;aacute; en alg&amp;uacute;n lugar del espacio, pero sabemos que est&amp;aacute; all&amp;iacute; y solo hay una copia de None all&amp;iacute;. Por lo tanto, cada vez que se invoca foo, los elementos se eval&amp;uacute;an (a diferencia de alguna respuesta que solo se eval&amp;uacute;a una vez) para ser Ninguno, para ser claros, la referencia (o la direcci&amp;oacute;n) de Ninguno. Luego, en el foo, el elemento se cambia a [], es decir, apunta a otro objeto que tiene una direcci&amp;oacute;n diferente.</target>
        </trans-unit>
        <trans-unit id="0b51475de74c8a0af3e8ac61016a0b03493b9c51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; doesn't change - every assignment call creates new int object - new object is printed</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; no cambia - cada llamada de asignaci&amp;oacute;n crea un nuevo objeto int - se imprime un nuevo objeto</target>
        </trans-unit>
        <trans-unit id="c91d4e033dfa8facf99b416bc8eb05efa39a8648" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt; doesn't change - new array is build from default value and printed</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; no cambia: la nueva matriz se crea a partir del valor predeterminado y se imprime</target>
        </trans-unit>
        <trans-unit id="99868d483227e38115a490908f9eb6410e764c96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt; changes - operation is performed on same object - and it is printed</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; cambia - la operaci&amp;oacute;n se realiza en el mismo objeto - y se imprime</target>
        </trans-unit>
        <trans-unit id="1dce96d08fb23e6dd9bf8c83e0ce03a0c31931c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Astonished?&lt;/em&gt; The value inside the object changes! Consecutive calls to the function will now simply append to that embedded &lt;code&gt;list&lt;/code&gt; object:</source>
          <target state="translated">&lt;em&gt;&amp;iquest;Asombrado?&lt;/em&gt; &amp;iexcl;El valor dentro del objeto cambia! Las llamadas consecutivas a la funci&amp;oacute;n ahora simplemente se agregar&amp;aacute;n a ese objeto de &lt;code&gt;list&lt;/code&gt; a incrustado:</target>
        </trans-unit>
        <trans-unit id="9a5e006676bccb5e949d65e43cc04bfdb3e0f5c0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This is not a design flaw&lt;/em&gt;. Anyone who trips over this is doing something wrong.</source>
          <target state="translated">&lt;em&gt;Esto no es un defecto de dise&amp;ntilde;o&lt;/em&gt; . Cualquiera que tropiece con esto est&amp;aacute; haciendo algo mal.</target>
        </trans-unit>
        <trans-unit id="0bb5707416517e01b1b19796f5b4d8047f7be81f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(1)&lt;/strong&gt; is described in the Python &lt;a href=&quot;http://docs.python.org/tutorial/classes.html&quot;&gt;tutorial on classes&lt;/a&gt;. In an attempt to assign a value to a read-only class attribute:</source>
          <target state="translated">&lt;strong&gt;(1)&lt;/strong&gt; se describe en el &lt;a href=&quot;http://docs.python.org/tutorial/classes.html&quot;&gt;tutorial de&lt;/a&gt; Python sobre clases . En un intento de asignar un valor a un atributo de clase de solo lectura:</target>
        </trans-unit>
        <trans-unit id="1e830734a74d3ffb326fa9a33d2d932c606c6e1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1. Rendimiento&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1c12447cabd52b525bef97e580f6be054679aad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Forcing bound parameters&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. Forzar par&amp;aacute;metros vinculados&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="23662664198844161cfe301172c065fd31a550b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. Introspection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3. Introspecci&amp;oacute;n&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="329d395d793f53ccf44090cd1ed8d91c54ccbc68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Consistency&lt;/strong&gt;: Python &lt;em&gt;always&lt;/em&gt; passes objects, not names.
The default parameter is, obviously, part of the function 
heading (not the function body). It therefore ought to be evaluated
at module load time (and only at module load time, unless nested), not
at function call time.</source>
          <target state="translated">&lt;strong&gt;Consistencia&lt;/strong&gt; : Python &lt;em&gt;siempre&lt;/em&gt; pasa objetos, no nombres. El par&amp;aacute;metro predeterminado es, obviamente, parte del encabezado de la funci&amp;oacute;n (no el cuerpo de la funci&amp;oacute;n). Por lo tanto, debe evaluarse en el tiempo de carga del m&amp;oacute;dulo (y solo en el tiempo de carga del m&amp;oacute;dulo, a menos que est&amp;eacute; anidado), no en el momento de la llamada a la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="cf88699ee467bc4d13c8c871f2752ff94d964b35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default parameter values are evaluated from left to right when the function definition is executed.&lt;/strong&gt; This means that the expression is evaluated once, when the function is defined, and that the same &amp;ldquo;pre-computed&amp;rdquo; value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified. This is generally not what was intended. A way around this is to use &lt;code&gt;None&lt;/code&gt; as the default, and explicitly test for it in the body of the function, e.g.:</source>
          <target state="translated">&lt;strong&gt;Los valores de los par&amp;aacute;metros predeterminados se eval&amp;uacute;an de izquierda a derecha cuando se ejecuta la definici&amp;oacute;n de la funci&amp;oacute;n.&lt;/strong&gt; Esto significa que la expresi&amp;oacute;n se eval&amp;uacute;a una vez, cuando se define la funci&amp;oacute;n, y que se utiliza el mismo valor &quot;precalculado&quot; para cada llamada. Esto es especialmente importante para entender cuando un par&amp;aacute;metro predeterminado es un objeto mutable, como una lista o un diccionario: si la funci&amp;oacute;n modifica el objeto (por ejemplo, al agregar un elemento a una lista), el valor predeterminado se modifica en efecto. Esto generalmente no es lo que se pretend&amp;iacute;a. Una forma de evitar esto es usar &lt;code&gt;None&lt;/code&gt; como valor predeterminado y probarlo expl&amp;iacute;citamente en el cuerpo de la funci&amp;oacute;n, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="539d5ec10b781d448886afa96eab4c325719e096" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Edit&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="d7ce856e37c4d17dcd955af410f64cbfd4b44efb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Meta-learning&lt;/strong&gt;: Falling into the trap is actually a very
helpful moment (at least if you are a reflective learner),
because you will subsequently better understand the point 
&quot;Consistency&quot; above and that will
teach you a great deal about Python.</source>
          <target state="translated">&lt;strong&gt;Meta-aprendizaje&lt;/strong&gt; : caer en la trampa es en realidad un momento muy &amp;uacute;til (al menos si eres un alumno reflexivo), porque posteriormente comprender&amp;aacute;s mejor el punto &quot;Consistencia&quot; anterior y eso te ense&amp;ntilde;ar&amp;aacute; mucho sobre Python.</target>
        </trans-unit>
        <trans-unit id="2c97178ae1f0df97cdd3aaefd09767743c8eb65b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Preferred Method&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;M&amp;eacute;todo preferido&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e76f2bbaaca5d9222981a5a9ed9effda9259956d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simplicity&lt;/strong&gt;: The behavior is simple in the following sense:
Most people fall into this trap only once, not several times.</source>
          <target state="translated">&lt;strong&gt;Simplicidad&lt;/strong&gt; : el comportamiento es simple en el siguiente sentido: la mayor&amp;iacute;a de las personas caen en esta trampa solo una vez, no varias veces.</target>
        </trans-unit>
        <trans-unit id="d8e5d785db266e5750b7b9c674b8350975a43b24" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution&lt;/strong&gt;:  a &lt;strong&gt;copy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Soluci&amp;oacute;n&lt;/strong&gt; : una &lt;strong&gt;copia&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37f9748bcb10eff54719d247d7d6981eb44d0507" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sufficient documentation&lt;/strong&gt;: In the most basic Python documentation,
the tutorial, the issue is loudly announced as
an &lt;strong&gt;&quot;Important warning&quot;&lt;/strong&gt; in the &lt;em&gt;first&lt;/em&gt; subsection of Section
&lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#default-argument-values&quot;&gt;&quot;More on Defining Functions&quot;&lt;/a&gt;.
The warning even uses boldface,
which is rarely applied outside of headings.
RTFM: Read the fine manual.</source>
          <target state="translated">&lt;strong&gt;Documentaci&amp;oacute;n suficiente&lt;/strong&gt; : en la &lt;strong&gt;documentaci&amp;oacute;n&lt;/strong&gt; m&amp;aacute;s b&amp;aacute;sica de Python, el tutorial, el problema se anuncia en voz alta como una &lt;strong&gt;&quot;Advertencia importante&quot;&lt;/strong&gt; en la &lt;em&gt;primera&lt;/em&gt; subsecci&amp;oacute;n de la Secci&amp;oacute;n &lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#default-argument-values&quot;&gt;&quot;M&amp;aacute;s sobre la definici&amp;oacute;n de funciones&quot;&lt;/a&gt; . La advertencia incluso usa negrita, que rara vez se aplica fuera de los encabezados. RTFM: Lea el excelente manual.</target>
        </trans-unit>
        <trans-unit id="5e1364752e34f5d31f57fbb793918340fe194bee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usefulness&lt;/strong&gt;: As Frederik Lundh points out in his explanation
of &lt;a href=&quot;http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults&quot;&gt;&quot;Default Parameter Values in Python&quot;&lt;/a&gt;, the
current behavior can be quite useful for advanced programming.
(Use sparingly.)</source>
          <target state="translated">&lt;strong&gt;Utilidad&lt;/strong&gt; : Como Frederik Lundh se&amp;ntilde;ala en su explicaci&amp;oacute;n de &lt;a href=&quot;http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults&quot;&gt;&quot;Valores de par&amp;aacute;metros predeterminados en Python&quot;&lt;/a&gt; , el comportamiento actual puede ser bastante &amp;uacute;til para la programaci&amp;oacute;n avanzada. (Utilizar con moderaci&amp;oacute;n.)</target>
        </trans-unit>
        <trans-unit id="294df7a72d2c1681571db14e9616ce4b1526495e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Wrong Method (probably...)&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;M&amp;eacute;todo incorrecto (probablemente ...)&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="82a5f8350abc0dbeea17f36fef8010fcc85d54f4" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;*&lt;/sup&gt; To verify that Python evaluates the default arguments during compilation of the function, try executing the following:</source>
          <target state="translated">&lt;sup&gt;*&lt;/sup&gt; Para verificar que Python eval&amp;uacute;a los argumentos predeterminados durante la compilaci&amp;oacute;n de la funci&amp;oacute;n, intente ejecutar lo siguiente:</target>
        </trans-unit>
        <trans-unit id="bb413fc5e883d792d1ef3763d765a7965fb2896f" translate="yes" xml:space="preserve">
          <source>====== No. 2 ========</source>
          <target state="translated">======No.2 ========</target>
        </trans-unit>
        <trans-unit id="69abcbfba6763da9ac43abb483ce88455e698517" translate="yes" xml:space="preserve">
          <source>====== No. 3 =======</source>
          <target state="translated">======No.3 ======</target>
        </trans-unit>
        <trans-unit id="b635b4f551391b730421190ef18f36b5a2349cd2" translate="yes" xml:space="preserve">
          <source>A brief introduction. First, there are two type of data types in python, one is simple elementary data type, like numbers, and another data type is objects. Second, when passing data to parameters, python pass elementary data type by value, i.e., make a local copy of the value to a local variable, but pass object by reference, i.e., pointers to the object.</source>
          <target state="translated">Una breve introducción.Primero,hay dos tipos de datos en la pitón,uno es un tipo de datos elementales simples,como los números,y otro tipo de datos son los objetos.En segundo lugar,al pasar los datos a los parámetros,la pitón pasa el tipo de datos elementales por valor,es decir,hace una copia local del valor a una variable local,pero pasa el objeto por referencia,es decir,apunta al objeto.</target>
        </trans-unit>
        <trans-unit id="3241c6873d2d65a534f9b317f8e6387aba7f1c09" translate="yes" xml:space="preserve">
          <source>A manager of mine once had his first encounter with this feature, and called it &quot;a dramatic design flaw&quot; of the language. I replied that the behavior had an underlying explanation, and it is indeed very puzzling and unexpected if you don't understand the internals. However, I was not able to answer (to myself) the following question: what is the reason for binding the default argument at function definition, and not at function execution? I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs?)</source>
          <target state="translated">Un gerente mío tuvo una vez su primer encuentro con esta característica,y la llamó &quot;un defecto de diseño dramático&quot; del lenguaje.Le respondí que el comportamiento tenía una explicación subyacente,y que de hecho es muy desconcertante e inesperado si no se entiende el interior.Sin embargo,no fui capaz de responder (a mí mismo)a la siguiente pregunta:¿cuál es la razón para vincular el argumento por defecto en la definición de la función,y no en la ejecución de la función? Dudo que el comportamiento experimentado tenga un uso práctico (¿quién usó realmente las variables estáticas en C,sin criar bichos?)</target>
        </trans-unit>
        <trans-unit id="b690fd135a267cbcdaf75de80b96af3baa5767c7" translate="yes" xml:space="preserve">
          <source>A simple workaround using None</source>
          <target state="translated">Una solución simple usando &quot;Ninguno&quot;.</target>
        </trans-unit>
        <trans-unit id="bdd7db67e420ecc9dcbd543e9f887304309b4542" translate="yes" xml:space="preserve">
          <source>A useful trick is to bind parameters of a lambda to the &lt;em&gt;current&lt;/em&gt; binding of a variable when the lambda is created.  For example:</source>
          <target state="translated">Un truco &amp;uacute;til es vincular los par&amp;aacute;metros de un lambda al enlace &lt;em&gt;actual&lt;/em&gt; de una variable cuando se crea el lambda. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="66dcf0d939788f48ade0f8205215ced808c313bc" translate="yes" xml:space="preserve">
          <source>Actually, this is not a design flaw, and it is not because of internals, or performance.</source>
          <target state="translated">En realidad,esto no es un defecto de diseño,y no es debido a los internos,o el rendimiento.</target>
        </trans-unit>
        <trans-unit id="995d1d076d3d58278102dc33655d7de6f9e9da69" translate="yes" xml:space="preserve">
          <source>Admitting the above two points, let's explain what happened to the python code. It's only because of passing by reference for objects, but has nothing to do with mutable/immutable, or arguably the fact that &quot;def&quot; statement is executed only once when it is defined.</source>
          <target state="translated">Admitiendo los dos puntos anteriores,vamos a explicar lo que pasó con el código de la pitón.Es sólo por pasar por referencia para los objetos,pero no tiene nada que ver con la inmutabilidad mutable,o posiblemente el hecho de que la declaración &quot;def&quot; se ejecuta sólo una vez cuando se define.</target>
        </trans-unit>
        <trans-unit id="12e60dab7722d48c3d6b49bcd3fb84f98b18afcc" translate="yes" xml:space="preserve">
          <source>After Python executes this definition it will take any default parameters specified (&lt;code&gt;a = []&lt;/code&gt; here) and &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy&quot;&gt;cram them in the &lt;code&gt;__defaults__&lt;/code&gt; attribute for the function object&lt;/a&gt; (relevant section: Callables):</source>
          <target state="translated">Despu&amp;eacute;s de que Python ejecute esta definici&amp;oacute;n, tomar&amp;aacute; los par&amp;aacute;metros predeterminados especificados ( &lt;code&gt;a = []&lt;/code&gt; aqu&amp;iacute;) y &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy&quot;&gt;los &lt;code&gt;__defaults__&lt;/code&gt; en el atributo __defaults__ para el objeto de funci&amp;oacute;n&lt;/a&gt; (secci&amp;oacute;n relevante: Callables):</target>
        </trans-unit>
        <trans-unit id="00ee3bf105e662d4c817e2a1dc2ea4cb63f26aa2" translate="yes" xml:space="preserve">
          <source>All with the power of introspection!</source>
          <target state="translated">¡Todo con el poder de la introspección!</target>
        </trans-unit>
        <trans-unit id="8511aa6f9e2aee5234b37fe72ed01ccf13a1f8e1" translate="yes" xml:space="preserve">
          <source>Already busy topic, but from what I read here, the following helped me realizing how it's working internally:</source>
          <target state="translated">Ya es un tema muy ocupado,pero por lo que leí aquí,lo siguiente me ayudó a darme cuenta de cómo funciona internamente:</target>
        </trans-unit>
        <trans-unit id="edef5af058c46851da7320ae99d9fe37689e0b06" translate="yes" xml:space="preserve">
          <source>An absolutely safe solution is to &lt;strong&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;code&gt;deepcopy&lt;/code&gt;&lt;/strong&gt; the input object first and then to do whatever with the copy.</source>
          <target state="translated">Una soluci&amp;oacute;n absolutamente segura es &lt;strong&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/strong&gt; o hacer una &lt;strong&gt;copia&lt;/strong&gt; &lt;strong&gt; &lt;code&gt;deepcopy&lt;/code&gt; &lt;/strong&gt; del objeto de entrada primero y luego hacer lo que sea con la copia.</target>
        </trans-unit>
        <trans-unit id="09883d93fd6b6978404b7d03e6adc34d60b2d91d" translate="yes" xml:space="preserve">
          <source>Anyone tinkering with Python long enough has been bitten (or torn to pieces) by the following issue:</source>
          <target state="translated">Cualquiera que haya jugueteado con Python el tiempo suficiente ha sido mordido (o despedazado)por el siguiente asunto:</target>
        </trans-unit>
        <trans-unit id="7870ab2e57db73f3c412a09b43f15db1bdd86aa3" translate="yes" xml:space="preserve">
          <source>As others have extensively commented, the list parameter is bound to the function when it is defined as opposed to when it is executed.  Because lists and dictionaries are mutable, any alteration to this parameter will affect other calls to this function.  As a result, subsequent calls to the function will receive this shared list which may have been altered by any other calls to the function.  Worse yet, two parameters are using this function's shared parameter at the same time oblivious to the changes made by the other.</source>
          <target state="translated">Como otros han comentado extensamente,el parámetro de la lista está vinculado a la función cuando se define y no cuando se ejecuta.Debido a que las listas y los diccionarios son mutables,cualquier alteración de este parámetro afectará a otras llamadas a esta función.Como resultado,las llamadas posteriores a la función recibirán esta lista compartida que puede haber sido alterada por cualquier otra llamada a la función.Peor aún,dos parámetros están usando el parámetro compartido de esta función al mismo tiempo sin tener en cuenta los cambios realizados por el otro.</target>
        </trans-unit>
        <trans-unit id="32ec561bfb975a7dfa873e1e6e2af0f1d887859e" translate="yes" xml:space="preserve">
          <source>As soon as you get to think into this way, then it completely makes sense: a function is an object being evaluated on its definition; default parameters are kind of &quot;member data&quot; and therefore their state may change from one call to the other - exactly as in any other object.</source>
          <target state="translated">Tan pronto como se llega a pensar de esta manera,entonces tiene todo el sentido:una función es un objeto que está siendo evaluado en su definición;los parámetros por defecto son una especie de &quot;datos de miembros&quot; y por lo tanto su estado puede cambiar de una llamada a la otra-exactamente como en cualquier otro objeto.</target>
        </trans-unit>
        <trans-unit id="1bfc5029b5667353a593e8232b61d516f6f5fa28" translate="yes" xml:space="preserve">
          <source>As the &lt;a href=&quot;https://docs.python.org/tutorial/controlflow.html#default-argument-values&quot;&gt;tutorial section on control flow&lt;/a&gt; says:</source>
          <target state="translated">Como dice la &lt;a href=&quot;https://docs.python.org/tutorial/controlflow.html#default-argument-values&quot;&gt;secci&amp;oacute;n&lt;/a&gt; del tutorial sobre el flujo de control :</target>
        </trans-unit>
        <trans-unit id="8b63ee9af6651f22cd0d28d64f81656efa3a8b0b" translate="yes" xml:space="preserve">
          <source>As you can see, there &lt;em&gt;is&lt;/em&gt; a performance benefit when using immutable default arguments.  This can make a difference if it's a frequently called function or the default argument takes a long time to construct.  Also, bear in mind that Python isn't C.  In C you have constants that are pretty much free.  In Python you don't have this benefit.</source>
          <target state="translated">Como puede ver, hay un beneficio de rendimiento cuando se utilizan argumentos predeterminados inmutables. Esto puede marcar la diferencia si es una funci&amp;oacute;n llamada con frecuencia o si el argumento predeterminado tarda mucho en construirse. Adem&amp;aacute;s, tenga en cuenta que Python no es C. En C tiene constantes que son pr&amp;aacute;cticamente gratuitas. En Python no tienes este beneficio.</target>
        </trans-unit>
        <trans-unit id="0af2a822a9873fb57c1a705017e412da7cf6eae6" translate="yes" xml:space="preserve">
          <source>At any time, if the caller doesn't tell us what &lt;code&gt;a&lt;/code&gt; is, we reuse &lt;code&gt;pavlo&lt;/code&gt;.</source>
          <target state="translated">En cualquier momento, si la persona que llama no nos dice qu&amp;eacute; es, reutilizamos &lt;code&gt;pavlo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a9041c4d4930adfbd1e5a18d381ab82f682a692" translate="yes" xml:space="preserve">
          <source>Baczek made an interesting example. Together with most of your comments and Utaal's in particular, I elaborated further:</source>
          <target state="translated">Baczek hizo un ejemplo interesante.Junto con la mayoría de sus comentarios y los de Utaal en particular,lo elaboré más:</target>
        </trans-unit>
        <trans-unit id="80f28b6534c5364d872c03c837c8604f92ca736d" translate="yes" xml:space="preserve">
          <source>But this is why the usual instruction to new users is to create their default arguments like this instead:</source>
          <target state="translated">Pero por eso la instrucción habitual para los nuevos usuarios es crear sus argumentos por defecto como este en su lugar:</target>
        </trans-unit>
        <trans-unit id="ec8e7d1b53f4a45c292a101f3cc7d8154605e8fd" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;foo()&lt;/code&gt; again modifies &lt;code&gt;pavlo&lt;/code&gt; again:</source>
          <target state="translated">Llamar a &lt;code&gt;foo()&lt;/code&gt; nuevamente modifica &lt;code&gt;pavlo&lt;/code&gt; nuevamente:</target>
        </trans-unit>
        <trans-unit id="7f12be39dc6279d3fabca7bbf354112e20d8c45e" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;foo&lt;/code&gt; without overriding a default uses that default's value from &lt;code&gt;foo.func_defs&lt;/code&gt;. In this case, &lt;code&gt;foo.func_defs[0]&lt;/code&gt; is used for &lt;code&gt;a&lt;/code&gt; within function object's code scope. Changes to &lt;code&gt;a&lt;/code&gt; change &lt;code&gt;foo.func_defs[0]&lt;/code&gt;, which is part of the &lt;code&gt;foo&lt;/code&gt; object and persists between execution of the code in &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">Llamar a &lt;code&gt;foo&lt;/code&gt; sin anular un valor predeterminado utiliza el valor predeterminado de &lt;code&gt;foo.func_defs&lt;/code&gt; . En este caso, &lt;code&gt;foo.func_defs[0]&lt;/code&gt; se utiliza para el alcance del c&amp;oacute;digo de un objeto dentro de la funci&amp;oacute;n. Cambios en &lt;code&gt;a&lt;/code&gt; cambio &lt;code&gt;foo.func_defs[0]&lt;/code&gt; , que es parte del objeto &lt;code&gt;foo&lt;/code&gt; y persiste entre la ejecuci&amp;oacute;n del c&amp;oacute;digo en &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bbb1f97b956cffee0de7b85c6ac5416fc49a2bd" translate="yes" xml:space="preserve">
          <source>Compare this:</source>
          <target state="translated">Compara esto:</target>
        </trans-unit>
        <trans-unit id="d0b35f2e80cf4078de3821051d01800d2a02ba30" translate="yes" xml:space="preserve">
          <source>Conclusion:</source>
          <target state="translated">Conclusion:</target>
        </trans-unit>
        <trans-unit id="89101438b832bbb4fe2957ecf228b15803627679" translate="yes" xml:space="preserve">
          <source>Consider the code:</source>
          <target state="translated">Considere el código:</target>
        </trans-unit>
        <trans-unit id="50ce20ee2ced0781e4776bbf85a113d06f364543" translate="yes" xml:space="preserve">
          <source>Consistency already says &quot;at definition&quot;: everything else of &lt;code&gt;def &amp;lt;name&amp;gt;(&amp;lt;args=defaults&amp;gt;):&lt;/code&gt; is best evaluated at definition as well. Delaying parts of it would be the astonishing choice.</source>
          <target state="translated">La consistencia ya dice &quot;en la definici&amp;oacute;n&quot;: todo lo dem&amp;aacute;s de &lt;code&gt;def &amp;lt;name&amp;gt;(&amp;lt;args=defaults&amp;gt;):&lt;/code&gt; se eval&amp;uacute;a mejor en la definici&amp;oacute;n. Retrasar partes de ella ser&amp;iacute;a la elecci&amp;oacute;n asombrosa.</target>
        </trans-unit>
        <trans-unit id="5e80e76fecb25c751bc0072a050074d6bf8b3a02" translate="yes" xml:space="preserve">
          <source>Default arguments get evaluated at the time the function is compiled into a function object. When used by the function, multiple times by that function, they are and remain the same object.</source>
          <target state="translated">Los argumentos por defecto se evalúan en el momento en que la función se compila en un objeto de función.Cuando son utilizados por la función,varias veces por esa función,son y siguen siendo el mismo objeto.</target>
        </trans-unit>
        <trans-unit id="0a13adb02282a5b13ea712ef898af3b40b3c9925" translate="yes" xml:space="preserve">
          <source>Defining a function affects two scopes: the defining scope &lt;em&gt;containing&lt;/em&gt; the function, and the execution  scope &lt;em&gt;contained by&lt;/em&gt; the function. While it is pretty clear how blocks map to scopes, the question is where &lt;code&gt;def &amp;lt;name&amp;gt;(&amp;lt;args=defaults&amp;gt;):&lt;/code&gt; belongs to:</source>
          <target state="translated">La definici&amp;oacute;n de una funci&amp;oacute;n afecta a dos &amp;aacute;mbitos: el &amp;aacute;mbito de definici&amp;oacute;n que &lt;em&gt;contiene&lt;/em&gt; la funci&amp;oacute;n y el &amp;aacute;mbito de ejecuci&amp;oacute;n &lt;em&gt;contenido por&lt;/em&gt; la funci&amp;oacute;n. Si bien est&amp;aacute; bastante claro c&amp;oacute;mo se asignan los bloques a los &amp;aacute;mbitos, la pregunta es d&amp;oacute;nde &lt;code&gt;def &amp;lt;name&amp;gt;(&amp;lt;args=defaults&amp;gt;):&lt;/code&gt; pertenece a:</target>
        </trans-unit>
        <trans-unit id="722360c4795e6584aab950e4f9ab28bf53d453fe" translate="yes" xml:space="preserve">
          <source>Demonstration</source>
          <target state="translated">Demonstration</target>
        </trans-unit>
        <trans-unit id="0cf2dad6fd4f2a353fd61dd22952442419c00063" translate="yes" xml:space="preserve">
          <source>Does this violate the principle of &quot;Least Astonishment&quot;?</source>
          <target state="translated">¿Viola esto el principio del &quot;Asombro mínimo&quot;?</target>
        </trans-unit>
        <trans-unit id="87ae29dc1cc2a0f0b1d8ff4a04b54a9e84f78784" translate="yes" xml:space="preserve">
          <source>Doing the binding inside the function would mean that &lt;code&gt;x&lt;/code&gt; is effectively bound to the specified default when the function is called, not defined, something that would present a deep flaw: the &lt;code&gt;def&lt;/code&gt; line would be &quot;hybrid&quot; in the sense that part of the binding (of the function object) would happen at definition, and part (assignment of default parameters) at function invocation time.</source>
          <target state="translated">Hacer el enlace dentro de la funci&amp;oacute;n significar&amp;iacute;a que &lt;code&gt;x&lt;/code&gt; est&amp;aacute; efectivamente vinculado al valor predeterminado especificado cuando se llama a la funci&amp;oacute;n, no est&amp;aacute; definida, algo que presentar&amp;iacute;a un defecto profundo: la l&amp;iacute;nea &lt;code&gt;def&lt;/code&gt; ser&amp;iacute;a &quot;h&amp;iacute;brida&quot; en el sentido de que parte del enlace (del objeto de funci&amp;oacute;n) suceder&amp;iacute;a en la definici&amp;oacute;n, y parte (asignaci&amp;oacute;n de par&amp;aacute;metros predeterminados) en el momento de invocaci&amp;oacute;n de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a1bc1de19c4470f909f862dada03b7e62dff2905" translate="yes" xml:space="preserve">
          <source>Each button can hold a distinct callback function which will display different value of &lt;code&gt;i&lt;/code&gt;. I can provide an example to show this:</source>
          <target state="translated">Cada bot&amp;oacute;n puede contener una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada distinta que mostrar&amp;aacute; un valor diferente de &lt;code&gt;i&lt;/code&gt; . Puedo proporcionar un ejemplo para mostrar esto:</target>
        </trans-unit>
        <trans-unit id="3535364419d36fc620e4f5493d86ed8c6d64572c" translate="yes" xml:space="preserve">
          <source>Equivalent code:</source>
          <target state="translated">Código equivalente:</target>
        </trans-unit>
        <trans-unit id="ff956d2a192938cf9d92d4c6a19f3ae8b72325fa" translate="yes" xml:space="preserve">
          <source>Every other answer explains why this is actually a nice and desired behavior, or why you shouldn't be needing this anyway. Mine is for those stubborn ones who want to exercise their right to bend the language to their will, not the other way around.</source>
          <target state="translated">Todas las demás respuestas explican por qué es un comportamiento agradable y deseado,o por qué no deberías necesitarlo de todas formas.La mía es para aquellos tercos que quieren ejercer su derecho a doblar el lenguaje a su voluntad,no al revés.</target>
        </trans-unit>
        <trans-unit id="0dd24b3cfa0f1397c657fd1c280dfe16bb9e3f42" translate="yes" xml:space="preserve">
          <source>Example problem for &lt;a href=&quot;https://stackoverflow.com/q/13484107/448474&quot;&gt;a similar SO question&lt;/a&gt;</source>
          <target state="translated">Problema de ejemplo para &lt;a href=&quot;https://stackoverflow.com/q/13484107/448474&quot;&gt;una pregunta SO similar&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="bb7c7223c0f7cca03529ae9f865e01923e18d2e1" translate="yes" xml:space="preserve">
          <source>From the above explanations, we can see that the &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;effbot&lt;/a&gt; webpage recommended in the accepted answer failed to give a relevant answer to this question. What is more, I think a point in the effbot webpage is wrong. I think the code regarding the UI.Button is correct:</source>
          <target state="translated">De las explicaciones anteriores, podemos ver que la p&amp;aacute;gina web de &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;efbot&lt;/a&gt; recomendada en la respuesta aceptada no dio una respuesta relevante a esta pregunta. Adem&amp;aacute;s, creo que un punto en la p&amp;aacute;gina web de effbot est&amp;aacute; mal. Creo que el c&amp;oacute;digo con respecto a la interfaz de usuario es correcto:</target>
        </trans-unit>
        <trans-unit id="ffce6790c5edcbed68ecf56b4ebcce15bf2962a7" translate="yes" xml:space="preserve">
          <source>Function After Execution:</source>
          <target state="translated">Función después de la ejecución:</target>
        </trans-unit>
        <trans-unit id="c6a884852d8c2a2883d38ae384496603d3a89ca1" translate="yes" xml:space="preserve">
          <source>Function Before Execution:</source>
          <target state="translated">Función antes de la ejecución:</target>
        </trans-unit>
        <trans-unit id="31a489ea01d856da46704976b42a3727c3bf5489" translate="yes" xml:space="preserve">
          <source>Functions are objects (explained well in the accepted answer).</source>
          <target state="translated">Las funciones son objetos (explicado bien en la respuesta aceptada).</target>
        </trans-unit>
        <trans-unit id="33152c3a458131f199d601848f2ff938e88b23ff" translate="yes" xml:space="preserve">
          <source>Given a simple little function &lt;code&gt;func&lt;/code&gt; defined as:</source>
          <target state="translated">Dada una funci&amp;oacute;n peque&amp;ntilde;a y simple, definida como:</target>
        </trans-unit>
        <trans-unit id="dc7ed69775b531605c40861499142c0c9436b2e1" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;foo&lt;/code&gt; is an object and &lt;code&gt;a&lt;/code&gt; is an attribute of &lt;code&gt;foo&lt;/code&gt; (available at &lt;code&gt;foo.func_defs[0]&lt;/code&gt;). Since &lt;code&gt;a&lt;/code&gt; is a list, &lt;code&gt;a&lt;/code&gt; is mutable and is thus a read-write attribute of &lt;code&gt;foo&lt;/code&gt;. It is initialized to the empty list as specified by the signature when the function is instantiated, and is available for reading and writing as long as the function object exists.</source>
          <target state="translated">Aqu&amp;iacute; &lt;code&gt;foo&lt;/code&gt; es un objeto y &lt;code&gt;a&lt;/code&gt; es un atributo de &lt;code&gt;foo&lt;/code&gt; (disponible en &lt;code&gt;foo.func_defs[0]&lt;/code&gt; ). Como &lt;code&gt;a&lt;/code&gt; es una lista, &lt;code&gt;a&lt;/code&gt; es mutable y, por lo tanto, es un atributo de lectura y escritura de &lt;code&gt;foo&lt;/code&gt; . Se inicializa en la lista vac&amp;iacute;a seg&amp;uacute;n lo especificado por la firma cuando se instancia la funci&amp;oacute;n, y est&amp;aacute; disponible para leer y escribir mientras exista el objeto de funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a60b329ec4b9d85ee4941270916f4f4532974b74" translate="yes" xml:space="preserve">
          <source>Here's a demonstration - you can verify that they are the same object each time they are referenced by</source>
          <target state="translated">Aquí hay una demostración-se puede verificar que son el mismo objeto cada vez que son referidos por</target>
        </trans-unit>
        <trans-unit id="6fd4504fd06148ba79eed7136bc3c11e43b9b3ff" translate="yes" xml:space="preserve">
          <source>Hopefully it's enough to show that not executing the default argument expressions at the execution time of the &lt;code&gt;def&lt;/code&gt; statement isn't easy or doesn't make sense, or both.</source>
          <target state="translated">Con suerte, es suficiente para mostrar que no ejecutar las expresiones de argumento predeterminadas en el momento de ejecuci&amp;oacute;n de la declaraci&amp;oacute;n &lt;code&gt;def&lt;/code&gt; no es f&amp;aacute;cil o no tiene sentido, o ambas cosas.</target>
        </trans-unit>
        <trans-unit id="efcda094ecf8e11cea988762da8f1af71d231058" translate="yes" xml:space="preserve">
          <source>However, supposed later on in the code, I do something like</source>
          <target state="translated">Sin embargo,se supone que más adelante en el código,hago algo como</target>
        </trans-unit>
        <trans-unit id="b3f69934c5bc363d742e1cab32463a9509580910" translate="yes" xml:space="preserve">
          <source>However, we've lost the ability to introspect, and see what the default arguments &lt;em&gt;are&lt;/em&gt;.  Because the objects haven't been constructed, we can't ever get hold of them without actually calling the function.  The best we could do is to store off the source code and return that as a string.</source>
          <target state="translated">Sin embargo, hemos perdido la capacidad de introspecci&amp;oacute;n y ver cu&amp;aacute;les &lt;em&gt;son los&lt;/em&gt; argumentos predeterminados. Debido a que los objetos no han sido construidos, no podemos obtenerlos sin llamar a la funci&amp;oacute;n. Lo mejor que podemos hacer es almacenar el c&amp;oacute;digo fuente y devolverlo como una cadena.</target>
        </trans-unit>
        <trans-unit id="62218df64348dca379d0be7d12cf753886ac8753" translate="yes" xml:space="preserve">
          <source>I agree it's a gotcha when you try to use default constructors, though.</source>
          <target state="translated">Estoy de acuerdo en que es un error cuando tratas de usar constructores por defecto,sin embargo.</target>
        </trans-unit>
        <trans-unit id="666a646463dc2675694b853c3a8d9d31ebba0462" translate="yes" xml:space="preserve">
          <source>I am going to demonstrate an alternative structure to pass a default list value to a function (it works equally well with dictionaries).</source>
          <target state="translated">Voy a demostrar una estructura alternativa para pasar un valor de lista por defecto a una función (funciona igual de bien con los diccionarios).</target>
        </trans-unit>
        <trans-unit id="79228cdbb3c7bc21ef5719f719a1a0dd6dfbf36b" translate="yes" xml:space="preserve">
          <source>I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs ?)</source>
          <target state="translated">Dudo que el comportamiento experimentado tenga un uso práctico (¿quién realmente usó variables estáticas en C,sin criar bichos?)</target>
        </trans-unit>
        <trans-unit id="43c16dd324ef24fec2c80514d01a8fbc2f28b9ba" translate="yes" xml:space="preserve">
          <source>I found it very clear, and I really suggest reading it for a better knowledge of how function objects work.</source>
          <target state="translated">Lo encontré muy claro,y realmente sugiero leerlo para un mejor conocimiento de cómo funcionan los objetos funcionales.</target>
        </trans-unit>
        <trans-unit id="e438a0bb860a536fec364c3e57d8144f3738861a" translate="yes" xml:space="preserve">
          <source>I know nothing about the Python interpreter inner workings (and I'm not an expert in compilers and interpreters either) so don't blame me if I propose anything unsensible or impossible.</source>
          <target state="translated">No sé nada sobre el funcionamiento interno del intérprete de Python (y tampoco soy experto en compiladores e intérpretes)así que no me culpes si propongo algo insensible o imposible.</target>
        </trans-unit>
        <trans-unit id="71d7286361ceb622e718e696e33275d64365bcc6" translate="yes" xml:space="preserve">
          <source>I know, I know: that's a closure. Alternatively Python might provide a keyword to force definition-time binding:</source>
          <target state="translated">Lo sé,lo sé:eso es un cierre.Alternativamente Python podría proporcionar una palabra clave para forzar la definición-tiempo vinculante:</target>
        </trans-unit>
        <trans-unit id="33854cd2f920283abdfe15942535e15a55a4bbc1" translate="yes" xml:space="preserve">
          <source>I personally like Python's current approach: default function arguments are evaluated when the function is defined and that object is always the default. I suppose they could special-case using an empty list, but that kind of special casing would cause even more astonishment, not to mention be backwards incompatible.</source>
          <target state="translated">Personalmente me gusta el enfoque actual de Python:los argumentos de la función por defecto se evalúan cuando se define la función y ese objeto es siempre el predeterminado.Supongo que podrían ser casos especiales usando una lista vacía,pero ese tipo de caso especial causaría aún más asombro,sin mencionar que sería incompatible al revés.</target>
        </trans-unit>
        <trans-unit id="653d0fdb648a0e875a98321cd116616aaa059e3d" translate="yes" xml:space="preserve">
          <source>I sometimes exploit this behavior as an alternative to the following pattern:</source>
          <target state="translated">A veces exploto este comportamiento como una alternativa al siguiente patrón:</target>
        </trans-unit>
        <trans-unit id="1136692ed919e61fb64464e3c7faa84bec1902d1" translate="yes" xml:space="preserve">
          <source>I think the answer to this question lies in how python pass data to parameter (pass by value or by reference), not mutability or how python handle the &quot;def&quot; statement.</source>
          <target state="translated">Creo que la respuesta a esta pregunta radica en cómo la pitón pasa los datos al parámetro (pasar por valor o por referencia),no en la mutabilidad o en cómo la pitón maneja la declaración &quot;def&quot;.</target>
        </trans-unit>
        <trans-unit id="344b69c74ad5e09938fa343f9bd784e609ba3f79" translate="yes" xml:space="preserve">
          <source>I used to think that creating the objects at runtime would be the better approach.  I'm less certain now, since you do lose some useful features, though it may be worth it regardless simply to prevent newbie confusion.  The disadvantages of doing so are:</source>
          <target state="translated">Solía pensar que crear los objetos en tiempo de ejecución sería el mejor enfoque.Ahora estoy menos seguro,ya que se pierden algunas características útiles,aunque puede valer la pena de todos modos,simplemente para evitar la confusión de los novatos.Las desventajas de hacerlo son:</target>
        </trans-unit>
        <trans-unit id="f45c52b12ce7f1ce19a9035ae4c48dd9daa005c0" translate="yes" xml:space="preserve">
          <source>I'll give you a hint.  Here's the disassembly (see &lt;a href=&quot;http://docs.python.org/library/dis.html&quot;&gt;http://docs.python.org/library/dis.html&lt;/a&gt;):</source>
          <target state="translated">Te dar&amp;eacute; una pista. Aqu&amp;iacute; est&amp;aacute; el desmontaje (ver &lt;a href=&quot;http://docs.python.org/library/dis.html&quot;&gt;http://docs.python.org/library/dis.html&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="63b9797c54d1f5b22108348202db1c0d9f27b5eb" translate="yes" xml:space="preserve">
          <source>I'm &lt;em&gt;really&lt;/em&gt; surprised no one has performed the insightful introspection offered by Python (&lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; apply) on callables.</source>
          <target state="translated">Estoy &lt;em&gt;realmente&lt;/em&gt; sorprendido de que nadie haya realizado la perspicaz introspecci&amp;oacute;n ofrecida por Python (se aplican &lt;code&gt;2&lt;/code&gt; y &lt;code&gt;3&lt;/code&gt; ) en las llamadas.</target>
        </trans-unit>
        <trans-unit id="d560ac161f04d984906ccae5894dd8e5c74ba7d6" translate="yes" xml:space="preserve">
          <source>I'm gonna give you what I see as a useful example.</source>
          <target state="translated">Te voy a dar lo que veo como un ejemplo útil.</target>
        </trans-unit>
        <trans-unit id="0ab4a274949e60b1dc8d810f1b8b6f0326e083c2" translate="yes" xml:space="preserve">
          <source>I've used this for instantiating client classes that access external resources, and also for creating dicts or lists for memoization.</source>
          <target state="translated">He usado esto para instanciar clases de clientes que acceden a recursos externos,y también para crear dictados o listas para la memorización.</target>
        </trans-unit>
        <trans-unit id="d4a17f0810bff8f4684352651e72c003f9d91265" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pavlo&lt;/code&gt; is mutable (modifiable), and &lt;code&gt;foo&lt;/code&gt; ends up modifying it, an effect we notice the next time &lt;code&gt;foo&lt;/code&gt; is called without specifying &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;pavlo&lt;/code&gt; es mutable (modificable) y &lt;code&gt;foo&lt;/code&gt; termina modific&amp;aacute;ndolo, un efecto que notamos la pr&amp;oacute;xima vez que se llama &lt;code&gt;foo&lt;/code&gt; sin especificar &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2fde0c1e8b0aff298d01bf5aa7a719c471660837" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;singleton&lt;/code&gt; is only used by &lt;code&gt;use_singleton&lt;/code&gt;, I like the following pattern as a replacement:</source>
          <target state="translated">Si &lt;code&gt;singleton&lt;/code&gt; solo lo usa &lt;code&gt;use_singleton&lt;/code&gt; , me gusta el siguiente patr&amp;oacute;n como reemplazo:</target>
        </trans-unit>
        <trans-unit id="12b09ce5fbf5f05e7151c2f7f01217b353055234" translate="yes" xml:space="preserve">
          <source>If call-time evaluation is used, then the expensive function is called every time your function is used without an argument.  You'd either pay an expensive price on each call, or need to manually cache the value externally, polluting your namespace and adding verbosity.</source>
          <target state="translated">Si se utiliza la evaluación de tiempo de llamada,entonces se llama a la función cara cada vez que se utiliza su función sin un argumento.Pagarías un alto precio por cada llamada,o necesitarías almacenar manualmente el valor en caché externamente,contaminando tu espacio de nombres y añadiendo verbosidad.</target>
        </trans-unit>
        <trans-unit id="07abc281d43c1a8d21b4d3e16a4f89b6450862f6" translate="yes" xml:space="preserve">
          <source>If we execute &lt;code&gt;x[7]()&lt;/code&gt; we'll get 7 as expected, and &lt;code&gt;x[9]()&lt;/code&gt; will gives 9, another value of &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">Si ejecutamos &lt;code&gt;x[7]()&lt;/code&gt; obtendremos 7 como se esperaba, y &lt;code&gt;x[9]()&lt;/code&gt; dar&amp;aacute; 9, otro valor de &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e5d0faf4767c71322e96d58c89f44e2f7d7004b" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want the default to be shared between subsequent calls,
  you can write the function like this instead:</source>
          <target state="translated">Si no desea que el valor predeterminado se comparta entre llamadas posteriores, puede escribir la funci&amp;oacute;n de esta manera:</target>
        </trans-unit>
        <trans-unit id="a78835080b9cc304e7940760ebe5a74f9feb7089" translate="yes" xml:space="preserve">
          <source>If you need to destructively manipulate a local temporary in the course of computing something, and you need to start your manipulation from an argument value, you need to make a copy.</source>
          <target state="translated">Si necesitas manipular destructivamente un temporal local en el curso de la computación de algo,y necesitas comenzar tu manipulación a partir de un valor de argumento,necesitas hacer una copia.</target>
        </trans-unit>
        <trans-unit id="ffce4f7ff1a5649ba9873493748437dec4a51845" translate="yes" xml:space="preserve">
          <source>In any case, Effbot has a very nice explanation of the reasons for this behavior in &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;Default Parameter Values in Python&lt;/a&gt;.</source>
          <target state="translated">En cualquier caso, Effbot tiene una muy buena explicaci&amp;oacute;n de las razones de este comportamiento en los &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;valores de par&amp;aacute;metros predeterminados en Python&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bbd472fc6429abfdafc9add5359fa997a6a79049" translate="yes" xml:space="preserve">
          <source>In other words, instead of evaluating default parameters, why not store each of them, and evaluate them when the function is called?</source>
          <target state="translated">En otras palabras,en lugar de evaluar los parámetros predeterminados,¿por qué no almacenar cada uno de ellos y evaluarlos cuando se llama a la función?</target>
        </trans-unit>
        <trans-unit id="44af44eea85fed48a31ed0183c38ed921ac1aabb" translate="yes" xml:space="preserve">
          <source>Input parameters objects shouldn't be modified in place (mutated) nor they should not be binded into an object returned by the function. (If we prefere programming without side effects which is strongly recommended. see &lt;a href=&quot;http://en.wikipedia.org/wiki/Side_effect_%28computer_science%29&quot;&gt;Wiki about &quot;side effect&quot;&lt;/a&gt; (The first two paragraphs are relevent in this context.)
.)</source>
          <target state="translated">Los objetos de par&amp;aacute;metros de entrada no deben modificarse en su lugar (mutar) ni tampoco deben vincularse a un objeto devuelto por la funci&amp;oacute;n. (Si preferimos la programaci&amp;oacute;n sin efectos secundarios, lo cual es muy recomendable. Ver &lt;a href=&quot;http://en.wikipedia.org/wiki/Side_effect_%28computer_science%29&quot;&gt;Wiki sobre &quot;efectos secundarios&quot;&lt;/a&gt; (Los dos primeros p&amp;aacute;rrafos son relevantes en este contexto).)</target>
        </trans-unit>
        <trans-unit id="f428f84105fcce031afe75598a91587f547827e4" translate="yes" xml:space="preserve">
          <source>It comes simply from the fact that functions in Python are first-class objects, and not only a piece of code.</source>
          <target state="translated">Viene simplemente del hecho de que las funciones en Python son objetos de primera clase,y no sólo un pedazo de código.</target>
        </trans-unit>
        <trans-unit id="8d35c5155e3a7198376d876ba2ac22709cf724ee" translate="yes" xml:space="preserve">
          <source>It is a confusing feature and it is unfortunate in Python.</source>
          <target state="translated">Es una característica confusa y es desafortunada en Python.</target>
        </trans-unit>
        <trans-unit id="2d1e31d0ad97904bac773140d97936823786bfd4" translate="yes" xml:space="preserve">
          <source>It may be true that switching horses in midstream here would be asking for significant breakage, and that there could be more problems created by changing Python to intuitively handle Stefano's opening snippet. And it may be true that someone who knew Python internals well could explain a minefield of consequences. &lt;em&gt;However,&lt;/em&gt;</source>
          <target state="translated">Puede ser cierto que cambiar caballos en la mitad de la corriente aqu&amp;iacute; requerir&amp;iacute;a una rotura significativa, y que podr&amp;iacute;a haber m&amp;aacute;s problemas creados al cambiar Python para manejar intuitivamente el fragmento de apertura de Stefano. Y puede ser cierto que alguien que conociera bien las partes internas de Python podr&amp;iacute;a explicar un campo minado de consecuencias. &lt;em&gt;Sin embargo,&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f7b0650553f1d03b5617ea73a2e594063dbeff1b" translate="yes" xml:space="preserve">
          <source>It may be true that:</source>
          <target state="translated">Puede ser cierto que:</target>
        </trans-unit>
        <trans-unit id="c88ae6b372096f323f1ae38ef63c959269132a80" translate="yes" xml:space="preserve">
          <source>It shouldn't be neither saved in any &lt;em&gt;public&lt;/em&gt; attribute of an instance returned by this function. (Assuming that &lt;em&gt;private&lt;/em&gt; attributes of instance should not be modified from outside of this class or subclasses by convention. i.e. &lt;code&gt;_var1&lt;/code&gt; is a private attribute )</source>
          <target state="translated">No debe guardarse ni en ning&amp;uacute;n atributo &lt;em&gt;p&amp;uacute;blico&lt;/em&gt; de una instancia devuelta por esta funci&amp;oacute;n. (Suponiendo que &lt;em&gt;los&lt;/em&gt; atributos &lt;em&gt;privados&lt;/em&gt; de instancia no se deben modificar desde fuera de esta clase o subclases por convenci&amp;oacute;n. Es decir, &lt;code&gt;_var1&lt;/code&gt; es un atributo privado)</target>
        </trans-unit>
        <trans-unit id="a1d3a576ba48952d86d8cfdfe398ef2bddea704e" translate="yes" xml:space="preserve">
          <source>It's a performance optimization.  As a result of this functionality, which of these two function calls do you think is faster?</source>
          <target state="translated">Es una optimización del rendimiento.Como resultado de esta funcionalidad,¿cuál de estas dos llamadas de función crees que es más rápida?</target>
        </trans-unit>
        <trans-unit id="0359bac5a1c47bf095f12d4add2a3b1b5b445f4a" translate="yes" xml:space="preserve">
          <source>It's important to note that the above solution breaks if you try to use keyword args, like so:</source>
          <target state="translated">Es importante tener en cuenta que la solución anterior se rompe si tratas de usar arcos de palabras clave,como así:</target>
        </trans-unit>
        <trans-unit id="b6c89d685ac19d7565519a44bbc4a6d593564a24" translate="yes" xml:space="preserve">
          <source>It's just &quot;How It Works&quot;, and making it work differently in the function case would probably be complicated, and in the class case likely impossible, or at least slow down object instantiation a lot, as you would have to keep the class code around and execute it when objects are created.</source>
          <target state="translated">Es simplemente &quot;Cómo funciona&quot;,y hacer que funcione de forma diferente en el caso de la función sería probablemente complicado,y en el caso de la clase probablemente imposible,o al menos retrasar mucho la instanciación del objeto,ya que habría que mantener el código de la clase alrededor y ejecutarlo cuando se crean los objetos.</target>
        </trans-unit>
        <trans-unit id="fd310ea6b1cae2a6a063f0bd5d873b8e8d185946" translate="yes" xml:space="preserve">
          <source>Just change the function to be:</source>
          <target state="translated">Sólo cambia la función a ser:</target>
        </trans-unit>
        <trans-unit id="7da4eaf92a58f20a9c68b073a49820f4346f33e5" translate="yes" xml:space="preserve">
          <source>Let's now execute this function:</source>
          <target state="translated">Ahora ejecutemos esta función:</target>
        </trans-unit>
        <trans-unit id="fd6ffcde729e6f54a9565146d7555da45d90700c" translate="yes" xml:space="preserve">
          <source>Look back to the original example and consider the above points:</source>
          <target state="translated">Vuelva al ejemplo original y considere los puntos anteriores:</target>
        </trans-unit>
        <trans-unit id="7d52014db1eb1bc10080d5b3576313f9f6997662" translate="yes" xml:space="preserve">
          <source>Many builtin mutable types have a copy method like &lt;code&gt;some_dict.copy()&lt;/code&gt; or &lt;code&gt;some_set.copy()&lt;/code&gt; or can be copied easy like &lt;code&gt;somelist[:]&lt;/code&gt; or &lt;code&gt;list(some_list)&lt;/code&gt;. Every object can be also copied by &lt;code&gt;copy.copy(any_object)&lt;/code&gt; or more thorough by &lt;code&gt;copy.deepcopy()&lt;/code&gt; (the latter useful if the mutable object is composed from mutable objects). Some objects are fundamentally based on side effects like &quot;file&quot; object and can not be meaningfully reproduced by copy. &lt;a href=&quot;http://effbot.org/pyfaq/how-do-i-copy-an-object-in-python.htm&quot;&gt;copying&lt;/a&gt;</source>
          <target state="translated">Muchos tipos mutables incorporados tienen un m&amp;eacute;todo de copia como &lt;code&gt;some_dict.copy()&lt;/code&gt; o &lt;code&gt;some_set.copy()&lt;/code&gt; o pueden copiarse f&amp;aacute;cilmente como &lt;code&gt;somelist[:]&lt;/code&gt; o &lt;code&gt;list(some_list)&lt;/code&gt; . Tambi&amp;eacute;n se puede copiar cada objeto mediante &lt;code&gt;copy.copy(any_object)&lt;/code&gt; o m&amp;aacute;s completo mediante &lt;code&gt;copy.deepcopy()&lt;/code&gt; (este &amp;uacute;ltimo &amp;uacute;til si el objeto mutable est&amp;aacute; compuesto de objetos mutables). Algunos objetos se basan fundamentalmente en efectos secundarios como el objeto &quot;archivo&quot; y no se pueden reproducir de manera significativa mediante copia. &lt;a href=&quot;http://effbot.org/pyfaq/how-do-i-copy-an-object-in-python.htm&quot;&gt;proceso de copiar&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e23f5cbc0bbb2cbb8b27c449a4bcd8e9fbb38b2b" translate="yes" xml:space="preserve">
          <source>No default values in sight in this code, but you get exactly the same problem.</source>
          <target state="translated">No hay valores por defecto a la vista en este código,pero tienes exactamente el mismo problema.</target>
        </trans-unit>
        <trans-unit id="b9b42c390ec8fb15d988160f4dd8c2a52791b6d6" translate="yes" xml:space="preserve">
          <source>Now let's redefine our function using this decorator:</source>
          <target state="translated">Ahora vamos a redefinir nuestra función usando este decorador:</target>
        </trans-unit>
        <trans-unit id="b7e59f92481e8e7835898fa1c85ba3a27d892126" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;pavlo&lt;/code&gt; is [5].</source>
          <target state="translated">Ahora, &lt;code&gt;pavlo&lt;/code&gt; es [5].</target>
        </trans-unit>
        <trans-unit id="362ccf94780188762e961bb582f31f3d92a8d7ee" translate="yes" xml:space="preserve">
          <source>Now, compare this to the example from the documentation on &lt;a href=&quot;http://docs.python.org/tutorial/controlflow.html#default-argument-values&quot;&gt;emulating the default argument behavior of other languages&lt;/a&gt;, such that the function signature defaults are used every time the function is executed:</source>
          <target state="translated">Ahora, compare esto con el ejemplo de la documentaci&amp;oacute;n sobre la &lt;a href=&quot;http://docs.python.org/tutorial/controlflow.html#default-argument-values&quot;&gt;emulaci&amp;oacute;n del comportamiento de argumento predeterminado de otros idiomas&lt;/a&gt; , de modo que los valores predeterminados de la firma de la funci&amp;oacute;n se usen cada vez que se ejecuta la funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="64acff4f47942d13d4f208bda7e869e11d893a33" translate="yes" xml:space="preserve">
          <source>Now, does my map use the value of the &lt;code&gt;StringBuffer&lt;/code&gt; key when it was placed into the map, or does it store the key by reference?  Either way, someone is astonished; either the person who tried to get the object out of the &lt;code&gt;Map&lt;/code&gt; using a value identical to the one they put it in with, or the person who can't seem to retrieve their object even though the key they're using is literally the same object that was used to put it into the map (this is actually why Python doesn't allow its mutable built-in data types to be used as dictionary keys).</source>
          <target state="translated">Ahora, &amp;iquest;utiliza mi mapa el valor de la clave &lt;code&gt;StringBuffer&lt;/code&gt; cuando se coloc&amp;oacute; en el mapa, o almacena la clave por referencia? De cualquier manera, alguien est&amp;aacute; asombrado; ya sea la persona que intent&amp;oacute; sacar el objeto del &lt;code&gt;Map&lt;/code&gt; a usando un valor id&amp;eacute;ntico al que lo coloc&amp;oacute;, o la persona que parece no poder recuperar su objeto a pesar de que la clave que est&amp;aacute;n usando es literalmente la misma objeto que se us&amp;oacute; para ponerlo en el mapa (esta es realmente la raz&amp;oacute;n por la cual Python no permite que sus tipos de datos incorporados mutables se usen como claves de diccionario).</target>
        </trans-unit>
        <trans-unit id="ca1782989bcd41936515ff547e98eb21e1c24f56" translate="yes" xml:space="preserve">
          <source>Now, let's see those &lt;code&gt;__defaults__&lt;/code&gt; again:</source>
          <target state="translated">Ahora, veamos esos &lt;code&gt;__defaults__&lt;/code&gt; nuevamente:</target>
        </trans-unit>
        <trans-unit id="03060fd5df0aea733c344b9b8691c947fcb3b65a" translate="yes" xml:space="preserve">
          <source>Now, suppose the behaviour of defaults could be changed so that this is the equivalent of:</source>
          <target state="translated">Ahora,supongamos que el comportamiento de los incumplimientos puede ser cambiado para que sea el equivalente de:</target>
        </trans-unit>
        <trans-unit id="c8b8bb4b9ae89c0e3c42072a31a62c115adca126" translate="yes" xml:space="preserve">
          <source>Now, when to evaluate &lt;code&gt;default&lt;/code&gt;?</source>
          <target state="translated">Ahora, &amp;iquest;cu&amp;aacute;ndo evaluar el &lt;code&gt;default&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="2d80698d75eb09b54cff119780e3f91af2942726" translate="yes" xml:space="preserve">
          <source>O.k, so an empty list as the single entry in &lt;code&gt;__defaults__&lt;/code&gt;, just as expected.</source>
          <target state="translated">Ok, entonces una lista vac&amp;iacute;a como la entrada &amp;uacute;nica en &lt;code&gt;__defaults__&lt;/code&gt; , tal como se esperaba.</target>
        </trans-unit>
        <trans-unit id="8ee84d967071869b5d4f78c07c4174525b7a125c" translate="yes" xml:space="preserve">
          <source>One answer is probably right there--it would effectively turn every function with default parameters into a closure.  Even if it's all hidden away in the interpreter and not a full-blown closure, the data's got to be stored somewhere.  It'd be slower and use more memory.</source>
          <target state="translated">Una respuesta probablemente esté ahí...convertiría efectivamente cada función con parámetros por defecto en un cierre.Incluso si todo está oculto en el intérprete y no es un cierre completo,los datos tienen que ser almacenados en algún lugar.Sería más lento y utilizaría más memoria.</target>
        </trans-unit>
        <trans-unit id="11b18ef18f03165cd782bc4f836d003ad9d95019" translate="yes" xml:space="preserve">
          <source>Only if the side effect on the actual parameter is required but unwanted on the default parameter then the useful solution is &lt;code&gt;def ...(var1=None):&lt;/code&gt;&lt;code&gt;if var1 is None:&lt;/code&gt;&lt;code&gt;var1 = []&lt;/code&gt;&lt;a href=&quot;http://effbot.org/zone/default-values.htm#what-to-do-instead&quot;&gt;More..&lt;/a&gt;</source>
          <target state="translated">Solo si el efecto secundario sobre el par&amp;aacute;metro real es requerido pero no deseado en el par&amp;aacute;metro predeterminado, entonces la soluci&amp;oacute;n &amp;uacute;til es &lt;code&gt;def ...(var1=None):&lt;/code&gt; &lt;code&gt;if var1 is None:&lt;/code&gt; &lt;code&gt;var1 = []&lt;/code&gt; &lt;a href=&quot;http://effbot.org/zone/default-values.htm#what-to-do-instead&quot;&gt;M&amp;aacute;s ...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="114258caa60ea3edd65afe4bbb8f1463ea7260f5" translate="yes" xml:space="preserve">
          <source>Per &lt;strong&gt;(1)&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;a new local variable also named &lt;code&gt;L&lt;/code&gt; is created in the local scope&lt;/em&gt;&lt;/strong&gt; and used for the remainder of the function call. &lt;code&gt;foo.func_defs[0]&lt;/code&gt; thus remains unchanged for future invocations of &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">Por &lt;strong&gt;(1)&lt;/strong&gt; , &lt;strong&gt;&lt;em&gt;una nueva variable local tambi&amp;eacute;n llamada &lt;code&gt;L&lt;/code&gt; se crea en el &amp;aacute;mbito local&lt;/em&gt;&lt;/strong&gt; y se utiliza para el resto de la llamada a la funci&amp;oacute;n. &lt;code&gt;foo.func_defs[0]&lt;/code&gt; tanto permanece sin cambios para futuras invocaciones de &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d87aa1b1e7324f25c59d457e5df3e2ceb743377" translate="yes" xml:space="preserve">
          <source>Per Brett Slatkin's &quot;Effective Python: 59 Specific Ways to Write Better Python&quot;, &lt;em&gt;Item 20: Use &lt;code&gt;None&lt;/code&gt; and Docstrings to specify dynamic default arguments&lt;/em&gt; (p. 48)</source>
          <target state="translated">Seg&amp;uacute;n &quot;Python eficaz: 59 formas espec&amp;iacute;ficas de escribir mejor Python&quot; de Brett Slatkin, &lt;em&gt;Elemento 20: Usar &lt;code&gt;None&lt;/code&gt; y Docstrings para especificar argumentos din&amp;aacute;micos predeterminados&lt;/em&gt; (p. 48)</target>
        </trans-unit>
        <trans-unit id="edbbe1dd270001c9959fe3b6bfc520ed27fa81f3" translate="yes" xml:space="preserve">
          <source>Provided that python objects &lt;strong&gt;are mutable&lt;/strong&gt; I think that this should be taken into account when designing the default arguments stuff.
When you instantiate a list:</source>
          <target state="translated">Siempre que los objetos de Python &lt;strong&gt;sean mutables&lt;/strong&gt; , creo que esto deber&amp;iacute;a tenerse en cuenta al dise&amp;ntilde;ar los elementos de argumentos predeterminados. Cuando crea una instancia de una lista:</target>
        </trans-unit>
        <trans-unit id="e05c3327cf67fb602c3add427a88b4d544b75506" translate="yes" xml:space="preserve">
          <source>Python novices would expect this function to always return a list with only one element: &lt;code&gt;[5]&lt;/code&gt;. The result is instead very different, and very astonishing (for a novice):</source>
          <target state="translated">Los principiantes de Python esperar&amp;iacute;an que esta funci&amp;oacute;n siempre devuelva una lista con un solo elemento: &lt;code&gt;[5]&lt;/code&gt; . El resultado es, en cambio, muy diferente y muy sorprendente (para un novato):</target>
        </trans-unit>
        <trans-unit id="81f99a7ff268aeaf873fa4045929feaf18be7cd0" translate="yes" xml:space="preserve">
          <source>Python: The Mutable Default Argument</source>
          <target state="translated">Pitón:El argumento por defecto mutable</target>
        </trans-unit>
        <trans-unit id="48fb53aa0f56fcdc44c27cdce6ee6b0ac6e04929" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;parameter&lt;/code&gt; is a constant name, we can &quot;evaluate&quot; it at the same time as &lt;code&gt;def name&lt;/code&gt;. This also has the advantage it produces the function with a known signature as &lt;code&gt;name(parameter=...):&lt;/code&gt;, instead of a bare &lt;code&gt;name(...):&lt;/code&gt;.</source>
          <target state="translated">Como el &lt;code&gt;parameter&lt;/code&gt; es un nombre constante, podemos &quot;evaluarlo&quot; al mismo tiempo que &lt;code&gt;def name&lt;/code&gt; . Esto tambi&amp;eacute;n tiene la ventaja de que produce la funci&amp;oacute;n con una firma conocida como &lt;code&gt;name(parameter=...):&lt;/code&gt; lugar de un &lt;code&gt;name(...):&lt;/code&gt; simple (...):.</target>
        </trans-unit>
        <trans-unit id="a5d182b67a7149475e28eef1bc9597d34d73b45e" translate="yes" xml:space="preserve">
          <source>Since I don't think this pattern is well known, I do put a short comment in to guard against future misunderstandings.</source>
          <target state="translated">Ya que no creo que este patrón sea bien conocido,hago un pequeño comentario para evitar futuros malentendidos.</target>
        </trans-unit>
        <trans-unit id="1da4b14f89f2b2d481987a26be3a56b816db7930" translate="yes" xml:space="preserve">
          <source>Since the function body is executed anew each time, you always get a fresh new empty list if no argument was passed for &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Dado que el cuerpo de la funci&amp;oacute;n se ejecuta de nuevo cada vez, siempre se obtiene una nueva lista vac&amp;iacute;a nueva si no se pas&amp;oacute; ning&amp;uacute;n argumento para &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8219cc9987e068b594e6f9212eabecd380fc4b23" translate="yes" xml:space="preserve">
          <source>Since the list is bound to the function when the function object is compiled and instantiated, this:</source>
          <target state="translated">Dado que la lista está ligada a la función cuando el objeto de la función es compilado e instanciado,esto:</target>
        </trans-unit>
        <trans-unit id="846d5d41860fc57cee6667664460f6fd3c443f37" translate="yes" xml:space="preserve">
          <source>So this is what you see (Remember, &lt;code&gt;pavlo&lt;/code&gt; is initialized to []):</source>
          <target state="translated">Entonces esto es lo que ves (recuerda, &lt;code&gt;pavlo&lt;/code&gt; se inicializa en []):</target>
        </trans-unit>
        <trans-unit id="cc480e96946c5a4d81dbe64f85f0531baec48a48" translate="yes" xml:space="preserve">
          <source>So, &lt;code&gt;pavlo&lt;/code&gt; is still &lt;code&gt;[5, 5]&lt;/code&gt;.</source>
          <target state="translated">Entonces, &lt;code&gt;pavlo&lt;/code&gt; todav&amp;iacute;a est&amp;aacute; &lt;code&gt;[5, 5]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="135253f82ce516e45be9920a7c65b965b29a4cbe" translate="yes" xml:space="preserve">
          <source>So, let's do some introspection, a before and after to examine how the list gets expanded &lt;strong&gt;inside&lt;/strong&gt; the function object. I'm using &lt;code&gt;Python 3.x&lt;/code&gt; for this, for Python 2 the same applies (use &lt;code&gt;__defaults__&lt;/code&gt; or &lt;code&gt;func_defaults&lt;/code&gt; in Python 2; yes, two names for the same thing).</source>
          <target state="translated">Entonces, hagamos una introspecci&amp;oacute;n, un antes y un despu&amp;eacute;s para examinar c&amp;oacute;mo se expande la lista &lt;strong&gt;dentro&lt;/strong&gt; del objeto de funci&amp;oacute;n. Estoy usando &lt;code&gt;Python 3.x&lt;/code&gt; para esto, para Python 2 se aplica lo mismo (use &lt;code&gt;__defaults__&lt;/code&gt; o &lt;code&gt;func_defaults&lt;/code&gt; en Python 2; s&amp;iacute;, dos nombres para la misma cosa).</target>
        </trans-unit>
        <trans-unit id="ac03b13d0df29e0d823d1733d67a60356a13e49c" translate="yes" xml:space="preserve">
          <source>So, there you have it, the reason why this &lt;em&gt;'flaw'&lt;/em&gt; happens, is because default arguments are part of the function object. There's nothing weird going on here, it's all just a bit surprising.</source>
          <target state="translated">Entonces, ah&amp;iacute; lo tiene, la raz&amp;oacute;n por &lt;em&gt;la que&lt;/em&gt; ocurre este &lt;em&gt;'defecto'&lt;/em&gt; es porque los argumentos predeterminados son parte del objeto de funci&amp;oacute;n. Aqu&amp;iacute; no pasa nada extra&amp;ntilde;o, todo es un poco sorprendente.</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="2ffd73eaa6f051202977e48c6c85a797b6fd5a12" translate="yes" xml:space="preserve">
          <source>Someone is using every language/library feature, and</source>
          <target state="translated">Alguien está usando todas las funciones de la biblioteca de idiomas,y</target>
        </trans-unit>
        <trans-unit id="d42bae2973e05a62b137b51620fea4d9b147edc0" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;a&lt;/code&gt; when calling &lt;code&gt;foo()&lt;/code&gt; ensures &lt;code&gt;pavlo&lt;/code&gt; is not touched.</source>
          <target state="translated">Al especificar &lt;code&gt;a&lt;/code&gt; cuando se llama a &lt;code&gt;foo()&lt;/code&gt; garantiza que no se toque &lt;code&gt;pavlo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f19d645e1fda82c64c713d7a7c9e1d69d1720d38" translate="yes" xml:space="preserve">
          <source>Suppose you have the following code</source>
          <target state="translated">Supongamos que tienes el siguiente código</target>
        </trans-unit>
        <trans-unit id="2985042a12a99a3c98ea5fdbdde2134ab3ef8abf" translate="yes" xml:space="preserve">
          <source>Switching the behavior here would be ill-advised, but</source>
          <target state="translated">Cambiar el comportamiento aquí sería desacertado,pero</target>
        </trans-unit>
        <trans-unit id="eb8098887cd8190749f463f9cd047389241aa54c" translate="yes" xml:space="preserve">
          <source>TLDR: Define-time defaults are consistent and strictly more expressive.</source>
          <target state="translated">Los valores por defecto de tiempo definido son consistentes y estrictamente más expresivos.</target>
        </trans-unit>
        <trans-unit id="baee8029959dfcc9ec36a00cfc022b60ddd58256" translate="yes" xml:space="preserve">
          <source>Taking &lt;strong&gt;(1)&lt;/strong&gt; and &lt;strong&gt;(2)&lt;/strong&gt; into account, one can see why this accomplishes the the desired behavior:</source>
          <target state="translated">Teniendo en cuenta &lt;strong&gt;(1)&lt;/strong&gt; y &lt;strong&gt;(2)&lt;/strong&gt; , uno puede ver por qu&amp;eacute; esto logra el comportamiento deseado:</target>
        </trans-unit>
        <trans-unit id="60e49eedb22450ed713b64f742443e241e6f5637" translate="yes" xml:space="preserve">
          <source>That is against the rules of functional programming, usually undesiderable and should be fixed both together.</source>
          <target state="translated">Esto va en contra de las reglas de la programación funcional,por lo general indeseable y debe ser fijado a la vez.</target>
        </trans-unit>
        <trans-unit id="6283984545c4460e3d117123b9917e356ce0cec9" translate="yes" xml:space="preserve">
          <source>That said it should feature prominently in any good Python tutorial. Because as you mention, everyone runs into this problem sooner or later.</source>
          <target state="translated">Dicho esto,debería figurar de manera prominente en cualquier buen tutorial de Python.Porque como mencionas,todo el mundo se encuentra con este problema tarde o temprano.</target>
        </trans-unit>
        <trans-unit id="4742191818ba22d12f4df985ed0fa6ab565b9a93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;def name&lt;/code&gt; part &lt;strong&gt;must&lt;/strong&gt; evaluate in the defining scope - we want &lt;code&gt;name&lt;/code&gt; to be available there, after all. Evaluating the function only inside itself would make it inaccessible.</source>
          <target state="translated">La parte del &lt;code&gt;def name&lt;/code&gt; &lt;strong&gt;debe&lt;/strong&gt; evaluarse en el &amp;aacute;mbito de definici&amp;oacute;n; despu&amp;eacute;s de todo, queremos que el &lt;code&gt;name&lt;/code&gt; est&amp;eacute; disponible all&amp;iacute;. Evaluar la funci&amp;oacute;n solo dentro de s&amp;iacute; misma la har&amp;iacute;a inaccesible.</target>
        </trans-unit>
        <trans-unit id="211b17364c2c5fb881927eef3ad2c632ef6e4ead" translate="yes" xml:space="preserve">
          <source>The actual behavior is more consistent: everything of that line gets evaluated when that line is executed, meaning at function definition.</source>
          <target state="translated">El comportamiento real es más consistente:todo lo de esa línea se evalúa cuando se ejecuta esa línea,es decir,en la definición de la función.</target>
        </trans-unit>
        <trans-unit id="b21b3a47af1bce60cc5bdaa7db45df9e68ea6c1a" translate="yes" xml:space="preserve">
          <source>The behavior of read-only class attributes upon assignment attempts, and that</source>
          <target state="translated">El comportamiento de los atributos de la clase de sólo lectura en los intentos de asignación,y que</target>
        </trans-unit>
        <trans-unit id="d812f28bfd7bbbe507925925cde1cb11345acdb0" translate="yes" xml:space="preserve">
          <source>The common solution to combat this is to use &lt;code&gt;None&lt;/code&gt; as the default and then initialize in the function body:</source>
          <target state="translated">La soluci&amp;oacute;n com&amp;uacute;n para combatir esto es usar &lt;code&gt;None&lt;/code&gt; como valor predeterminado y luego inicializar en el cuerpo de la funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="e6bc97e96787463bf81bb7eba82e092966902caa" translate="yes" xml:space="preserve">
          <source>The convention for achieving the desired result in Python is to
  provide a default value of &lt;code&gt;None&lt;/code&gt; and to document the actual behaviour
  in the docstring.</source>
          <target state="translated">La convenci&amp;oacute;n para lograr el resultado deseado en Python es proporcionar un valor predeterminado de &lt;code&gt;None&lt;/code&gt; y documentar el comportamiento real en la cadena de documentaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="12d835d927cd99c2caf5af5f3e46112259ed6aeb" translate="yes" xml:space="preserve">
          <source>The decorator could be adjusted to allow for that, but we leave this as an exercise for the reader ;)</source>
          <target state="translated">El decorador podría ser ajustado para permitir eso,pero dejamos esto como un ejercicio para el lector ;)</target>
        </trans-unit>
        <trans-unit id="5da3d3f2271874d0124b0b19b38e9cd58ca9fc21" translate="yes" xml:space="preserve">
          <source>The example in the question could fall into category 1 or 3. It's odd that it both modifies the passed list and returns it; you should pick one or the other.</source>
          <target state="translated">El ejemplo de la pregunta podría entrar en la categoría 1 o 3.Es extraño que modifique la lista pasada y la devuelva;debería elegir una u otra.</target>
        </trans-unit>
        <trans-unit id="07a5b90c302821e9edaa02c42d4c5a34d0d660fb" translate="yes" xml:space="preserve">
          <source>The existing behavior is not Pythonic, and Python is successful because very little about the language violates the principle of least astonishment anywhere &lt;em&gt;near&lt;/em&gt; this badly. It is a real problem, whether or not it would be wise to uproot it. It is a design flaw. If you understand the language much better by trying to trace out the behavior, I can say that C++ does all of this and more; you learn a lot by navigating, for instance, subtle pointer errors. But this is not Pythonic: people who care about Python enough to persevere in the face of this behavior are people who are drawn to the language because Python has far fewer surprises than other language. Dabblers and the curious become Pythonistas when they are astonished at how little time it takes to get something working--not because of a design fl--I mean, hidden logic puzzle--that cuts against the intuitions of programmers who are drawn to Python because it &lt;strong&gt;Just Works&lt;/strong&gt;.</source>
          <target state="translated">El comportamiento existente no es Pythonic, y Python es exitoso porque muy poco sobre el lenguaje viola el principio de menos asombro en cualquier parte &lt;em&gt;cerca de&lt;/em&gt; esto. Es un problema real, sea o no conveniente desarraigarlo. Es un defecto de dise&amp;ntilde;o. Si comprende el lenguaje mucho mejor al tratar de rastrear el comportamiento, puedo decir que C ++ hace todo esto y m&amp;aacute;s; aprende mucho navegando, por ejemplo, errores sutiles de puntero. Pero esto no es Pythonic: las personas que se preocupan por Python lo suficiente como para perseverar frente a este comportamiento son personas que se sienten atra&amp;iacute;das por el lenguaje porque Python tiene muchas menos sorpresas que otro lenguaje. Dabblers y los curiosos se convierten en Pythonistas cuando se sorprenden del poco tiempo que lleva hacer que algo funcione, no por un dise&amp;ntilde;o fl - quiero decir, un rompecabezas de l&amp;oacute;gica oculta - que corta en contra de las intuiciones de los programadores que se sienten atra&amp;iacute;dos por Python porque &lt;strong&gt;simplemente funciona&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="16ba720afc950d5f92d65c94fa4b03086d39ddeb" translate="yes" xml:space="preserve">
          <source>The invocation of foo(1) make items point to a list object [] with an address, say, 11111111. the content of the list is changed to &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; in the foo function in the sequel, but the address is not changed, still 11111111. Then foo(2,[]) is coming. Although the [] in foo(2,[]) has the same content as the default parameter [] when calling foo(1), their address are different! Since we provide the parameter explicitly, &lt;code&gt;items&lt;/code&gt; has to take the address of this new &lt;code&gt;[]&lt;/code&gt;, say 2222222, and return it after making some change. Now foo(3) is executed. since only &lt;code&gt;x&lt;/code&gt; is provided, items has to take its default value again. What's the default value? It is set when defining the foo function: the list object located in 11111111. So the items is evaluated to be the address 11111111 having an element 1. The list located at 2222222 also contains one element 2, but it is not pointed by items any more. Consequently, An append of 3 will make &lt;code&gt;items&lt;/code&gt; [1,3].</source>
          <target state="translated">La invocaci&amp;oacute;n de foo (1) hace que los elementos apunten a un objeto de lista [] con una direcci&amp;oacute;n, por ejemplo, 11111111. el contenido de la lista se cambia a &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; en la funci&amp;oacute;n foo en la secuela, pero la direcci&amp;oacute;n no se cambia, todav&amp;iacute;a 11111111 Luego viene foo (2, []). Aunque [] en foo (2, []) tiene el mismo contenido que el par&amp;aacute;metro predeterminado [] cuando llama a foo (1), &amp;iexcl;su direcci&amp;oacute;n es diferente! Como proporcionamos el par&amp;aacute;metro expl&amp;iacute;citamente, los &lt;code&gt;items&lt;/code&gt; deben tomar la direcci&amp;oacute;n de este nuevo &lt;code&gt;[]&lt;/code&gt; , digamos 2222222, y devolverlo despu&amp;eacute;s de realizar alg&amp;uacute;n cambio. Ahora se ejecuta foo (3). Como solo se proporciona &lt;code&gt;x&lt;/code&gt; , los elementos deben volver a tomar su valor predeterminado. &amp;iquest;Cu&amp;aacute;l es el valor predeterminado? Se establece al definir la funci&amp;oacute;n foo: el objeto de lista ubicado en 11111111. Por lo tanto, los elementos se eval&amp;uacute;an como la direcci&amp;oacute;n 11111111 que tiene un elemento 1. La lista ubicada en 2222222 tambi&amp;eacute;n contiene un elemento 2, pero no se se&amp;ntilde;ala con ning&amp;uacute;n elemento. m&amp;aacute;s. En consecuencia, un anexo de 3 har&amp;aacute; &lt;code&gt;items&lt;/code&gt; [1,3].</target>
        </trans-unit>
        <trans-unit id="960186c4fed60739e84ad1f39072643da3a4aa62" translate="yes" xml:space="preserve">
          <source>The only way to implement this otherwise would be to create a further closure with the i bound, ie:</source>
          <target state="translated">La única manera de implementar esto de otra manera sería crear un cierre adicional con el i bound,es decir:</target>
        </trans-unit>
        <trans-unit id="9a6df79e5dc84aaf86c93401973ff0f28eae8f32" translate="yes" xml:space="preserve">
          <source>The other answers, or at least some of them either make points 1 and 2 but not 3, or make point 3 and downplay points 1 and 2. &lt;strong&gt;But all three are true.&lt;/strong&gt;</source>
          <target state="translated">Las otras respuestas, o al menos algunas de ellas, hacen los puntos 1 y 2 pero no 3, o hacen el punto 3 y minimizan los puntos 1 y 2. &lt;strong&gt;Pero las tres son verdaderas.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="927ebe1c435f42420093f2af144d14cd34af2416" translate="yes" xml:space="preserve">
          <source>The problem is that &lt;code&gt;foo&lt;/code&gt; is &lt;em&gt;modifying&lt;/em&gt; a mutable variable passed in from the caller, when the caller doesn't expect this. Code like this would be fine if the function was called something like &lt;code&gt;append_5&lt;/code&gt;; then the caller would be calling the function in order to modify the value they pass in, and the behaviour would be expected. But such a function would be very unlikely to take a default argument, and probably wouldn't return the list (since the caller already has a reference to that list; the one it just passed in).</source>
          <target state="translated">El problema es que &lt;code&gt;foo&lt;/code&gt; est&amp;aacute; &lt;em&gt;modificando&lt;/em&gt; una variable mutable transmitida por la persona que llama, cuando la persona que llama no espera esto. Un c&amp;oacute;digo como este estar&amp;iacute;a bien si la funci&amp;oacute;n se llamara algo as&amp;iacute; como &lt;code&gt;append_5&lt;/code&gt; ; entonces la persona que llama llamar&amp;iacute;a a la funci&amp;oacute;n para modificar el valor que pasa y se esperar&amp;iacute;a el comportamiento. Pero es muy poco probable que una funci&amp;oacute;n de este tipo tome un argumento predeterminado, y probablemente no devolver&amp;aacute; la lista (ya que la persona que llama ya tiene una referencia a esa lista; la que acaba de pasar).</target>
        </trans-unit>
        <trans-unit id="65336feec4cf085e41224e4e768035259840cf58" translate="yes" xml:space="preserve">
          <source>The real problem lies with mutable variables, and all languages have this problem to some extent. Here's a question: suppose in Java I have the following code:</source>
          <target state="translated">El verdadero problema radica en las variables mutables,y todos los idiomas tienen este problema en cierta medida.Aquí hay una pregunta:supongamos que en Java tengo el siguiente código:</target>
        </trans-unit>
        <trans-unit id="0a4fcade0686f8907935d1c1f96cfa776ce37445" translate="yes" xml:space="preserve">
          <source>The relevant part of the &lt;a href=&quot;http://docs.python.org/reference/compound_stmts.html#function-definitions&quot;&gt;documentation&lt;/a&gt;:</source>
          <target state="translated">La parte relevante de la &lt;a href=&quot;http://docs.python.org/reference/compound_stmts.html#function-definitions&quot;&gt;documentaci&amp;oacute;n&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="83a5fdca145464c718498a81f3ff52fe5cd258bb" translate="yes" xml:space="preserve">
          <source>The role of &lt;strong&gt;(2)&lt;/strong&gt; has been covered extensively in this thread. &lt;strong&gt;(1)&lt;/strong&gt; is likely the astonishment causing factor, as this behavior is not &quot;intuitive&quot; when coming from other languages.</source>
          <target state="translated">El papel de &lt;strong&gt;(2)&lt;/strong&gt; se ha cubierto ampliamente en este hilo. &lt;strong&gt;(1)&lt;/strong&gt; es probablemente el factor causante de asombro, ya que este comportamiento no es &quot;intuitivo&quot; cuando proviene de otros idiomas.</target>
        </trans-unit>
        <trans-unit id="300e6346ced2778bb2850c432c17f5b9ac6cc781" translate="yes" xml:space="preserve">
          <source>The second option is nice because users of the function can pass in a callable, which may be already existing (such as a &lt;code&gt;type&lt;/code&gt;)</source>
          <target state="translated">La segunda opci&amp;oacute;n es buena porque los usuarios de la funci&amp;oacute;n pueden pasar un invocable, que ya puede existir (como un &lt;code&gt;type&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a7a38b99177ce67bdf698f00a61b5341959f2954" translate="yes" xml:space="preserve">
          <source>The shortest answer would probably be &quot;definition is execution&quot;, therefore the whole argument makes no strict sense. As a more contrived example, you may cite this:</source>
          <target state="translated">La respuesta más corta sería probablemente &quot;la definición es la ejecución&quot;,por lo que todo el argumento no tiene sentido estricto.Como un ejemplo más artificioso,puede citar esto:</target>
        </trans-unit>
        <trans-unit id="1545469b153fc84d77f2934491dab6d60119c4f8" translate="yes" xml:space="preserve">
          <source>The solutions here are:</source>
          <target state="translated">Las soluciones aquí son:</target>
        </trans-unit>
        <trans-unit id="9f29d3492458b50ad2b58ab7115f1bdab5c6dec2" translate="yes" xml:space="preserve">
          <source>The two choices are not equivalent, either: If &lt;code&gt;default&lt;/code&gt; is evaluated at definition time, it &lt;em&gt;can still&lt;/em&gt; affect execution time. If &lt;code&gt;default&lt;/code&gt; is evaluated at execution time, it &lt;em&gt;cannot&lt;/em&gt; affect definition time. Choosing &quot;at definition&quot; allows expressing both cases, while choosing &quot;at execution&quot; can express only one:</source>
          <target state="translated">Las dos opciones tampoco son equivalentes: si el &lt;code&gt;default&lt;/code&gt; se eval&amp;uacute;a en el momento de la definici&amp;oacute;n, &lt;em&gt;a&amp;uacute;n puede&lt;/em&gt; afectar el tiempo de ejecuci&amp;oacute;n. Si el &lt;code&gt;default&lt;/code&gt; se eval&amp;uacute;a en el tiempo de ejecuci&amp;oacute;n, no &lt;em&gt;puede&lt;/em&gt; afectar el tiempo de definici&amp;oacute;n. Elegir &quot;en la definici&amp;oacute;n&quot; permite expresar ambos casos, mientras que elegir &quot;en la ejecuci&amp;oacute;n&quot; puede expresar solo uno:</target>
        </trans-unit>
        <trans-unit id="9d3b19afacd01fa6760d29ccb31fceacd0420b99" translate="yes" xml:space="preserve">
          <source>The usual instruction to new Python users:</source>
          <target state="translated">La instrucción habitual para los nuevos usuarios de Python:</target>
        </trans-unit>
        <trans-unit id="83431a0cce73cc9ea555626b7407f498ddeab772" translate="yes" xml:space="preserve">
          <source>There are 3 cases I see where you might run into this problem:</source>
          <target state="translated">Hay 3 casos que veo en los que podrías encontrarte con este problema:</target>
        </trans-unit>
        <trans-unit id="7d403bffc3efdc0e15e597031a66e58b86f1e427" translate="yes" xml:space="preserve">
          <source>There may be legitimate use cases for the 'Wrong Method' whereby the programmer intended the default list parameter to be shared, but this is more likely the exception than the rule.</source>
          <target state="translated">Puede haber casos de uso legítimo del &quot;Método Incorrecto&quot; en los que el programador pretendía que se compartiera el parámetro de la lista por defecto,pero es más probable que sea la excepción que la regla.</target>
        </trans-unit>
        <trans-unit id="e122131b734ffdd0c974c11125de9bf4d4ac1de3" translate="yes" xml:space="preserve">
          <source>They stay mutated because they are the same object each time.</source>
          <target state="translated">Permanecen mutados porque son el mismo objeto cada vez.</target>
        </trans-unit>
        <trans-unit id="42f87dc35743615ca50ba7a4e0a765f48628f38e" translate="yes" xml:space="preserve">
          <source>This &quot;bug&quot; gave me a lot of overtime work hours! But I'm beginning to see a potential use of it (but I would have liked it to be at the execution time, still)</source>
          <target state="translated">¡Este &quot;bicho&quot; me dio un montón de horas extras de trabajo! Pero estoy empezando a ver un uso potencial de él (pero me hubiera gustado que fuera en el momento de la ejecución,todavía)</target>
        </trans-unit>
        <trans-unit id="09c551bd076af75de6f7f75f84e6e19528a70b20" translate="yes" xml:space="preserve">
          <source>This actually has nothing to do with default values, other than that it often comes up as an unexpected behaviour when you write functions with mutable default values.</source>
          <target state="translated">En realidad,esto no tiene nada que ver con los valores por defecto,aparte de que a menudo aparece como un comportamiento inesperado cuando se escriben funciones con valores por defecto mutables.</target>
        </trans-unit>
        <trans-unit id="91bf40b75c5eb2ec9fc9e9af2dee27f147910385" translate="yes" xml:space="preserve">
          <source>This behavior is easy explained by:</source>
          <target state="translated">Este comportamiento es fácil de explicar:</target>
        </trans-unit>
        <trans-unit id="8e882fce06b5aa8e4902377bf10643c0438bee5c" translate="yes" xml:space="preserve">
          <source>This behavior is not surprising if you take the following into consideration:</source>
          <target state="translated">Este comportamiento no es sorprendente si se tiene en cuenta lo siguiente:</target>
        </trans-unit>
        <trans-unit id="53ed8453d80a594313b39f617a24cd922589e53c" translate="yes" xml:space="preserve">
          <source>This code suffers from the exact same unexpected happenstance. bananas is a class attribute, and hence, when you add things to it, it's added to all instances of that class. The reason is exactly the same.</source>
          <target state="translated">Este código sufre exactamente la misma circunstancia inesperada.El plátano es un atributo de la clase,y por lo tanto,cuando le añades cosas,se añade a todas las instancias de esa clase.La razón es exactamente la misma.</target>
        </trans-unit>
        <trans-unit id="5aa4790f0f096239796bd26d7ab23aed623fa5b3" translate="yes" xml:space="preserve">
          <source>This implementation ensures that each call to the function either receives the default list or else the list passed to the function.</source>
          <target state="translated">Esta implementación asegura que cada llamada a la función reciba la lista predeterminada o bien la lista pasada a la función.</target>
        </trans-unit>
        <trans-unit id="37aa3fb7ad8287604da5115ea29978831dfe3dda" translate="yes" xml:space="preserve">
          <source>This information is very useful for things like document generation, metaprogramming, decorators etc.</source>
          <target state="translated">Esta información es muy útil para cosas como la generación de documentos,metaprogramación,decoradores,etc.</target>
        </trans-unit>
        <trans-unit id="643cda6d4c6e34a04adb1a217260ad6665380a64" translate="yes" xml:space="preserve">
          <source>This is particularly neat for functions that take multiple arguments. Compare:</source>
          <target state="translated">Esto es particularmente claro para las funciones que requieren múltiples argumentos.Compare:</target>
        </trans-unit>
        <trans-unit id="e564daaa17ad1d2d62e46bbb59e0067c087845a8" translate="yes" xml:space="preserve">
          <source>This order of execution is frequently confusing to new users of Python. If you understand the Python execution model, then it becomes quite expected.</source>
          <target state="translated">Este orden de ejecución es frecuentemente confuso para los nuevos usuarios de Python.Si entiendes el modelo de ejecución de Python,entonces es bastante esperado.</target>
        </trans-unit>
        <trans-unit id="b99a6bdeb57707ff2643e03cc6dbbbaa2acc3f12" translate="yes" xml:space="preserve">
          <source>This returns a list of functions that return 0,1,2,3... respectively.  If the behaviour is changed, they will instead bind &lt;code&gt;i&lt;/code&gt; to the &lt;em&gt;call-time&lt;/em&gt; value of i, so you would get a list of functions that all returned &lt;code&gt;9&lt;/code&gt;.</source>
          <target state="translated">Esto devuelve una lista de funciones que devuelven 0,1,2,3 ... respectivamente. Si se cambia el comportamiento, en su lugar vincular&amp;aacute;n &lt;code&gt;i&lt;/code&gt; al valor de &lt;em&gt;tiempo de llamada&lt;/em&gt; de i, por lo que obtendr&amp;iacute;a una lista de funciones que devolvieron &lt;code&gt;9&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1a3982204610904ddbc4a70de5860ec7e166984" translate="yes" xml:space="preserve">
          <source>This uses the None singleton as a sentinel object to tell the function whether or not we've gotten an argument other than the default. If we get no argument, then we actually want to use a new empty list, &lt;code&gt;[]&lt;/code&gt;, as the default.</source>
          <target state="translated">Esto usa el singleton None como un objeto centinela para decirle a la funci&amp;oacute;n si hemos recibido o no un argumento diferente al predeterminado. Si no obtenemos argumentos, en realidad queremos usar una nueva lista vac&amp;iacute;a, &lt;code&gt;[]&lt;/code&gt; , como valor predeterminado.</target>
        </trans-unit>
        <trans-unit id="4aedb952cd727e6e69581496e8e0b6ab6127d03c" translate="yes" xml:space="preserve">
          <source>To further validate my answer, let's take a look at two additional codes.</source>
          <target state="translated">Para validar aún más mi respuesta,echemos un vistazo a dos códigos adicionales.</target>
        </trans-unit>
        <trans-unit id="3488d10d037c07a6d63c40837ee02a62ef16f935" translate="yes" xml:space="preserve">
          <source>To further verify that the list in &lt;code&gt;__defaults__&lt;/code&gt; is the same as that used in the function &lt;code&gt;func&lt;/code&gt; you can just change your function to return the &lt;code&gt;id&lt;/code&gt; of the list &lt;code&gt;a&lt;/code&gt; used inside the function body. Then, compare it to the list in &lt;code&gt;__defaults__&lt;/code&gt; (position &lt;code&gt;[0]&lt;/code&gt; in &lt;code&gt;__defaults__&lt;/code&gt;) and you'll see how these are indeed refering to the same list instance:</source>
          <target state="translated">Para verificar a&amp;uacute;n m&amp;aacute;s que la lista en &lt;code&gt;__defaults__&lt;/code&gt; es la misma que la utilizada en la funci&amp;oacute;n &lt;code&gt;func&lt;/code&gt; , simplemente puede cambiar su funci&amp;oacute;n para devolver la &lt;code&gt;id&lt;/code&gt; entificaci&amp;oacute;n de la lista utilizada dentro del cuerpo de la funci&amp;oacute;n. Luego, comp&amp;aacute;relo con la lista en &lt;code&gt;__defaults__&lt;/code&gt; (posici&amp;oacute;n &lt;code&gt;[0]&lt;/code&gt; en &lt;code&gt;__defaults__&lt;/code&gt; ) y ver&amp;aacute; c&amp;oacute;mo se refieren a la misma instancia de lista:</target>
        </trans-unit>
        <trans-unit id="6c169f56bd97d585a628344306275a6fbb160c64" translate="yes" xml:space="preserve">
          <source>To make things simpler for this discussion, let's temporarily give the unnamed list a name. How about &lt;code&gt;pavlo&lt;/code&gt; ?</source>
          <target state="translated">Para simplificar las cosas para esta discusi&amp;oacute;n, asignemos temporalmente un nombre a la lista sin nombre. &amp;iquest;Qu&amp;eacute; tal &lt;code&gt;pavlo&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="e3a6729bfe6a04ecd5a00fc68b6c0f6331500e7a" translate="yes" xml:space="preserve">
          <source>To me, it seems that the design decision was relative to where to put the scope of parameters: inside the function or &quot;together&quot; with it?</source>
          <target state="translated">A mí me parece que la decisión de diseño fue relativa a dónde poner el alcance de los parámetros:¿dentro de la función o &quot;junto a ella&quot;?</target>
        </trans-unit>
        <trans-unit id="636d1dcd268f11a46b28fe964396e61a54cf23da" translate="yes" xml:space="preserve">
          <source>Ugly, but it works.</source>
          <target state="translated">Feo,pero funciona.</target>
        </trans-unit>
        <trans-unit id="f1f3a34856e7b498ab581f67c98cdf2d11513052" translate="yes" xml:space="preserve">
          <source>Upon &lt;code&gt;L = []&lt;/code&gt;, the assignment cannot succeed at &lt;code&gt;foo.func_defs[0]&lt;/code&gt;, because that attribute is read-only.</source>
          <target state="translated">Con &lt;code&gt;L = []&lt;/code&gt; , la asignaci&amp;oacute;n no puede tener &amp;eacute;xito en &lt;code&gt;foo.func_defs[0]&lt;/code&gt; , porque ese atributo es de solo lectura.</target>
        </trans-unit>
        <trans-unit id="b4add7a466713c04e3a9ff607faa91aff366d0f8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;None&lt;/code&gt; as your default value (or a nonce &lt;code&gt;object&lt;/code&gt;), and switch on that to create your values at runtime; or</source>
          <target state="translated">Utilice &lt;code&gt;None&lt;/code&gt; como su valor predeterminado (o un &lt;code&gt;object&lt;/code&gt; nonce) y act&amp;iacute;velo para crear sus valores en tiempo de ejecuci&amp;oacute;n; o</target>
        </trans-unit>
        <trans-unit id="ea379d2578b870e14c73410aa538eccdf7d0c72c" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;lambda&lt;/code&gt; as your default parameter, and call it within a try block to get the default value (this is the sort of thing that lambda abstraction is for).</source>
          <target state="translated">Use un &lt;code&gt;lambda&lt;/code&gt; como par&amp;aacute;metro predeterminado y ll&amp;aacute;melo dentro de un bloque try para obtener el valor predeterminado (este es el tipo de cosa para la que sirve la abstracci&amp;oacute;n lambda).</target>
        </trans-unit>
        <trans-unit id="9ce0fb10a3874ece19a632c8bbfe4072e2abf695" translate="yes" xml:space="preserve">
          <source>We can get information about the arguments and defaults using the &lt;code&gt;inspect&lt;/code&gt; module, which</source>
          <target state="translated">Podemos obtener informaci&amp;oacute;n sobre los argumentos y valores predeterminados utilizando el m&amp;oacute;dulo de &lt;code&gt;inspect&lt;/code&gt; , que</target>
        </trans-unit>
        <trans-unit id="f43fd0e1e7b924e195b0d1f43667f4b3ecb78cc3" translate="yes" xml:space="preserve">
          <source>We will &quot;fix&quot; this behavior with a decorator that will copy the default value instead of reusing the same instance for each positional argument left at its default value.</source>
          <target state="translated">Arreglaremos este comportamiento con un decorador que copiará el valor por defecto en lugar de reutilizar la misma instancia para cada argumento posicional dejado en su valor por defecto.</target>
        </trans-unit>
        <trans-unit id="028722da6bbfb13719d096b837a20e83f8b33121" translate="yes" xml:space="preserve">
          <source>Well, the reason is quite simply that bindings are done when code is executed, and the function definition is executed, well... when the functions is defined.</source>
          <target state="translated">Bueno,la razón es simplemente que los enlaces se hacen cuando se ejecuta el código,y la definición de la función se ejecuta,bueno...cuando se definen las funciones.</target>
        </trans-unit>
        <trans-unit id="7ad15b2528d3a839026c0d58cd1ee45b2711f4f7" translate="yes" xml:space="preserve">
          <source>What you're asking is why this:</source>
          <target state="translated">Lo que estás preguntando es por qué esto:</target>
        </trans-unit>
        <trans-unit id="bb251fe5322c9cbb5669eb17fcc4c69cba91f98f" translate="yes" xml:space="preserve">
          <source>When I see the declaration of eat, the least astonishing thing is to think that if the first parameter is not given, that it will be equal to the tuple &lt;code&gt;(&quot;apples&quot;, &quot;bananas&quot;, &quot;loganberries&quot;)&lt;/code&gt;</source>
          <target state="translated">Cuando veo la declaraci&amp;oacute;n de comer, lo menos sorprendente es pensar que si no se da el primer par&amp;aacute;metro, ser&amp;aacute; igual a la tupla &lt;code&gt;(&quot;apples&quot;, &quot;bananas&quot;, &quot;loganberries&quot;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92837d652717841e4dbdd22b5957c04117add88c" translate="yes" xml:space="preserve">
          <source>When Python encounters it, the first thing it will do is compile it in order to create a &lt;code&gt;code&lt;/code&gt; object for this function. While this compilation step is done, &lt;em&gt;Python &lt;strong&gt;evaluates&lt;/strong&gt;* and then &lt;strong&gt;stores&lt;/strong&gt; the default arguments (an empty list &lt;code&gt;[]&lt;/code&gt; here) in the function object itself&lt;/em&gt;. As the top answer mentioned: the list &lt;code&gt;a&lt;/code&gt; can now be considered a &lt;em&gt;member&lt;/em&gt; of the function &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">Cuando Python lo encuentra, lo primero que har&amp;aacute; es compilarlo para crear un objeto de &lt;code&gt;code&lt;/code&gt; para esta funci&amp;oacute;n. Mientras se realiza este paso de compilaci&amp;oacute;n, &lt;em&gt;Python &lt;strong&gt;eval&amp;uacute;a&lt;/strong&gt; * y luego &lt;strong&gt;almacena&lt;/strong&gt; los argumentos predeterminados (una lista vac&amp;iacute;a &lt;code&gt;[]&lt;/code&gt; aqu&amp;iacute;) en el propio objeto de funci&amp;oacute;n&lt;/em&gt; . Como se menciona en la respuesta principal: la lista &lt;code&gt;a&lt;/code&gt; ahora se puede considerar &lt;em&gt;miembro&lt;/em&gt; de la funci&amp;oacute;n &lt;code&gt;func&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd17f911f362a654b5a6c64b275c0e88df650e11" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;foo&lt;/code&gt; function object is instantiated, &lt;code&gt;foo.func_defs[0]&lt;/code&gt; is set to &lt;code&gt;None&lt;/code&gt;, an immutable object.</source>
          <target state="translated">Cuando se &lt;code&gt;foo.func_defs[0]&lt;/code&gt; instancia del objeto de funci&amp;oacute;n &lt;code&gt;foo&lt;/code&gt; , foo.func_defs [0] se establece en &lt;code&gt;None&lt;/code&gt; , un objeto inmutable.</target>
        </trans-unit>
        <trans-unit id="6bb5893e3a075febba63fa1345cc1545dec24f55" translate="yes" xml:space="preserve">
          <source>When the function is executed with defaults (with no parameter specified for &lt;code&gt;L&lt;/code&gt; in the function call), &lt;code&gt;foo.func_defs[0]&lt;/code&gt; (&lt;code&gt;None&lt;/code&gt;) is available in the local scope as &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="translated">Cuando la funci&amp;oacute;n se ejecuta con los valores predeterminados (sin par&amp;aacute;metros especificados para &lt;code&gt;L&lt;/code&gt; en la llamada de funci&amp;oacute;n), &lt;code&gt;foo.func_defs[0]&lt;/code&gt; ( &lt;code&gt;None&lt;/code&gt; ) est&amp;aacute; disponible en el &amp;aacute;mbito local como &lt;code&gt;L&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c90da9c4543da64cdb8845246bc7bf7320e0bc1d" translate="yes" xml:space="preserve">
          <source>When they are mutable, when mutated (for example, by adding an element to it) they remain mutated on consecutive calls.</source>
          <target state="translated">Cuando son mutables,al mutar (por ejemplo,al añadirle un elemento)permanecen mutados en llamadas consecutivas.</target>
        </trans-unit>
        <trans-unit id="2241f2b26702e693ed138e31ffa8bd03750a3109" translate="yes" xml:space="preserve">
          <source>When we do this:</source>
          <target state="translated">Cuando hagamos esto:</target>
        </trans-unit>
        <trans-unit id="6912ff10f6eb1fb687cb173f4f87e2aa8cb150d3" translate="yes" xml:space="preserve">
          <source>Why don't you introspect?</source>
          <target state="translated">¿Por qué no haces una introspección?</target>
        </trans-unit>
        <trans-unit id="287fc26c3268d8d1c2a9357d670b0099b1576d07" translate="yes" xml:space="preserve">
          <source>Why should the &lt;code&gt;a=[]&lt;/code&gt; in</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; deber&amp;iacute;a &lt;code&gt;a=[]&lt;/code&gt; en</target>
        </trans-unit>
        <trans-unit id="52b2c683c383df4eb8aa68d958bd6badb17f2b85" translate="yes" xml:space="preserve">
          <source>Yes, it is unexpected. But once the penny drops, it fits in perfectly with how Python works in general. In fact, it's a good teaching aid, and once you understand why this happens, you'll grok python much better.</source>
          <target state="translated">Sí,es inesperado.Pero una vez que el centavo cae,encaja perfectamente con el funcionamiento de Python en general.De hecho,es una buena ayuda para la enseñanza,y una vez que entiendas por qué sucede esto,tocarás la pitón mucho mejor.</target>
        </trans-unit>
        <trans-unit id="9083597dacf68f7853fb01578d3aa2ab71e8663f" translate="yes" xml:space="preserve">
          <source>You can get round this by replacing the object (and therefore the tie with the scope):</source>
          <target state="translated">Puedes evitarlo reemplazando el objeto (y por lo tanto la corbata con el visor):</target>
        </trans-unit>
        <trans-unit id="b512ff0f2aacb271cc653788c90da69d6dfc77d3" translate="yes" xml:space="preserve">
          <source>You can verify that they are one and the same object by using &lt;code&gt;id&lt;/code&gt;:</source>
          <target state="translated">Puede verificar que son el mismo objeto utilizando &lt;code&gt;id&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b7a57f1c427b2aba87570b0fda4061b9802afcc3" translate="yes" xml:space="preserve">
          <source>You intend to leave the argument unmodified, but you accidentally &lt;em&gt;did&lt;/em&gt; modify it. That's a bug, fix it.</source>
          <target state="translated">Tiene la intenci&amp;oacute;n de dejar el argumento sin modificar, pero accidentalmente &lt;em&gt;lo&lt;/em&gt; modific&amp;oacute;. Eso es un error, arr&amp;eacute;glalo.</target>
        </trans-unit>
        <trans-unit id="c2929c645da85b138bef1656c13169d0ec045e7d" translate="yes" xml:space="preserve">
          <source>You intend to modify the argument as a side effect of the function. In this case it &lt;em&gt;never makes sense&lt;/em&gt; to have a default argument. The only exception is when you're abusing the argument list to have function attributes, e.g. &lt;code&gt;cache={}&lt;/code&gt;, and you wouldn't be expected to call the function with an actual argument at all.</source>
          <target state="translated">Tiene la intenci&amp;oacute;n de modificar el argumento como un efecto secundario de la funci&amp;oacute;n. En este caso, &lt;em&gt;nunca tiene sentido&lt;/em&gt; tener un argumento predeterminado. La &amp;uacute;nica excepci&amp;oacute;n es cuando abusa de la lista de argumentos para tener atributos de funci&amp;oacute;n, por ejemplo, &lt;code&gt;cache={}&lt;/code&gt; , y no se espera que llame a la funci&amp;oacute;n con un argumento real.</target>
        </trans-unit>
        <trans-unit id="17d9e231f7ae8537e606b6c0973a016f0c3b9581" translate="yes" xml:space="preserve">
          <source>You intend to modify the argument for use inside the function, but didn't expect the modification to be viewable outside of the function. In that case you need to make a &lt;em&gt;copy&lt;/em&gt; of the argument, whether it was the default or not! Python is not a call-by-value language so it doesn't make the copy for you, you need to be explicit about it.</source>
          <target state="translated">Tiene la intenci&amp;oacute;n de modificar el argumento para su uso dentro de la funci&amp;oacute;n, pero no esperaba que la modificaci&amp;oacute;n fuera visible fuera de la funci&amp;oacute;n. En ese caso, debe hacer una &lt;em&gt;copia&lt;/em&gt; del argumento, ya sea por defecto o no. Python no es un lenguaje de llamada por valor, por lo que no hace la copia por usted, debe ser expl&amp;iacute;cito al respecto.</target>
        </trans-unit>
        <trans-unit id="a6ced87465fcf1eeb8fdd29b614471918519675e" translate="yes" xml:space="preserve">
          <source>Your example is a good one of a case where Python newcomers will be surprised and bitten.  But I'd argue that if we &quot;fixed&quot; this, then that would only create a different situation where they'd be bitten instead, and that one would be even less intuitive. Moreover, this is always the case when dealing with mutable variables; you always run into cases where someone could intuitively expect one or the opposite behavior depending on what code they're writing.</source>
          <target state="translated">Su ejemplo es un buen caso en el que los recién llegados a Python serán sorprendidos y mordidos.Pero yo diría que si &quot;arreglamos&quot; esto,entonces eso sólo crearía una situación diferente en la que serían mordidos en su lugar,y eso sería aún menos intuitivo.Además,este es siempre el caso cuando se trata de variables mutables;siempre te encuentras con casos en los que alguien podría esperar intuitivamente un comportamiento opuesto dependiendo del código que esté escribiendo.</target>
        </trans-unit>
        <trans-unit id="27311373d31b73eb41d1e0b30e06efc32dc97a21" translate="yes" xml:space="preserve">
          <source>Your original &lt;code&gt;foo&lt;/code&gt;, with a default argument, shouldn't be modifying &lt;code&gt;a&lt;/code&gt; whether it was explicitly passed in or got the default value. Your code should leave mutable arguments alone unless it is clear from the context/name/documentation that the arguments are supposed to be modified. Using mutable values passed in as arguments as local temporaries is an extremely bad idea, whether we're in Python or not and whether there are default arguments involved or not.</source>
          <target state="translated">Su &lt;code&gt;foo&lt;/code&gt; original, con un argumento predeterminado, no deber&amp;iacute;a modificar si se pas&amp;oacute; expl&amp;iacute;citamente o si obtuvo el valor predeterminado. Su c&amp;oacute;digo debe dejar solo argumentos mutables a menos que sea claro por el contexto / nombre / documentaci&amp;oacute;n que se supone que los argumentos deben modificarse. Usar valores mutables pasados ​​como argumentos como temporales locales es una idea extremadamente mala, ya sea que estemos en Python o no y si hay argumentos predeterminados involucrados o no.</target>
        </trans-unit>
        <trans-unit id="a47c48016c7bd5e01546ccb1b762c78b706d5abe" translate="yes" xml:space="preserve">
          <source>[] is an object, so python pass the reference of [] to &lt;code&gt;a&lt;/code&gt;, i.e., &lt;code&gt;a&lt;/code&gt; is only a pointer to [] which lies in memory as an object. There is only one copy of [] with, however, many references to it. For the first foo(), the list [] is changed to &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; by append method. But Note that there is only one copy of the list object and this object now becomes &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt;. When running the second foo(), what effbot webpage says (items is not evaluated any more) is wrong. &lt;code&gt;a&lt;/code&gt; is evaluated to be the list object, although now the content of the object is &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt;. This is the effect of passing by reference! The result of foo(3) can be easily derived in the same way.</source>
          <target state="translated">[] es un objeto, por lo que Python pasa la referencia de [] a &lt;code&gt;a&lt;/code&gt; , es decir, &lt;code&gt;a&lt;/code&gt; es solo un puntero a [] que se encuentra en la memoria como un objeto. Sin embargo, solo hay una copia de [] con muchas referencias. Para el primer foo (), la lista [] se cambia a &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; por el m&amp;eacute;todo append. Pero tenga en cuenta que solo hay una copia del objeto de lista y este objeto ahora se convierte en &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; . Al ejecutar el segundo foo (), lo que dice la p&amp;aacute;gina web de efbot (los elementos ya no se eval&amp;uacute;an) est&amp;aacute; mal. &lt;code&gt;a&lt;/code&gt; se eval&amp;uacute;a como el objeto de la lista, aunque ahora el contenido del objeto es &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; . Este es el efecto de pasar por referencia! El resultado de foo (3) se puede derivar f&amp;aacute;cilmente de la misma manera.</target>
        </trans-unit>
        <trans-unit id="811a1b05ff4f47b946f5851e4e0919d50dfa1cfc" translate="yes" xml:space="preserve">
          <source>and running it with &lt;code&gt;python example.py&lt;/code&gt;:</source>
          <target state="translated">y ejecutarlo con &lt;code&gt;python example.py&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="049874c49f0ace21f9f13dd31c57abc695140bba" translate="yes" xml:space="preserve">
          <source>as you'll notice, &lt;code&gt;input()&lt;/code&gt; is called before the process of building the function and binding it to the name &lt;code&gt;bar&lt;/code&gt; is made.</source>
          <target state="translated">Como notar&amp;aacute;, se llama a &lt;code&gt;input()&lt;/code&gt; antes de que se realice el proceso de compilar la funci&amp;oacute;n y vincularla a la &lt;code&gt;bar&lt;/code&gt; ra de nombre.</target>
        </trans-unit>
        <trans-unit id="3375274202e5815d3135c4440713525187e9f33a" translate="yes" xml:space="preserve">
          <source>everything is passed by reference</source>
          <target state="translated">todo se pasa por referencia</target>
        </trans-unit>
        <trans-unit id="127ad2d11d264ef1bc3b7c9367a87c065c2e20d2" translate="yes" xml:space="preserve">
          <source>except for the case of explicitly calling func(None, None), which we'll ignore.</source>
          <target state="translated">excepto en el caso de llamar explícitamente func(None,None),que ignoraremos.</target>
        </trans-unit>
        <trans-unit id="fc5c678a45bcac56840b3c908642740f5ede6d3d" translate="yes" xml:space="preserve">
          <source>function (class etc.) declaration is executed only once, creating all default value objects</source>
          <target state="translated">La declaración de la función (clase,etc.)se ejecuta una sola vez,creando todos los objetos de valor predeterminado</target>
        </trans-unit>
        <trans-unit id="71759c14baa0f1b45b053d0754f9b76a716165c8" translate="yes" xml:space="preserve">
          <source>instantiate a new list on function definition and not on invocation?
It's just like you're asking &quot;if the user doesn't provide the argument then &lt;em&gt;instantiate&lt;/em&gt; a new list and use it as if it was produced by the caller&quot;.
I think this is ambiguous instead:</source>
          <target state="translated">instanciar una nueva lista en la definici&amp;oacute;n de la funci&amp;oacute;n y no en la invocaci&amp;oacute;n? Es como si estuviera preguntando &quot;si el usuario no proporciona el argumento, &lt;em&gt;cree&lt;/em&gt; una nueva lista y &amp;uacute;sela como si hubiera sido producida por la persona que llama&quot;. Creo que esto es ambiguo en su lugar:</target>
        </trans-unit>
        <trans-unit id="9d29cbd7a4d1e405b35c263d8e5d5507492f015a" translate="yes" xml:space="preserve">
          <source>is almost exactly equivalent to this:</source>
          <target state="translated">es casi exactamente equivalente a esto:</target>
        </trans-unit>
        <trans-unit id="d94296d98f302fe54eca1ccc91cf45236ffa89e2" translate="yes" xml:space="preserve">
          <source>isn't internally equivalent to this:</source>
          <target state="translated">no es internamente equivalente a esto:</target>
        </trans-unit>
        <trans-unit id="3e5690a3202553a2f619db51e48332229bfe602f" translate="yes" xml:space="preserve">
          <source>it is entirely consistent to hold to both of the features above and still make another point:</source>
          <target state="translated">es totalmente coherente para mantener las dos características anteriores y aún así hacer otro punto:</target>
        </trans-unit>
        <trans-unit id="39fcd29280818de6a833974667212de642dcf2a7" translate="yes" xml:space="preserve">
          <source>observing that the id is the same each time the list is referenced,</source>
          <target state="translated">observando que la identificación es la misma cada vez que se hace referencia a la lista,</target>
        </trans-unit>
        <trans-unit id="d8e7da304415824d87e81f7b39df6675059d9a54" translate="yes" xml:space="preserve">
          <source>observing that the list stays changed when the function that uses it is called a second time,</source>
          <target state="translated">observando que la lista permanece cambiada cuando la función que la utiliza es llamada por segunda vez,</target>
        </trans-unit>
        <trans-unit id="b573226ee49e1a1dd733f88915532ed8bd52e8f9" translate="yes" xml:space="preserve">
          <source>observing the order in which the output is printed from the source (which I conveniently numbered for you):</source>
          <target state="translated">observando el orden en que se imprime la salida de la fuente (que he numerado convenientemente para usted):</target>
        </trans-unit>
        <trans-unit id="04c9c0f5ccf58a5d42c14519b24d6f2145c58d5f" translate="yes" xml:space="preserve">
          <source>prints the following</source>
          <target state="translated">imprime lo siguiente</target>
        </trans-unit>
        <trans-unit id="db480f941abc083354113eeeff05d261f2c92991" translate="yes" xml:space="preserve">
          <source>seeing that the list is created before the function has finished compiling to a function object,</source>
          <target state="translated">viendo que la lista se crea antes de que la función haya terminado de compilar a un objeto de la función,</target>
        </trans-unit>
        <trans-unit id="7fae1298345bf082e2261fee60080aa9d63fe920" translate="yes" xml:space="preserve">
          <source>then if default parameters were bound at function execution rather than function declaration then I would be astonished (in a very bad way) to discover that fruits had been changed.  This would be more astonishing IMO than discovering that your &lt;code&gt;foo&lt;/code&gt; function above was mutating the list.</source>
          <target state="translated">entonces, si los par&amp;aacute;metros predeterminados se vincularon en la ejecuci&amp;oacute;n de la funci&amp;oacute;n en lugar de la declaraci&amp;oacute;n de la funci&amp;oacute;n, me sorprender&amp;iacute;a (de una manera muy mala) descubrir que las frutas hab&amp;iacute;an cambiado. Esto ser&amp;iacute;a m&amp;aacute;s sorprendente IMO que descubrir que la funci&amp;oacute;n de &lt;code&gt;foo&lt;/code&gt; anterior estaba mutando la lista.</target>
        </trans-unit>
        <trans-unit id="f16bec6158470b4bee129a9e6c86214a2e496fdf" translate="yes" xml:space="preserve">
          <source>user, do you want &lt;code&gt;a&lt;/code&gt; to default to the datetime corresponding to when you're defining or executing &lt;code&gt;x&lt;/code&gt;?
In this case, as in the previous one, I'll keep the same behaviour as if the default argument &quot;assignment&quot; was the first instruction of the function (&lt;code&gt;datetime.now()&lt;/code&gt; called on function invocation).
On the other hand, if the user wanted the definition-time mapping he could write:</source>
          <target state="translated">usuario, &amp;iquest;quieres que el valor predeterminado sea la fecha y hora correspondiente a cuando est&amp;aacute;s definiendo o ejecutando &lt;code&gt;x&lt;/code&gt; ? En este caso, como en el anterior, mantendr&amp;eacute; el mismo comportamiento como si el argumento predeterminado &quot;asignaci&amp;oacute;n&quot; fuera la primera instrucci&amp;oacute;n de la funci&amp;oacute;n ( &lt;code&gt;datetime.now()&lt;/code&gt; invocada en la invocaci&amp;oacute;n de funci&amp;oacute;n). Por otro lado, si el usuario quisiera el mapeo del tiempo de definici&amp;oacute;n, podr&amp;iacute;a escribir:</target>
        </trans-unit>
        <trans-unit id="8fcd25a39d2037183044a8897e9a5333d727fded" translate="yes" xml:space="preserve">
          <source>with</source>
          <target state="translated">with</target>
        </trans-unit>
        <trans-unit id="06e3de5b5b2d499fee4d0c87a0745254a4a566cb" translate="yes" xml:space="preserve">
          <source>you expect to get a &lt;strong&gt;new&lt;/strong&gt; list referenced by &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">espera obtener una &lt;strong&gt;nueva&lt;/strong&gt; lista referenciada por &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c194c14b318f40b680d2378e5d49d583177218c" translate="yes" xml:space="preserve">
          <source>“Least Astonishment” and the Mutable Default Argument</source>
          <target state="translated">&quot;El menor asombro&quot; y el argumento por defecto mutable</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
