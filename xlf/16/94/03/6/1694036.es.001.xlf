<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/1694036">
    <body>
      <group id="1694036">
        <trans-unit id="e97568ea4e112041c0cb6599eb15f6a2a791148f" translate="yes" xml:space="preserve">
          <source>&amp;sect;6.5.4.1 The &lt;code&gt;gets_s&lt;/code&gt; function</source>
          <target state="translated">&amp;sect;6.5.4.1 La funci&amp;oacute;n &lt;code&gt;gets_s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17518df0b5ea550ff0f27d57a4b252bf26d11988" translate="yes" xml:space="preserve">
          <source>(.text+0x34): warning: the `gets' function is dangerous and should not be used.</source>
          <target state="translated">(.text+0x34):advertencia:la función ``objetos'' es peligrosa y no debe ser utilizada.</target>
        </trans-unit>
        <trans-unit id="c800bf27a5a07d0fefadb5b1a5ecd4f9f2ac70f1" translate="yes" xml:space="preserve">
          <source>(&lt;code&gt;fgets&lt;/code&gt;, if it reads an entire line, will leave the &lt;code&gt;'\n'&lt;/code&gt; in the string; you'll have to deal with that.)</source>
          <target state="translated">( &lt;code&gt;fgets&lt;/code&gt; , si lee una l&amp;iacute;nea completa, dejar&amp;aacute; el &lt;code&gt;'\n'&lt;/code&gt; en la cadena; tendr&amp;aacute; que lidiar con eso).</target>
        </trans-unit>
        <trans-unit id="6bc1be7c21ad64a2f919728d4a8f72e29bd67349" translate="yes" xml:space="preserve">
          <source>3 If there is a runtime-constraint violation, &lt;code&gt;s[0]&lt;/code&gt; is set to the null character, and characters
  are read and discarded from &lt;code&gt;stdin&lt;/code&gt; until a new-line character is read, or end-of-file or a
  read error occurs.</source>
          <target state="translated">3 Si hay una violaci&amp;oacute;n de restricci&amp;oacute;n de tiempo de ejecuci&amp;oacute;n, &lt;code&gt;s[0]&lt;/code&gt; se establece en el car&amp;aacute;cter nulo y los caracteres se leen y se descartan de &lt;code&gt;stdin&lt;/code&gt; hasta que se lee un car&amp;aacute;cter de nueva l&amp;iacute;nea, o al final del archivo o se produce un error de lectura.</target>
        </trans-unit>
        <trans-unit id="2c6b11246694e0a53c8eaef6d402a2f6d483a210" translate="yes" xml:space="preserve">
          <source>4 The &lt;code&gt;gets_s&lt;/code&gt; function reads at most one less than the number of characters specified by &lt;code&gt;n&lt;/code&gt;
  from the stream pointed to by &lt;code&gt;stdin&lt;/code&gt;, into the array pointed to by &lt;code&gt;s&lt;/code&gt;. No additional
  characters are read after a new-line character (which is discarded) or after end-of-file.
  The discarded new-line character does not count towards number of characters read. A
  null character is written immediately after the last character read into the array.</source>
          <target state="translated">4 La funci&amp;oacute;n &lt;code&gt;gets_s&lt;/code&gt; lee como m&amp;aacute;ximo uno menos que el n&amp;uacute;mero de caracteres especificados por &lt;code&gt;n&lt;/code&gt; del flujo al que apunta &lt;code&gt;stdin&lt;/code&gt; , en la matriz a la que apunta &lt;code&gt;s&lt;/code&gt; . No se leen caracteres adicionales despu&amp;eacute;s de un car&amp;aacute;cter de nueva l&amp;iacute;nea (que se descarta) o despu&amp;eacute;s del final del archivo. El car&amp;aacute;cter de nueva l&amp;iacute;nea descartado no cuenta para el n&amp;uacute;mero de caracteres le&amp;iacute;dos. Un car&amp;aacute;cter nulo se escribe inmediatamente despu&amp;eacute;s del &amp;uacute;ltimo car&amp;aacute;cter le&amp;iacute;do en la matriz.</target>
        </trans-unit>
        <trans-unit id="871d5200809b27e3005fc171c5add16863eb429c" translate="yes" xml:space="preserve">
          <source>5 If end-of-file is encountered and no characters have been read into the array, or if a read
  error occurs during the operation, then &lt;code&gt;s[0]&lt;/code&gt; is set to the null character, and the other
  elements of &lt;code&gt;s&lt;/code&gt; take unspecified values.</source>
          <target state="translated">5 Si se encuentra el final del archivo y no se han le&amp;iacute;do caracteres en la matriz, o si se produce un error de lectura durante la operaci&amp;oacute;n, entonces &lt;code&gt;s[0]&lt;/code&gt; se establece en el car&amp;aacute;cter nulo, y los otros elementos de &lt;code&gt;s&lt;/code&gt; toman valores no especificados .</target>
        </trans-unit>
        <trans-unit id="ed163a0ef4f509855327416f1f2b9ccda77aeeb8" translate="yes" xml:space="preserve">
          <source>6 The &lt;code&gt;fgets&lt;/code&gt; function allows properly-written programs to safely process input lines too
  long to store in the result array. In general this requires that callers of &lt;code&gt;fgets&lt;/code&gt; pay
  attention to the presence or absence of a new-line character in the result array. Consider
  using &lt;code&gt;fgets&lt;/code&gt; (along with any needed processing based on new-line characters) instead of
  &lt;code&gt;gets_s&lt;/code&gt;.</source>
          <target state="translated">6 La funci&amp;oacute;n &lt;code&gt;fgets&lt;/code&gt; permite que los programas escritos correctamente procesen con seguridad las l&amp;iacute;neas de entrada durante demasiado tiempo para almacenarlas en la matriz de resultados. En general, esto requiere que las personas que llaman &lt;code&gt;fgets&lt;/code&gt; presten atenci&amp;oacute;n a la presencia o ausencia de un car&amp;aacute;cter de nueva l&amp;iacute;nea en la matriz de resultados. Considere usar &lt;code&gt;fgets&lt;/code&gt; (junto con cualquier procesamiento necesario basado en caracteres de nueva l&amp;iacute;nea) en lugar de &lt;code&gt;gets_s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0d48e496596a430fc0e8ae6d905f708329be4d7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.cplusplus.com/reference/clibrary/cstdio/fgets/&quot;&gt;fgets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.cplusplus.com/reference/clibrary/cstdio/fgets/&quot;&gt;fgets&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c82c7b8bf8ffe3eb68fdc9b9a00c4519c5ff30ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fgets()&lt;/code&gt; allows you to specify how many characters are taken out of the standard input buffer, so they don't overrun the variable.</source>
          <target state="translated">&lt;code&gt;fgets()&lt;/code&gt; permite especificar cu&amp;aacute;ntos caracteres se sacan del b&amp;uacute;fer de entrada est&amp;aacute;ndar, para que no sobrepasen la variable.</target>
        </trans-unit>
        <trans-unit id="8bf95efd9191a7a3774dd9d7416afbf3b8c75a34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getline()&lt;/code&gt; &amp;mdash; POSIX</source>
          <target state="translated">&lt;code&gt;getline()&lt;/code&gt; - POSIX</target>
        </trans-unit>
        <trans-unit id="8159d16eefb5f350c2e02c79e3cecfbaf46ad0cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gets()&lt;/code&gt; is dangerous because it is possible for the user to crash the program by typing too much into the prompt. It can't detect the end of available memory, so if you allocate an amount of memory too small for the purpose, it can cause a seg fault and crash. Sometimes it seems very unlikely that a user will type 1000 letters into a prompt meant for a person's name, but as programmers, we need to make our programs bulletproof. (it may also be a security risk if a user can crash a system program by sending too much data).</source>
          <target state="translated">&lt;code&gt;gets()&lt;/code&gt; es peligroso porque es posible que el usuario bloquee el programa escribiendo demasiado en el indicador. No puede detectar el final de la memoria disponible, por lo que si asigna una cantidad de memoria demasiado peque&amp;ntilde;a para ese prop&amp;oacute;sito, puede causar una falla de seguridad y bloquearse. A veces parece muy poco probable que un usuario escriba 1000 letras en un mensaje destinado al nombre de una persona, pero como programadores, necesitamos que nuestros programas sean a prueba de balas. (Tambi&amp;eacute;n puede ser un riesgo de seguridad si un usuario puede bloquear un programa del sistema al enviar demasiados datos).</target>
        </trans-unit>
        <trans-unit id="6adcc51eed96f7c3fbc2eba2e501ef8ab2436d0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt; shall not be a null pointer. &lt;code&gt;n&lt;/code&gt; shall neither be equal to zero nor be greater than
  RSIZE_MAX. A new-line character, end-of-file, or read error shall occur within reading
  &lt;code&gt;n-1&lt;/code&gt; characters from &lt;code&gt;stdin&lt;/code&gt;.&lt;sup&gt;25)&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; no ser&amp;aacute; un puntero nulo. &lt;code&gt;n&lt;/code&gt; no ser&amp;aacute; igual a cero ni mayor que RSIZE_MAX. Se producir&amp;aacute; &lt;code&gt;n-1&lt;/code&gt; car&amp;aacute;cter de nueva l&amp;iacute;nea, fin de archivo o error de lectura al leer n-1 caracteres de &lt;code&gt;stdin&lt;/code&gt; . &lt;sup&gt;25)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="32999174ab5c86638eab236eddb300aaa124ae76" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;25)&lt;/sup&gt; The &lt;code&gt;gets_s&lt;/code&gt; function, unlike &lt;code&gt;gets&lt;/code&gt;, makes it a runtime-constraint violation for a line of input to
  overflow the buffer to store it. Unlike &lt;code&gt;fgets&lt;/code&gt;, &lt;code&gt;gets_s&lt;/code&gt; maintains a one-to-one relationship between
  input lines and successful calls to &lt;code&gt;gets_s&lt;/code&gt;. Programs that use &lt;code&gt;gets&lt;/code&gt; expect such a relationship.</source>
          <target state="translated">&lt;sup&gt;25)&lt;/sup&gt; La funci&amp;oacute;n &lt;code&gt;gets_s&lt;/code&gt; , a diferencia de &lt;code&gt;gets&lt;/code&gt; , lo convierte en una violaci&amp;oacute;n de restricci&amp;oacute;n de tiempo de ejecuci&amp;oacute;n para que una l&amp;iacute;nea de entrada desborde el b&amp;uacute;fer para almacenarlo. A diferencia de los &lt;code&gt;fgets&lt;/code&gt; , &lt;code&gt;gets_s&lt;/code&gt; mantiene una relaci&amp;oacute;n uno a uno entre las l&amp;iacute;neas de entrada y las llamadas exitosas a &lt;code&gt;gets_s&lt;/code&gt; . Los programas que usan &lt;code&gt;gets&lt;/code&gt; tal relaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d47deb2fa418026ef69328b4feb307c797055743" translate="yes" xml:space="preserve">
          <source>Also, as &lt;a href=&quot;https://stackoverflow.com/users/134633/caf&quot;&gt;caf&lt;/a&gt; points out in a comment and &lt;a href=&quot;https://stackoverflow.com/users/14860/paxdiablo&quot;&gt;paxdiablo&lt;/a&gt; shows in his answer, with &lt;code&gt;fgets()&lt;/code&gt; you might have data left over on a line.  My wrapper code leaves that data to be read next time; you can readily modify it to gobble the rest of the line of data if you prefer:</source>
          <target state="translated">Adem&amp;aacute;s, como se&amp;ntilde;ala &lt;a href=&quot;https://stackoverflow.com/users/134633/caf&quot;&gt;caf&lt;/a&gt; en un comentario y &lt;a href=&quot;https://stackoverflow.com/users/14860/paxdiablo&quot;&gt;paxdiablo&lt;/a&gt; muestra en su respuesta, con &lt;code&gt;fgets()&lt;/code&gt; es posible que le queden datos en una l&amp;iacute;nea. Mi c&amp;oacute;digo contenedor deja esos datos para leer la pr&amp;oacute;xima vez; puede modificarlo f&amp;aacute;cilmente para engullir el resto de la l&amp;iacute;nea de datos si lo prefiere:</target>
        </trans-unit>
        <trans-unit id="3a577c69baeea75db56ec2bf55a2c47ccbe72969" translate="yes" xml:space="preserve">
          <source>Alternatives to &lt;code&gt;gets()&lt;/code&gt;</source>
          <target state="translated">Alternativas a &lt;code&gt;gets()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dacdb797ba8e8e112d387210f5fd7a4b54c331cd" translate="yes" xml:space="preserve">
          <source>As everyone else said, the canonical alternative to &lt;code&gt;gets()&lt;/code&gt; is &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fgets.html&quot;&gt;&lt;code&gt;fgets()&lt;/code&gt;&lt;/a&gt; specifying &lt;code&gt;stdin&lt;/code&gt; as the file stream.</source>
          <target state="translated">Como todos los dem&amp;aacute;s dijeron, la alternativa can&amp;oacute;nica a &lt;code&gt;gets()&lt;/code&gt; es &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fgets.html&quot;&gt; &lt;code&gt;fgets()&lt;/code&gt; &lt;/a&gt; especificando &lt;code&gt;stdin&lt;/code&gt; como flujo de archivos.</target>
        </trans-unit>
        <trans-unit id="276cab09e51e47a855dc9b87ab1220f1023257fe" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;gets&lt;/code&gt; doesn't do any kind of check while getting bytes from &lt;em&gt;stdin&lt;/em&gt; and putting them somewhere. A simple example:</source>
          <target state="translated">Porque &lt;code&gt;gets&lt;/code&gt; no hace ning&amp;uacute;n tipo de verificaci&amp;oacute;n mientras obtiene bytes de &lt;em&gt;stdin&lt;/em&gt; y los coloca en alg&amp;uacute;n lugar. Un simple ejemplo:</target>
        </trans-unit>
        <trans-unit id="f2c96493dd9f7f0a24eaac18c571948408967130" translate="yes" xml:space="preserve">
          <source>But this also has its problems such as:</source>
          <target state="translated">Pero esto también tiene sus problemas como:</target>
        </trans-unit>
        <trans-unit id="375f5f535aa6378b6f0ddc609d99ec61fd2fc369" translate="yes" xml:space="preserve">
          <source>C11 K.3.5.4.1 The &lt;code&gt;gets_s&lt;/code&gt; function</source>
          <target state="translated">C11 K.3.5.4.1 La funci&amp;oacute;n &lt;code&gt;gets_s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="e0e37d77940442881c3ecdeeb4e63ff793130daf" translate="yes" xml:space="preserve">
          <source>Feel free to use it as you wish, I hereby release it under the &quot;do what you damn well want to&quot; licence :-)</source>
          <target state="translated">Siéntase libre de usarla como desee,por la presente la libero bajo la licencia &quot;haz lo que quieras&quot; :-)</target>
        </trans-unit>
        <trans-unit id="24320b942db7d03958da6d14023db94004c68712" translate="yes" xml:space="preserve">
          <source>Given that your code will crash anyway, sooner or later, it is better to head the trouble off sooner rather than later.  I'd be prepared to add an error message:</source>
          <target state="translated">Dado que su código se bloqueará de todos modos,tarde o temprano,es mejor prevenir el problema más pronto que tarde.Estaría preparado para añadir un mensaje de error:</target>
        </trans-unit>
        <trans-unit id="b2a1c70a047d18fa7bb41b678bcbfccc91d6d372" translate="yes" xml:space="preserve">
          <source>Hopefully this whets your appetite for the whole talk, which draws attention to how we need more formal correctness proofs in languages and how language designers should be blamed for the mistakes in their languages, not the programmer. This seems to have been the whole dubious reason for designers of bad languages to push the blame to programmers in the guise of 'programmer freedom'.</source>
          <target state="translated">Esperemos que esto despierte su apetito por toda la charla,lo que llama la atención sobre cómo necesitamos más pruebas de corrección formal en los idiomas y cómo los diseñadores de idiomas deben ser culpados por los errores en sus idiomas,no el programador.Esta parece haber sido la razón más dudosa para que los diseñadores de lenguajes malos culpen a los programadores bajo el disfraz de &quot;libertad de programación&quot;.</target>
        </trans-unit>
        <trans-unit id="271cb448109ee99e001bef107a8f3bc50b2b6f84" translate="yes" xml:space="preserve">
          <source>How can I remove this warning and why is there such a warning about using &lt;code&gt;gets()&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo puedo eliminar esta advertencia y por qu&amp;eacute; hay tal advertencia sobre el uso de &lt;code&gt;gets()&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="e4ba164e3701105ccec7d9eab6ba69fc62d2fc45" translate="yes" xml:space="preserve">
          <source>However, in the &lt;em&gt;Recommended practice&lt;/em&gt; section, &lt;code&gt;fgets()&lt;/code&gt; is still preferred.</source>
          <target state="translated">Sin embargo, en la secci&amp;oacute;n &lt;em&gt;Pr&amp;aacute;ctica recomendada&lt;/em&gt; , todav&amp;iacute;a se prefiere &lt;code&gt;fgets()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5f1326537bd1a67f425e3007ee099675175abbb" translate="yes" xml:space="preserve">
          <source>I read recently, in a &lt;a href=&quot;http://groups.google.com/group/comp.lang.c/msg/7e92710bc5ff2ba8&quot;&gt;USENET post to &lt;code&gt;comp.lang.c&lt;/code&gt;&lt;/a&gt;, that &lt;code&gt;gets()&lt;/code&gt; is getting removed from the Standard. &lt;strong&gt;WOOHOO&lt;/strong&gt;</source>
          <target state="translated">Le&amp;iacute; recientemente, en una &lt;a href=&quot;http://groups.google.com/group/comp.lang.c/msg/7e92710bc5ff2ba8&quot;&gt;publicaci&amp;oacute;n de USENET en &lt;code&gt;comp.lang.c&lt;/code&gt; &lt;/a&gt; , que &lt;code&gt;gets()&lt;/code&gt; se est&amp;aacute; eliminando del Est&amp;aacute;ndar. &lt;strong&gt;WOOHOO&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eceb5f707de5da0dab443da03e3e6e5e41328764" translate="yes" xml:space="preserve">
          <source>I remember this has something to do with stack protection and security, but I'm not sure exactly why.</source>
          <target state="translated">Recuerdo que esto tiene que ver con la protección y la seguridad de la pila,pero no estoy seguro de por qué.</target>
        </trans-unit>
        <trans-unit id="9a0c616272856956300d35a22b16fc991d07f8ca" translate="yes" xml:space="preserve">
          <source>I would like to extend an earnest invitation to any C library maintainers out there who are still including &lt;code&gt;gets&lt;/code&gt; in their libraries &quot;just in case anyone is still depending on it&quot;: Please replace your implementation with the equivalent of</source>
          <target state="translated">Me gustar&amp;iacute;a extender una invitaci&amp;oacute;n sincera a todos los encargados del mantenimiento de bibliotecas C que todav&amp;iacute;a est&amp;eacute;n incluidos en sus bibliotecas &quot;en caso de que alguien todav&amp;iacute;a dependa de ello&quot;: Reemplace su implementaci&amp;oacute;n con el equivalente de</target>
        </trans-unit>
        <trans-unit id="7bf781506125edfc033141ab72812799f2999203" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gets()&lt;/code&gt; is so dangerous then why can't we remove it?</source>
          <target state="translated">Si &lt;code&gt;gets()&lt;/code&gt; es tan peligroso, &amp;iquest;por qu&amp;eacute; no podemos eliminarlo?</target>
        </trans-unit>
        <trans-unit id="2225f53902789cdbd60c62ef1ae2f7be501676f7" translate="yes" xml:space="preserve">
          <source>In C11(ISO/IEC 9899:201x), &lt;code&gt;gets()&lt;/code&gt; has been removed. (It's deprecated in ISO/IEC 9899:1999/Cor.3:2007(E))</source>
          <target state="translated">En C11 (ISO / IEC 9899: 201x), &lt;code&gt;gets()&lt;/code&gt; ha sido eliminado. (Est&amp;aacute; en desuso en ISO / IEC 9899: 1999 / Cor.3: 2007 (E))</target>
        </trans-unit>
        <trans-unit id="84611e142406e2872460af2270761a3dcd9aedd8" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;fgets()&lt;/code&gt;, C11 introduces a new safe alternative &lt;code&gt;gets_s()&lt;/code&gt;:</source>
          <target state="translated">Adem&amp;aacute;s de &lt;code&gt;fgets()&lt;/code&gt; , C11 presenta una nueva alternativa segura &lt;code&gt;gets_s()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5163be8673258f548a47017b937adce7bc283e33" translate="yes" xml:space="preserve">
          <source>In fact, ISO have actually taken the step of &lt;em&gt;removing&lt;/em&gt;&lt;code&gt;gets&lt;/code&gt; from the C standard (as of C11, though it was deprecated in C99) which, given how highly they rate backward compatibility, should be an indication of how bad that function was.</source>
          <target state="translated">De hecho, ISO realmente ha dado el paso de &lt;em&gt;eliminar los&lt;/em&gt; &lt;code&gt;gets&lt;/code&gt; del est&amp;aacute;ndar C (a partir de C11, aunque fue obsoleto en C99) que, dada la alta calificaci&amp;oacute;n que tienen de la compatibilidad con versiones anteriores, deber&amp;iacute;a ser una indicaci&amp;oacute;n de cu&amp;aacute;n mala era esa funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fc19320a49a091fc199629c4ede2786469111688" translate="yes" xml:space="preserve">
          <source>In order to use &lt;code&gt;gets&lt;/code&gt; safely, you have to know exactly how many characters you will be reading, so that you can make your buffer large enough. You will only know that if you know exactly what data you will be reading.</source>
          <target state="translated">Para que el uso &lt;code&gt;gets&lt;/code&gt; seguro, debe saber exactamente cu&amp;aacute;ntos caracteres leer&amp;aacute;, de modo que pueda hacer que su b&amp;uacute;fer sea lo suficientemente grande. Solo lo sabr&amp;aacute; si sabe exactamente qu&amp;eacute; datos leer&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="8fde1f90e44e07a8abd3fce0c7724c0e1eae3b60" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;gets&lt;/code&gt;, you want to use &lt;a href=&quot;http://en.cppreference.com/w/c/io/fgets&quot;&gt;&lt;code&gt;fgets&lt;/code&gt;&lt;/a&gt;, which has the signature</source>
          <target state="translated">En lugar de usar &lt;code&gt;gets&lt;/code&gt; , desea usar &lt;a href=&quot;http://en.cppreference.com/w/c/io/fgets&quot;&gt; &lt;code&gt;fgets&lt;/code&gt; &lt;/a&gt; , que tiene la firma</target>
        </trans-unit>
        <trans-unit id="98bc71dac689b4fcfc909ec3933e5b117578f4fe" translate="yes" xml:space="preserve">
          <source>It provides the same protections as &lt;code&gt;fgets&lt;/code&gt; in that it prevents buffer overflows but it also notifies the caller as to what happened and clears out the excess characters so that they do not affect your next input operation.</source>
          <target state="translated">Proporciona las mismas protecciones que los &lt;code&gt;fgets&lt;/code&gt; , ya que evita el desbordamiento del b&amp;uacute;fer, pero tambi&amp;eacute;n notifica a la persona que llama lo que sucedi&amp;oacute; y borra el exceso de caracteres para que no afecten su pr&amp;oacute;xima operaci&amp;oacute;n de entrada.</target>
        </trans-unit>
        <trans-unit id="e1c25818b614ad4886532bcde8537de5f9306656" translate="yes" xml:space="preserve">
          <source>It remained an official part of the language up to the 1999 ISO C standard, but
it was officially removed by the 2011 standard. Most C implementations still support it, but at least gcc issues a warning for any code that uses it.</source>
          <target state="translated">Permaneció como parte oficial del idioma hasta la norma ISO C de 1999,pero fue oficialmente eliminada por la norma de 2011.La mayoría de las implementaciones de C todavía lo apoyan,pero al menos gcc emite una advertencia para cualquier código que lo utilice.</target>
        </trans-unit>
        <trans-unit id="42a5c3d9526dc8085da2abd8478f2b40b7ae031d" translate="yes" xml:space="preserve">
          <source>Modern versions of the Linux compilation system generates warnings if you link &lt;code&gt;gets()&lt;/code&gt; &amp;mdash; and also for some other functions that also have security problems (&lt;code&gt;mktemp()&lt;/code&gt;, &amp;hellip;).</source>
          <target state="translated">Las versiones modernas del sistema de compilaci&amp;oacute;n de Linux generan advertencias si enlaza &lt;code&gt;gets()&lt;/code&gt; , y tambi&amp;eacute;n para algunas otras funciones que tambi&amp;eacute;n tienen problemas de seguridad ( &lt;code&gt;mktemp()&lt;/code&gt; , ...).</target>
        </trans-unit>
        <trans-unit id="b4f2b34526a68d26a3bc4d9dfd62c538c97d08f6" translate="yes" xml:space="preserve">
          <source>Now, first of all you are allowed to input how many characters you want, &lt;code&gt;gets&lt;/code&gt; won't care about it. Secondly the bytes over the size of the array in which you put them (in this case &lt;code&gt;array1&lt;/code&gt;) will overwrite whatever they find in memory because &lt;code&gt;gets&lt;/code&gt; will write them. In the previous example this means that if you input &lt;code&gt;&quot;abcdefghijklmnopqrts&quot;&lt;/code&gt; maybe, unpredictably, it will overwrite also &lt;code&gt;array2&lt;/code&gt; or whatever.</source>
          <target state="translated">Ahora, en primer lugar, se le permite ingresar la cantidad de caracteres que desea, ya que no le importar&amp;aacute;. En segundo lugar, los bytes por encima del tama&amp;ntilde;o de la matriz en la que los coloca (en este caso &lt;code&gt;array1&lt;/code&gt; ) sobrescribir&amp;aacute;n lo que encuentren en la memoria porque los escribir&amp;aacute;. En el ejemplo anterior, esto significa que si &lt;code&gt;&quot;abcdefghijklmnopqrts&quot;&lt;/code&gt; tal vez, de forma impredecible, sobrescribir&amp;aacute; tambi&amp;eacute;n &lt;code&gt;array2&lt;/code&gt; o lo que sea.</target>
        </trans-unit>
        <trans-unit id="198ebb642096c9df4b79446052ed1fe43d6543be" translate="yes" xml:space="preserve">
          <source>Or, better:</source>
          <target state="translated">O,mejor:</target>
        </trans-unit>
        <trans-unit id="9c7dd7546662103cca27c658f26b4a018c8beaa4" translate="yes" xml:space="preserve">
          <source>POSIX 2008 also provides a safe alternative to &lt;code&gt;gets()&lt;/code&gt; called &lt;a href=&quot;http://www.opengroup.org/onlinepubs/9699919799/functions/getline.html&quot;&gt;&lt;code&gt;getline()&lt;/code&gt;&lt;/a&gt;.  It allocates space for the line dynamically, so you end up needing to free it.  It removes the limitation on line length, therefore. It also returns the length of the data that was read, or &lt;code&gt;-1&lt;/code&gt; (and not &lt;code&gt;EOF&lt;/code&gt;!), which means that null bytes in the input can be handled reliably.  There is also a 'choose your own single-character delimiter' variation called &lt;code&gt;getdelim()&lt;/code&gt;; this can be useful if you are dealing with the output from &lt;code&gt;find -print0&lt;/code&gt; where the ends of the file names are marked with an ASCII NUL &lt;code&gt;'\0'&lt;/code&gt; character, for example.</source>
          <target state="translated">POSIX 2008 tambi&amp;eacute;n proporciona una alternativa segura a &lt;code&gt;gets()&lt;/code&gt; llamada &lt;a href=&quot;http://www.opengroup.org/onlinepubs/9699919799/functions/getline.html&quot;&gt; &lt;code&gt;getline()&lt;/code&gt; &lt;/a&gt; . Asigna espacio para la l&amp;iacute;nea din&amp;aacute;micamente, por lo que terminas necesitando liberarla. Elimina la limitaci&amp;oacute;n en la longitud de la l&amp;iacute;nea, por lo tanto. Tambi&amp;eacute;n devuelve la longitud de los datos que se leyeron, o &lt;code&gt;-1&lt;/code&gt; (&amp;iexcl;y no &lt;code&gt;EOF&lt;/code&gt; !), Lo que significa que los bytes nulos en la entrada se pueden manejar de manera confiable. Tambi&amp;eacute;n hay una variaci&amp;oacute;n de 'elige tu propio delimitador de un solo car&amp;aacute;cter' llamada &lt;code&gt;getdelim()&lt;/code&gt; ; esto puede ser &amp;uacute;til si est&amp;aacute; tratando con la salida de &lt;code&gt;find -print0&lt;/code&gt; donde los extremos de los nombres de archivo est&amp;aacute;n marcados con un car&amp;aacute;cter ASCII NUL &lt;code&gt;'\0'&lt;/code&gt; , por ejemplo.</target>
        </trans-unit>
        <trans-unit id="c0983051c063b5fe2f2d2af2af6a0cd45f15bfda" translate="yes" xml:space="preserve">
          <source>Reading a line that overflows the
  array pointed to by s results in
  undefined behavior. The use of fgets()
  is recommended.</source>
          <target state="translated">La lectura de una línea que desborda la matriz señalada por s resulta en un comportamiento indefinido.Se recomienda el uso de fgets().</target>
        </trans-unit>
        <trans-unit id="c3ab3ad6eec1bd2048a1df66a1a4b7763d342532" translate="yes" xml:space="preserve">
          <source>Recommended practice</source>
          <target state="translated">Práctica recomendada</target>
        </trans-unit>
        <trans-unit id="7bafc3df8bbe7113ca4bf95bc8fbacdf935c49b9" translate="yes" xml:space="preserve">
          <source>Runtime-constraints</source>
          <target state="translated">Runtime-constraints</target>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="9eb32d7bd20a4fdf0d3574611c1fa45b36a0d5f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fgets&lt;/code&gt; function allows properly-written programs to safely process input lines too
  long to store in the result array. In general this requires that callers of &lt;code&gt;fgets&lt;/code&gt; pay
  attention to the presence or absence of a new-line character in the result array. Consider
  using &lt;code&gt;fgets&lt;/code&gt; (along with any needed processing based on new-line characters) instead of
  &lt;code&gt;gets_s&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;fgets&lt;/code&gt; permite que los programas escritos correctamente procesen con seguridad las l&amp;iacute;neas de entrada durante demasiado tiempo para almacenarlas en la matriz de resultados. En general, esto requiere que las personas que llaman &lt;code&gt;fgets&lt;/code&gt; presten atenci&amp;oacute;n a la presencia o ausencia de un car&amp;aacute;cter de nueva l&amp;iacute;nea en la matriz de resultados. Considere usar &lt;code&gt;fgets&lt;/code&gt; (junto con cualquier procesamiento necesario basado en caracteres de nueva l&amp;iacute;nea) en lugar de &lt;code&gt;gets_s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9893bc4b020b6f22d145585b4fbf57f8568424a9" translate="yes" xml:space="preserve">
          <source>The C gets function is dangerous and has been a very costly mistake. Tony Hoare singles it out for specific mention in his talk &quot;Null References: The Billion Dollar Mistake&quot;:</source>
          <target state="translated">La función de la C es peligrosa y ha sido un error muy costoso.Tony Hoare lo menciona específicamente en su charla &quot;Referencias Nulas&quot;:El error del billón de dólares&quot;:</target>
        </trans-unit>
        <trans-unit id="7244dce292e5a67e56330c3ae3ac70115d04c857" translate="yes" xml:space="preserve">
          <source>The C11 standard ISO/IEC 9899:2011 eliminated &lt;code&gt;gets()&lt;/code&gt; as a standard function, which is A Good Thing&amp;trade; (it was formally marked as 'obsolescent' and 'deprecated' in ISO/IEC 9899:1999/Cor.3:2007 &amp;mdash; Technical Corrigendum 3 for C99, and then removed in C11).  Sadly, it will remain in libraries for many years (meaning 'decades') for reasons of backwards compatibility. If it were up to me, the implementation of &lt;code&gt;gets()&lt;/code&gt; would become:</source>
          <target state="translated">El est&amp;aacute;ndar C11 ISO / IEC 9899: 2011 eliminado &lt;code&gt;gets()&lt;/code&gt; como una funci&amp;oacute;n est&amp;aacute;ndar, que es A Good Thing &amp;trade; (se marc&amp;oacute; formalmente como 'obsoleto' y 'obsoleto' en ISO / IEC 9899: 1999 / Cor.3: 2007 - Corrigendum t&amp;eacute;cnico 3 para C99, y luego eliminado en C11). Lamentablemente, permanecer&amp;aacute; en las bibliotecas durante muchos a&amp;ntilde;os (lo que significa 'd&amp;eacute;cadas') por razones de compatibilidad con versiones anteriores. Si fuera por m&amp;iacute;, la implementaci&amp;oacute;n de &lt;code&gt;gets()&lt;/code&gt; se convertir&amp;iacute;a en:</target>
        </trans-unit>
        <trans-unit id="84ef67f2688a48e7b376c4ba61e40d505a890822" translate="yes" xml:space="preserve">
          <source>The C11 standard, ISO/IEC 9899-2011, includes TR24731 in Annex K as an optional part of the library. Unfortunately, it is seldom implemented on Unix-like systems.</source>
          <target state="translated">La norma C11,ISOIEC 9899-2011,incluye el TR24731 en el Anexo K como parte opcional de la biblioteca.Desafortunadamente,rara vez se implementa en sistemas de tipo Unix.</target>
        </trans-unit>
        <trans-unit id="9d47e50860bf8076ed169f41d7a85c4359380205" translate="yes" xml:space="preserve">
          <source>The Microsoft Visual Studio compilers implement an approximation to the TR 24731-1 standard, but there are differences between the signatures implemented by Microsoft and those in the TR.</source>
          <target state="translated">Los compiladores de Microsoft Visual Studio implementan una aproximación al estándar TR 24731-1,pero hay diferencias entre las firmas implementadas por Microsoft y las del TR.</target>
        </trans-unit>
        <trans-unit id="98a01dba31dbdea116f56ac87ed8248da7b6c77c" translate="yes" xml:space="preserve">
          <source>The correct thing to do is to use the &lt;code&gt;fgets&lt;/code&gt; function with the &lt;code&gt;stdin&lt;/code&gt; file handle since you can limit the characters read from the user.</source>
          <target state="translated">Lo correcto es utilizar la funci&amp;oacute;n &lt;code&gt;fgets&lt;/code&gt; con el identificador de archivo &lt;code&gt;stdin&lt;/code&gt; , ya que puede limitar los caracteres le&amp;iacute;dos por el usuario.</target>
        </trans-unit>
        <trans-unit id="f1dcc2d6f194f7526b03d578ac0939cdcf19025f" translate="yes" xml:space="preserve">
          <source>The first internet worm (the &lt;a href=&quot;https://en.wikipedia.org/wiki/Morris_worm&quot;&gt;Morris Internet Worm&lt;/a&gt;) escaped about 30 years ago (1988-11-02), and it used &lt;code&gt;gets()&lt;/code&gt; and a buffer overflow as one of its methods of propagating from system to system. The basic problem is that the function doesn't know how big the buffer is, so it continues reading until it finds a newline or encounters EOF, and may overflow the bounds of the buffer it was given.</source>
          <target state="translated">El primer gusano de Internet ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Morris_worm&quot;&gt;Morris Internet Worm&lt;/a&gt; ) escap&amp;oacute; hace unos 30 a&amp;ntilde;os (1988-11-02), y utiliz&amp;oacute; &lt;code&gt;gets()&lt;/code&gt; y un desbordamiento de b&amp;uacute;fer como uno de sus m&amp;eacute;todos de propagaci&amp;oacute;n de un sistema a otro. El problema b&amp;aacute;sico es que la funci&amp;oacute;n no sabe qu&amp;eacute; tan grande es el b&amp;uacute;fer, por lo que contin&amp;uacute;a leyendo hasta que encuentra una nueva l&amp;iacute;nea o encuentra EOF, y puede desbordar los l&amp;iacute;mites del b&amp;uacute;fer que se le dio.</target>
        </trans-unit>
        <trans-unit id="7eff3cb60315bcf695059c295657cc7a122f7959" translate="yes" xml:space="preserve">
          <source>The function is unsafe because it assumes consistent input. &lt;strong&gt;NEVER USE IT!&lt;/strong&gt;</source>
          <target state="translated">La funci&amp;oacute;n no es segura porque supone una entrada consistente. &lt;strong&gt;&amp;iexcl;NUNCA LO USE!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="750bcf656f3974181d5e1a76edf73ad2e124ad0b" translate="yes" xml:space="preserve">
          <source>The residual problem is how to report the three different result states &amp;mdash; EOF or error, line read and not truncated, and partial line read but data was truncated.</source>
          <target state="translated">El problema residual es c&amp;oacute;mo informar los tres estados de resultados diferentes: EOF o error, lectura de l&amp;iacute;nea y no truncada, y lectura de l&amp;iacute;nea parcial pero los datos se truncaron.</target>
        </trans-unit>
        <trans-unit id="6fc9f99af3e43c7167d5846fb446313e960c6292" translate="yes" xml:space="preserve">
          <source>The whole hour is worth watching but for his comments view from 30 minutes on with the specific gets criticism around 39 minutes.</source>
          <target state="translated">Vale la pena ver la hora entera pero para sus comentarios la vista de 30 minutos en adelante con el específico consigue la crítica alrededor de 39 minutos.</target>
        </trans-unit>
        <trans-unit id="9fd85043992102449a1a070298d3a4921c88db31" translate="yes" xml:space="preserve">
          <source>There is also the &lt;a href=&quot;https://stackoverflow.com/questions/372980/do-you-use-the-tr-24731-safe-functions-in-your-c-code&quot;&gt;TR 24731-1&lt;/a&gt; (Technical Report from the C Standard Committee) which provides safer alternatives to a variety of functions, including &lt;code&gt;gets()&lt;/code&gt;:</source>
          <target state="translated">Tambi&amp;eacute;n existe el &lt;a href=&quot;https://stackoverflow.com/questions/372980/do-you-use-the-tr-24731-safe-functions-in-your-c-code&quot;&gt;TR 24731-1&lt;/a&gt; (Informe T&amp;eacute;cnico del Comit&amp;eacute; Est&amp;aacute;ndar de C) que proporciona alternativas m&amp;aacute;s seguras a una variedad de funciones, incluyendo &lt;code&gt;gets()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a4868f32615e852c069d3803b180101b92668998" translate="yes" xml:space="preserve">
          <source>This is the reason that &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/gets.html&quot;&gt;one reference&lt;/a&gt; gives:</source>
          <target state="translated">Esta es la raz&amp;oacute;n que da &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/gets.html&quot;&gt;una referencia&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7db094300ea01e073164a5ea03e10bb13a54db69" translate="yes" xml:space="preserve">
          <source>This problem doesn't arise with &lt;code&gt;gets()&lt;/code&gt; because it doesn't know where your buffer ends and merrily tramples beyond the end, wreaking havoc on your beautifully tended memory layout, often messing up the return stack (a &lt;a href=&quot;https://stackoverflow.com/&quot;&gt;Stack Overflow&lt;/a&gt;) if the buffer is allocated on the stack, or trampling over the control information if the buffer is dynamically allocated, or copying data over other precious global (or module) variables if the buffer is statically allocated.  None of these is a good idea &amp;mdash; they epitomize the phrase 'undefined behaviour`.</source>
          <target state="translated">Este problema no surge con &lt;code&gt;gets()&lt;/code&gt; porque no sabe d&amp;oacute;nde termina el b&amp;uacute;fer y se aleja alegremente m&amp;aacute;s all&amp;aacute; del final, causando estragos en su dise&amp;ntilde;o de memoria bellamente cuidado, a menudo estropeando la pila de retorno (un &lt;a href=&quot;https://stackoverflow.com/&quot;&gt;desbordamiento de pila&lt;/a&gt; ) si el b&amp;uacute;fer se asigna en la pila, o pisotea la informaci&amp;oacute;n de control si el b&amp;uacute;fer se asigna din&amp;aacute;micamente, o copia datos sobre otras valiosas variables globales (o m&amp;oacute;dulos) si el b&amp;uacute;fer se asigna est&amp;aacute;ticamente. Ninguno de estos es una buena idea: personifican la frase 'comportamiento indefinido'.</target>
        </trans-unit>
        <trans-unit id="adf290c1c7f6be3057acb6bea5e471efc8f43c4c" translate="yes" xml:space="preserve">
          <source>This will help make sure nobody is still depending on it.  Thank you.</source>
          <target state="translated">Esto ayudará a asegurar que nadie siga dependiendo de él.Gracias.</target>
        </trans-unit>
        <trans-unit id="4753e2e49fc858e5a2b2e5fbdd4113a97feee0cb" translate="yes" xml:space="preserve">
          <source>To read from the stdin:</source>
          <target state="translated">Para leer de la ETS:</target>
        </trans-unit>
        <trans-unit id="4d6321faea3b1611f6eebc8bb7ca88b9b78860d8" translate="yes" xml:space="preserve">
          <source>To that end, almost every C coder at some point in their career will write a more useful wrapper around &lt;code&gt;fgets&lt;/code&gt; as well. Here's mine:</source>
          <target state="translated">Con ese fin, casi todos los codificadores C en alg&amp;uacute;n momento de su carrera tambi&amp;eacute;n escribir&amp;aacute;n una envoltura m&amp;aacute;s &amp;uacute;til en torno a los &lt;code&gt;fgets&lt;/code&gt; . Aqu&amp;iacute; est&amp;aacute; el m&amp;iacute;o:</target>
        </trans-unit>
        <trans-unit id="ecd90ca1824950ce8dafea2df6b494288f14f8c1" translate="yes" xml:space="preserve">
          <source>What no-one else yet mentioned is that &lt;code&gt;gets()&lt;/code&gt; does not include the newline but &lt;code&gt;fgets()&lt;/code&gt; does.  So, you might need to use a wrapper around &lt;code&gt;fgets()&lt;/code&gt; that deletes the newline:</source>
          <target state="translated">Lo que nadie m&amp;aacute;s mencion&amp;oacute; es que &lt;code&gt;gets()&lt;/code&gt; no incluye la nueva l&amp;iacute;nea, pero &lt;code&gt;fgets()&lt;/code&gt; s&amp;iacute;. Por lo tanto, es posible que deba usar un contenedor alrededor de &lt;code&gt;fgets()&lt;/code&gt; que elimine la nueva l&amp;iacute;nea:</target>
        </trans-unit>
        <trans-unit id="08444532e7c4d0762fa2b5391bf997ac96aef445" translate="yes" xml:space="preserve">
          <source>When I try to compile C code that uses the &lt;code&gt;gets()&lt;/code&gt; function with GCC, I get this warning:</source>
          <target state="translated">Cuando intento compilar c&amp;oacute;digo C que usa la funci&amp;oacute;n &lt;code&gt;gets()&lt;/code&gt; con GCC, aparece esta advertencia:</target>
        </trans-unit>
        <trans-unit id="3b6b52ac0a4e8ac7a4e4655813bedaec02b2f479" translate="yes" xml:space="preserve">
          <source>Why is &lt;code&gt;gets()&lt;/code&gt; dangerous</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; es peligroso &lt;code&gt;gets()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49394cee4f62a9a31d7d725e85adf763e37ad711" translate="yes" xml:space="preserve">
          <source>Why is the gets function so dangerous that it should not be used</source>
          <target state="translated">¿Por qué es la función de get tan peligrosa que no debe ser usada</target>
        </trans-unit>
        <trans-unit id="dd864ec14dc44123c407eae349765bb2dc5e0f85" translate="yes" xml:space="preserve">
          <source>You can't remove API functions without breaking the API. If you would, many applications would no longer compile or run at all.</source>
          <target state="translated">No se pueden eliminar las funciones de la API sin romper la API.Si lo hicieras,muchas aplicaciones ya no se compilarían ni se ejecutarían en absoluto.</target>
        </trans-unit>
        <trans-unit id="9e49543b808f0e06f0c85a5661cdf85f9286f402" translate="yes" xml:space="preserve">
          <source>You should forget you ever heard that &lt;code&gt;gets()&lt;/code&gt; existed.</source>
          <target state="translated">Deber&amp;iacute;as olvidar que alguna vez escuchaste que &lt;code&gt;gets()&lt;/code&gt; exist&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="f6ff7c3689e3c944d79918636d39dc0ec7c04f02" translate="yes" xml:space="preserve">
          <source>You should not use &lt;code&gt;gets&lt;/code&gt; since it has no way to stop a buffer overflow. If the user types in more data than can fit in your buffer, you will most likely end up with corruption or worse.</source>
          <target state="translated">No debe usar &lt;code&gt;gets&lt;/code&gt; ya que no tiene forma de detener un desbordamiento de b&amp;uacute;fer. Si el usuario ingresa m&amp;aacute;s datos de los que caben en su b&amp;uacute;fer, lo m&amp;aacute;s probable es que termine con corrupci&amp;oacute;n o algo peor.</target>
        </trans-unit>
        <trans-unit id="166a2a738c30b8a8caff252f1c9b03400dafc933" translate="yes" xml:space="preserve">
          <source>You'll be happy to know that the
  committee just voted (unanimously, as
  it turns out) to remove gets() from
  the draft as well.</source>
          <target state="translated">Te alegrará saber que el comité acaba de votar (por unanimidad,según parece)para eliminar a gets()del borrador también.</target>
        </trans-unit>
        <trans-unit id="04897e3a7e24331cc83197a34a7f070c6b5ba1a8" translate="yes" xml:space="preserve">
          <source>extra characters entered by the user will be picked up the next time around.</source>
          <target state="translated">los caracteres extra introducidos por el usuario serán recogidos la próxima vez.</target>
        </trans-unit>
        <trans-unit id="4aafe66faf6e18737060606cf1f4058a26b65c75" translate="yes" xml:space="preserve">
          <source>fgets()</source>
          <target state="translated">fgets()</target>
        </trans-unit>
        <trans-unit id="d0b0a098660d5321e56ce33e74f19c73bce34754" translate="yes" xml:space="preserve">
          <source>there's no quick notification that the user entered too much data.</source>
          <target state="translated">no hay una notificación rápida de que el usuario introdujo demasiados datos.</target>
        </trans-unit>
        <trans-unit id="2fec03664be6d0484ac4cd6fbcac08352b5cb407" translate="yes" xml:space="preserve">
          <source>with some test code:</source>
          <target state="translated">con algún código de prueba:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
