<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/509211">
    <body>
      <group id="509211">
        <trans-unit id="0aaf66473b71c5d42becc13d72b6f4ed70fedde3" translate="yes" xml:space="preserve">
          <source>(Python 3 gets a &lt;code&gt;list.copy&lt;/code&gt; and &lt;code&gt;list.clear&lt;/code&gt; method.)</source>
          <target state="translated">(Python 3 obtiene un m&amp;eacute;todo &lt;code&gt;list.copy&lt;/code&gt; y &lt;code&gt;list.clear&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="95d6f5f0e5758c7fa9092f862da9a2259661dfd4" translate="yes" xml:space="preserve">
          <source>1. Slice Notation</source>
          <target state="translated">1.Notación de la rebanada</target>
        </trans-unit>
        <trans-unit id="0f38c5a54db99d84e876f9b5eaa8720b9f3a9a26" translate="yes" xml:space="preserve">
          <source>2. Pitfalls</source>
          <target state="translated">2.trampas</target>
        </trans-unit>
        <trans-unit id="8862228b2902925878e3e9b09c1707ac7de719af" translate="yes" xml:space="preserve">
          <source>3. Examples</source>
          <target state="translated">3.Ejemplos</target>
        </trans-unit>
        <trans-unit id="a3d3ca439ad803f892271df58e7d3c810355f6fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;end&lt;/code&gt;: last index, &lt;strong&gt;NOTE that &lt;code&gt;end&lt;/code&gt; index will not be included in the resulted slice&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;end&lt;/code&gt; : &amp;uacute;ltimo &amp;iacute;ndice, &lt;strong&gt;TEN&lt;/strong&gt; EN &lt;strong&gt;CUENTA que el &amp;iacute;ndice &lt;code&gt;end&lt;/code&gt; no se incluir&amp;aacute; en el segmento resultante&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6643606539da7a52988dc6cf4ceeadabfd2aeb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt;: an object that can be sliced</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; : un objeto que puede ser cortado</target>
        </trans-unit>
        <trans-unit id="1b4c4192b9f7af406c63bd0fcecb821e5c7cd6f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start&lt;/code&gt;: first index to start iteration</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; : primer &amp;iacute;ndice para iniciar la iteraci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="f694d4d7856a4daa5fcd72c6329bb35f7a4a3b91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;step&lt;/code&gt;: pick element every &lt;code&gt;step&lt;/code&gt; index</source>
          <target state="translated">&lt;code&gt;step&lt;/code&gt; : elija elemento cada &amp;iacute;ndice de &lt;code&gt;step&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="31b0888c10f4ec32c43b2a524281bf1bc1307538" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A negative step means iterate the array backwards: from the end to start, with the end index included, and the start index excluded from the result.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Un paso negativo significa iterar la matriz hacia atr&amp;aacute;s: desde el final hasta el inicio, con el &amp;iacute;ndice final incluido y el &amp;iacute;ndice inicial excluido del resultado.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3dd769027176645af5d46752c43bf60e2cbab996" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Basic Slicing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Rebanado B&amp;aacute;sico&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="03764b700c4114b7c7e0b1fc151ca8ee76b98522" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How Python Figures Out Missing Parameters:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C&amp;oacute;mo Python descubre los par&amp;aacute;metros perdidos:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a8df44af93130aa47cf7708478946a1e899c9b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: when step is negative, the default value for &lt;code&gt;start&lt;/code&gt; is &lt;code&gt;len(s)&lt;/code&gt; (while &lt;code&gt;end&lt;/code&gt; does not equal to &lt;code&gt;0&lt;/code&gt;, because &lt;code&gt;s[::-1]&lt;/code&gt; contains &lt;code&gt;s[0]&lt;/code&gt;). For example:</source>
          <target state="translated">&lt;strong&gt;NOTA&lt;/strong&gt; : cuando el paso es negativo, el valor predeterminado para el &lt;code&gt;start&lt;/code&gt; es &lt;code&gt;len(s)&lt;/code&gt; (mientras que el &lt;code&gt;end&lt;/code&gt; no es igual a &lt;code&gt;0&lt;/code&gt; , porque &lt;code&gt;s[::-1]&lt;/code&gt; contiene &lt;code&gt;s[0]&lt;/code&gt; ). Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="a040621624a5c253662c247800c0317b88fdc6d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This post was originally written in my blog, &lt;em&gt;&lt;a href=&quot;https://avilpage.com/2015/03/a-slice-of-python-intelligence-behind.html&quot;&gt;The Intelligence Behind Python Slices&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Esta publicaci&amp;oacute;n se escribi&amp;oacute; originalmente en mi blog, &lt;em&gt;&lt;a href=&quot;https://avilpage.com/2015/03/a-slice-of-python-intelligence-behind.html&quot;&gt;The Intelligence Behind Python Slices&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="dd2468b43f8b0b0ef298ce86ccd65ed0c9f49ef9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Slicing With Step:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Cortando con paso:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7fe67ddb4f6798a243fbf3c1c781e47c402b956c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Slicing can also be applied to multi-dimensional arrays.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;La divisi&amp;oacute;n tambi&amp;eacute;n se puede aplicar a matrices multidimensionales.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54689a39c2f4af595b96d8fcee877e522e69fc2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TODO&lt;/strong&gt;: The code below had a bug with &quot;never go outside the sequence&quot; when abs(step)&amp;gt;1; I &lt;em&gt;think&lt;/em&gt; I patched it to be correct, but it's hard to understand.</source>
          <target state="translated">&lt;strong&gt;TODO&lt;/strong&gt; : El siguiente c&amp;oacute;digo ten&amp;iacute;a un error con &quot;nunca salir de la secuencia&quot; cuando abs (paso)&amp;gt; 1; Creo &lt;em&gt;que&lt;/em&gt; lo parche&amp;eacute; para que sea correcto, pero es dif&amp;iacute;cil de entender.</target>
        </trans-unit>
        <trans-unit id="120f2d378e6907d447c90878b70cfec95cfa80ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Understanding the difference between indexing and slicing:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Comprender la diferencia entre indexaci&amp;oacute;n y segmentaci&amp;oacute;n:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2c3618c39203bd4928667eb7837893a51d2c72ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;start:&lt;/strong&gt; the beginning index of the slice, it will include the element at this index unless it is the same as &lt;em&gt;stop&lt;/em&gt;, defaults to 0, i.e. the first index. If it's negative, it means to start &lt;code&gt;n&lt;/code&gt; items from the end.</source>
          <target state="translated">&lt;strong&gt;inicio:&lt;/strong&gt; el &amp;iacute;ndice de inicio del segmento, incluir&amp;aacute; el elemento en este &amp;iacute;ndice a menos que sea lo mismo que &lt;em&gt;detener&lt;/em&gt; , el valor predeterminado es 0, es decir, el primer &amp;iacute;ndice. Si es negativo, significa comenzar &lt;code&gt;n&lt;/code&gt; elementos desde el final.</target>
        </trans-unit>
        <trans-unit id="3b0828277ef33d65b168b24d8f7acb52b6e97797" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;step:&lt;/strong&gt; the amount by which the index increases, defaults to 1. If it's negative, you're slicing over the iterable in reverse.</source>
          <target state="translated">&lt;strong&gt;paso:&lt;/strong&gt; la cantidad por la cual el &amp;iacute;ndice aumenta, por defecto es 1. Si es negativo, est&amp;aacute;s cortando el iterable en reversa.</target>
        </trans-unit>
        <trans-unit id="f4d542aea390972989442b2f47543ac47e2b208f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;stop:&lt;/strong&gt; the ending index of the slice, it does &lt;em&gt;not&lt;/em&gt; include the element at this index, defaults to length of the sequence being sliced, that is, up to and including the end.</source>
          <target state="translated">&lt;strong&gt;stop:&lt;/strong&gt; el &amp;iacute;ndice final de la divisi&amp;oacute;n, &lt;em&gt;no&lt;/em&gt; incluye el elemento en este &amp;iacute;ndice, por defecto la longitud de la secuencia que se divide, es decir, hasta el final.</target>
        </trans-unit>
        <trans-unit id="227dd9dbc0108dfd4661edff64d2fe881992bffb" translate="yes" xml:space="preserve">
          <source>After using it a bit I realise that the simplest description is that it is exactly the same as the arguments in a &lt;code&gt;for&lt;/code&gt; loop...</source>
          <target state="translated">Despu&amp;eacute;s de usarlo un poco, me doy cuenta de que la descripci&amp;oacute;n m&amp;aacute;s simple es que es exactamente lo mismo que los argumentos en un bucle &lt;code&gt;for&lt;/code&gt; ...</target>
        </trans-unit>
        <trans-unit id="ee7829458bdd9d9fb9e4d5d3a2fb33291ce2cf6c" translate="yes" xml:space="preserve">
          <source>Also, note that negative values for &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are relative to the end of the list and computed in the example above by &lt;code&gt;given_index + a.shape[0]&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s, tenga en cuenta que los valores negativos para &lt;code&gt;start&lt;/code&gt; y &lt;code&gt;end&lt;/code&gt; son relativos al final de la lista y se calculan en el ejemplo anterior por &lt;code&gt;given_index + a.shape[0]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70a021868ab3df3f88ae6899b164851777cd1b14" translate="yes" xml:space="preserve">
          <source>And a couple of things that weren't immediately obvious to me when I first saw the slicing syntax:</source>
          <target state="translated">Y un par de cosas que no fueron inmediatamente obvias para mí cuando vi por primera vez la sintaxis de corte:</target>
        </trans-unit>
        <trans-unit id="d105f3bd854548cc6f0bd3800349d324c615cb05" translate="yes" xml:space="preserve">
          <source>And clearing them is with:</source>
          <target state="translated">Y la limpieza de ellos es con:</target>
        </trans-unit>
        <trans-unit id="d25005772475e3ef4f540f81cb570f204b58a0d9" translate="yes" xml:space="preserve">
          <source>And if you wanted, for some reason, every second item in the reversed sequence:</source>
          <target state="translated">Y si quisieras,por alguna razón,cada segundo artículo en la secuencia inversa:</target>
        </trans-unit>
        <trans-unit id="77bb433c739e5798f1c99c633d2b911edd356fc6" translate="yes" xml:space="preserve">
          <source>And recall that there are defaults for &lt;em&gt;start&lt;/em&gt;, &lt;em&gt;stop&lt;/em&gt;, and &lt;em&gt;step&lt;/em&gt;, so to access the defaults, simply leave out the argument.</source>
          <target state="translated">Y recuerde que hay valores predeterminados para &lt;em&gt;inicio&lt;/em&gt; , &lt;em&gt;detenci&amp;oacute;n&lt;/em&gt; y &lt;em&gt;paso&lt;/em&gt; , as&amp;iacute; que para acceder a los valores predeterminados, simplemente omita el argumento.</target>
        </trans-unit>
        <trans-unit id="8d114526a29d613405e6408309b436a186ca0d52" translate="yes" xml:space="preserve">
          <source>And then once you've seen that, slice assignment to the empty slice makes sense too:</source>
          <target state="translated">Y una vez que has visto eso,la asignación de la rebanada a la rebanada vacía también tiene sentido:</target>
        </trans-unit>
        <trans-unit id="5de2b62e17f6a84350d6fbe4ce6b42edec436e54" translate="yes" xml:space="preserve">
          <source>Another heuristic is, &quot;for any slice, replace the start by zero, apply the previous heuristic to get the end of the list, then count the first number back up to chop items off the beginning&quot;</source>
          <target state="translated">Otra heurística es,&quot;para cualquier rebanada,reemplace el comienzo por cero,aplique la heurística anterior para obtener el final de la lista,luego cuente el primer número de nuevo para cortar los elementos del comienzo&quot;</target>
        </trans-unit>
        <trans-unit id="faa6734c0c057ce07a0df52181d494e9f022c4d5" translate="yes" xml:space="preserve">
          <source>Another import thing: &lt;strong&gt;all &lt;code&gt;start&lt;/code&gt;,&lt;code&gt;end&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt; can be omitted!&lt;/strong&gt; And if they are omitted, their default value will be used: &lt;code&gt;0&lt;/code&gt;,&lt;code&gt;len(s)&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt; accordingly.</source>
          <target state="translated">Otra cosa importante: &amp;iexcl; &lt;strong&gt;todo el &lt;code&gt;start&lt;/code&gt; , el &lt;code&gt;end&lt;/code&gt; y el &lt;code&gt;step&lt;/code&gt; pueden omitirse!&lt;/strong&gt; Y si se omiten, se usar&amp;aacute; su valor predeterminado: &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;len(s)&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; en consecuencia.</target>
        </trans-unit>
        <trans-unit id="7af9ada0982e5ec6222baca6341c1c5cff1f46c9" translate="yes" xml:space="preserve">
          <source>Any of them are optional:</source>
          <target state="translated">Cualquiera de ellos son opcionales:</target>
        </trans-unit>
        <trans-unit id="9e68e1c90bdbb11b1d0236fe65983d5f0f2685f0" translate="yes" xml:space="preserve">
          <source>As a general rule, writing code with a lot of hardcoded index values leads to a readability
and maintenance mess. For example, if you come back to the code a year later, you&amp;rsquo;ll
look at it and wonder what you were thinking when you wrote it. The solution shown
is simply a way of more clearly stating what your code is actually doing.
In general, the built-in slice() creates a slice object that can be used anywhere a slice
is allowed. For example:</source>
          <target state="translated">Como regla general, escribir c&amp;oacute;digo con muchos valores de &amp;iacute;ndice codificados conduce a un l&amp;iacute;o de legibilidad y mantenimiento. Por ejemplo, si vuelve al c&amp;oacute;digo un a&amp;ntilde;o despu&amp;eacute;s, lo mirar&amp;aacute; y se preguntar&amp;aacute; qu&amp;eacute; estaba pensando cuando lo escribi&amp;oacute;. La soluci&amp;oacute;n que se muestra es simplemente una forma de establecer m&amp;aacute;s claramente lo que su c&amp;oacute;digo est&amp;aacute; haciendo realmente. En general, el sector integrado () crea un objeto de sector que se puede utilizar en cualquier lugar donde se permita un sector. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="a5d1179754e1ec07fb3a1e15a9fe95c4e93756e2" translate="yes" xml:space="preserve">
          <source>As you can see, defining only stop returns one element. Since the start defaults to none, this translates into retrieving only one element.</source>
          <target state="translated">Como puedes ver,definir sólo la parada devuelve un elemento.Como el inicio no tiene ninguno,esto se traduce en la recuperación de un solo elemento.</target>
        </trans-unit>
        <trans-unit id="10ddbc6f0ff07831197cae7c89a5e4feb5e47439" translate="yes" xml:space="preserve">
          <source>Backing up a little bit, what happens when you keep going with our procession of counting up the slice beginning?</source>
          <target state="translated">Retrocediendo un poco,¿qué pasa cuando sigues con nuestra procesión de contar el comienzo de la rebanada?</target>
        </trans-unit>
        <trans-unit id="a0a44e8c2753c157919dea94666ab53b99900c6e" translate="yes" xml:space="preserve">
          <source>Be surprised: &lt;strong&gt;slice does not raise an IndexError when the index is out of range!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Sorpr&amp;eacute;ndase&lt;/strong&gt; : &amp;iexcl;el &lt;strong&gt;segmento no genera un IndexError cuando el &amp;iacute;ndice est&amp;aacute; fuera de rango!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="51688e4ac0a45d12d7f9bb788db79cb941448aea" translate="yes" xml:space="preserve">
          <source>Begin from &lt;code&gt;start&lt;/code&gt;, increment by &lt;code&gt;step&lt;/code&gt;, do not reach &lt;code&gt;stop&lt;/code&gt;.  Very simple.</source>
          <target state="translated">Comience desde el &lt;code&gt;start&lt;/code&gt; , incremente &lt;code&gt;step&lt;/code&gt; , no llegue a &lt;code&gt;stop&lt;/code&gt; . Muy simple.</target>
        </trans-unit>
        <trans-unit id="4b2092c15e09d1d0a69d863b94fdb3e35c63e659" translate="yes" xml:space="preserve">
          <source>Below is the example usage:</source>
          <target state="translated">A continuación se muestra el ejemplo de uso:</target>
        </trans-unit>
        <trans-unit id="2b5c42838b863b4b8a4537944505370085a2f395" translate="yes" xml:space="preserve">
          <source>Below is the text of my original answer. It has been useful to many people, so I didn't want to delete it.</source>
          <target state="translated">Abajo está el texto de mi respuesta original.Ha sido útil para mucha gente,así que no quise borrarlo.</target>
        </trans-unit>
        <trans-unit id="c47e4145f6e8d534763f4eeb46a2b86362f0690b" translate="yes" xml:space="preserve">
          <source>Besides basic slicing, it is also possible to apply the following notation:</source>
          <target state="translated">Además del rebanado básico,también es posible aplicar la siguiente anotación:</target>
        </trans-unit>
        <trans-unit id="0b189ce87053a4a6f9151c04b8051585e6e4e7ff" translate="yes" xml:space="preserve">
          <source>Blank values are defaulted as follows: &lt;code&gt;[+0:-0:1]&lt;/code&gt;.</source>
          <target state="translated">Los valores en blanco est&amp;aacute;n predeterminados de la siguiente manera: &lt;code&gt;[+0:-0:1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ab9f5780bbd8ad36625e87ca02af9b8bf9361df" translate="yes" xml:space="preserve">
          <source>But occasionally a doubt creeps in and my brain asks for reassurance that it does not contain the &lt;code&gt;end&lt;/code&gt;-th element.</source>
          <target state="translated">Pero ocasionalmente aparece una duda y mi cerebro me pide que me asegure que no contiene el elemento &lt;code&gt;end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25e3d76337cea9e9d631c334c54bbcb275c06f0f" translate="yes" xml:space="preserve">
          <source>But this range continues in both directions infinitely:</source>
          <target state="translated">Pero este rango continúa en ambas direcciones infinitamente:</target>
        </trans-unit>
        <trans-unit id="313813cd850a6b775a1fb26d3d9c84054d7263b9" translate="yes" xml:space="preserve">
          <source>But you can pass in a negative integer, and the list (or most other standard slicables) will be sliced from the end to the beginning.</source>
          <target state="translated">Pero puedes pasar un entero negativo,y la lista (o la mayoría de los demás rebanables estándar)se rebanará desde el final hasta el principio.</target>
        </trans-unit>
        <trans-unit id="78c9a2985c6c2db62af25652b536f68dff04e931" translate="yes" xml:space="preserve">
          <source>By default, when the &lt;code&gt;step&lt;/code&gt; argument is empty (or &lt;code&gt;None&lt;/code&gt;), it is assigned to &lt;code&gt;+1&lt;/code&gt;.</source>
          <target state="translated">Por defecto, cuando el argumento del &lt;code&gt;step&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o (o &lt;code&gt;None&lt;/code&gt; ), se asigna a &lt;code&gt;+1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74e101616da42c9f860f041e06e88cf3afc9af8d" translate="yes" xml:space="preserve">
          <source>Coming from other programming languages, that's when the common sense gets compromised. What are x and y?</source>
          <target state="translated">Viniendo de otros lenguajes de programación,es cuando el sentido común se ve comprometido.¿Qué son la X y la Y?</target>
        </trans-unit>
        <trans-unit id="114f22f6d7079d292a7e78398094c20f332e1368" translate="yes" xml:space="preserve">
          <source>Confirming this in the source</source>
          <target state="translated">Confirmando esto en la fuente</target>
        </trans-unit>
        <trans-unit id="3eb94acf98e91b224000fb69a7e7764bf5d24a8e" translate="yes" xml:space="preserve">
          <source>Create two lists to slice. The first is a numeric list from 1 to 9 (List A). The second is also a numeric list, from 0 to 9 (List B):</source>
          <target state="translated">Crear dos listas para rebanar.La primera es una lista numérica del 1 al 9 (Lista A).La segunda es también una lista numérica,de 0 a 9 (Lista B):</target>
        </trans-unit>
        <trans-unit id="57856d05bb32d5be32788eb0692ff1468ddf3c07" translate="yes" xml:space="preserve">
          <source>Depending on your application, that might... or might not... be what you were hoping for there!</source>
          <target state="translated">Dependiendo de su solicitud,eso podría...o podría no...¡ser lo que esperaba allí!</target>
        </trans-unit>
        <trans-unit id="20f3af310b2b47de75d12e36f7756694568aec42" translate="yes" xml:space="preserve">
          <source>Don't worry about the &lt;code&gt;is None&lt;/code&gt; details - just remember that omitting &lt;code&gt;start&lt;/code&gt; and/or &lt;code&gt;stop&lt;/code&gt; always does the right thing to give you the whole sequence.</source>
          <target state="translated">No se preocupe por los detalles de &lt;code&gt;is None&lt;/code&gt; , solo recuerde que omitir &lt;code&gt;start&lt;/code&gt; y / o &lt;code&gt;stop&lt;/code&gt; siempre hace lo correcto para darle toda la secuencia.</target>
        </trans-unit>
        <trans-unit id="6d6d1b284c6af28298538c5cdc0a7256d5d5f150" translate="yes" xml:space="preserve">
          <source>Easy way to reverse sequences!</source>
          <target state="translated">¡Una forma fácil de invertir las secuencias!</target>
        </trans-unit>
        <trans-unit id="dec3b85ab5c8afe4bdcf9aa78a36bb7b04f5b4e2" translate="yes" xml:space="preserve">
          <source>Enumerating the possibilities allowed by the grammar:</source>
          <target state="translated">Enumerando las posibilidades permitidas por la gramática:</target>
        </trans-unit>
        <trans-unit id="e2005c2f600247253cdd9b3a166cb5e388bbfb14" translate="yes" xml:space="preserve">
          <source>Explain Python's slice notation</source>
          <target state="translated">Explica la notación de la rebanada de Python</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="ad2d3fd5da36e4d1450b52434f65543e2c249274" translate="yes" xml:space="preserve">
          <source>Extended indexing syntax used for slicing is aList[start:stop:step]. The start argument and the step argument both default to none - the only required argument is stop. Did you notice this is similar to how range was used to define lists A and B? This is because the slice object represents the set of indices specified by range(start, stop, step). Python 3.4 documentation.</source>
          <target state="translated">La sintaxis de indexación extendida utilizada para el rebanado es aList[start:stop:step].Tanto el argumento start como el step están predeterminados a none-el único argumento requerido es stop.¿Te has dado cuenta de que esto es similar a cómo se usaba el rango para definir las listas A y B? Esto se debe a que el objeto slice representa el conjunto de índices especificados por range(start,stop,step).Documentación de Python 3.4.</target>
        </trans-unit>
        <trans-unit id="25a46e8db798e121dc4a998aaa52b7c9c2f4ec77" translate="yes" xml:space="preserve">
          <source>Extended slicing (with commas and ellipses) are mostly used only by special data structures (like NumPy); the basic sequences don't support them.</source>
          <target state="translated">El corte extendido (con comas y elipses)se utiliza principalmente sólo por estructuras de datos especiales (como NumPy);las secuencias básicas no las soportan.</target>
        </trans-unit>
        <trans-unit id="2ce6a2c45d1f432b7017f6d8ad6c6f1f419ab941" translate="yes" xml:space="preserve">
          <source>Few other tricks for reversing the list:</source>
          <target state="translated">Otros pocos trucos para invertir la lista:</target>
        </trans-unit>
        <trans-unit id="53c11609ebb7eeb39c6ae1148df32803811abaf7" translate="yes" xml:space="preserve">
          <source>First, we will create a list of values to use in our slicing.</source>
          <target state="translated">Primero,crearemos una lista de valores para usar en nuestro rebanado.</target>
        </trans-unit>
        <trans-unit id="189f73dcf0d0e026377e4c161485f0bca4a39a7e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;, negative values are interpreted as being relative to the end of the sequence.</source>
          <target state="translated">Para &lt;code&gt;start&lt;/code&gt; y &lt;code&gt;end&lt;/code&gt; , los valores negativos se interpretan como relativos al final de la secuencia.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="ad09b9342bcb6da8bd5c7a868860d3b6440eb901" translate="yes" xml:space="preserve">
          <source>For those who don't know, you can create any substring from &lt;code&gt;azString&lt;/code&gt; using the notation &lt;code&gt;azString[x:y]&lt;/code&gt;</source>
          <target state="translated">Para aquellos que no saben, puede crear cualquier subcadena desde &lt;code&gt;azString&lt;/code&gt; utilizando la notaci&amp;oacute;n &lt;code&gt;azString[x:y]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2d2d5928c54cd3be6435296e94075da9fefa553" translate="yes" xml:space="preserve">
          <source>Found this great table at &lt;a href=&quot;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&quot;&gt;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&lt;/a&gt;</source>
          <target state="translated">Encontr&amp;eacute; esta gran tabla en &lt;a href=&quot;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&quot;&gt;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="666ad671cbeba0a89e7c706687f77df7b879dbc2" translate="yes" xml:space="preserve">
          <source>From the diagram, I expect &lt;code&gt;a[-4,-6,-1]&lt;/code&gt; to be &lt;code&gt;yP&lt;/code&gt; but it is &lt;code&gt;ty&lt;/code&gt;.</source>
          <target state="translated">En el diagrama, espero que &lt;code&gt;a[-4,-6,-1]&lt;/code&gt; sea &lt;code&gt;yP&lt;/code&gt; pero es &lt;code&gt;ty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="181af959e4f8d0fb4083b24c9a79dcab0d808777" translate="yes" xml:space="preserve">
          <source>Give your slices a descriptive name!</source>
          <target state="translated">¡Denle a sus rebanadas un nombre descriptivo!</target>
        </trans-unit>
        <trans-unit id="d8bca9c064390cb40eb6923b46c08e356cc9a63d" translate="yes" xml:space="preserve">
          <source>Given the pattern aList[start:stop], retrieve the first two elements from List A.</source>
          <target state="translated">Dado el patrón aList[start:stop],recupera los dos primeros elementos de la Lista A.</target>
        </trans-unit>
        <trans-unit id="f94faa9a2d2714420791cc753d22514493d014e9" translate="yes" xml:space="preserve">
          <source>Here is an example visualization of that ...</source>
          <target state="translated">Aquí hay un ejemplo de visualización de eso...</target>
        </trans-unit>
        <trans-unit id="77b2dd3c3ff1e4885a243132aecac207f224e3f5" translate="yes" xml:space="preserve">
          <source>How Indexing Works</source>
          <target state="translated">Cómo funciona la indexación</target>
        </trans-unit>
        <trans-unit id="6f1f32310474f8326626103969ab54a0b5070606" translate="yes" xml:space="preserve">
          <source>How Slicing Works</source>
          <target state="translated">Cómo funciona el corte</target>
        </trans-unit>
        <trans-unit id="3da40c095b10f44487cd4ccca0f47467d44aa681" translate="yes" xml:space="preserve">
          <source>However, using a negative value for &lt;code&gt;step&lt;/code&gt; could become very confusing. Moreover, in order to be &lt;a href=&quot;https://en.wiktionary.org/wiki/Pythonic#Adjective&quot;&gt;Pythonic&lt;/a&gt;, you should avoid using &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;step&lt;/code&gt; in a single slice. In case this is required, consider doing this in two assignments (one to slice, and the other to stride).</source>
          <target state="translated">Sin embargo, usar un valor negativo para el &lt;code&gt;step&lt;/code&gt; podr&amp;iacute;a ser muy confuso. Adem&amp;aacute;s, para ser &lt;a href=&quot;https://en.wiktionary.org/wiki/Pythonic#Adjective&quot;&gt;Pythonic&lt;/a&gt; , debe evitar usar &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; y &lt;code&gt;step&lt;/code&gt; en una sola porci&amp;oacute;n. En caso de que sea necesario, considere hacer esto en dos tareas (una para cortar y la otra para avanzar).</target>
        </trans-unit>
        <trans-unit id="4ad93a5dd4fcd6d7c940755502a6bc63d374feb4" translate="yes" xml:space="preserve">
          <source>However, you can't just assign some integers separated by colons to a variable. You need to use the slice object:</source>
          <target state="translated">Sin embargo,no puedes asignar algunos enteros separados por dos puntos a una variable.Tienes que usar el objeto rebanado:</target>
        </trans-unit>
        <trans-unit id="aaa8f93b237e6d327bf33efc09bdaf86ccf36c81" translate="yes" xml:space="preserve">
          <source>I don't think that the &lt;a href=&quot;https://docs.python.org/3/tutorial/introduction.html#strings&quot;&gt;Python tutorial&lt;/a&gt; diagram (cited in various other answers) is good as this suggestion works for positive stride, but does not for a negative stride.</source>
          <target state="translated">No creo que el diagrama del &lt;a href=&quot;https://docs.python.org/3/tutorial/introduction.html#strings&quot;&gt;tutorial de Python&lt;/a&gt; (citado en varias otras respuestas) sea bueno ya que esta sugerencia funciona para un paso positivo, pero no para un paso negativo.</target>
        </trans-unit>
        <trans-unit id="c138ed3c54e5f033afa16fdbd5fccf8d39b80779" translate="yes" xml:space="preserve">
          <source>I find it easier to remember how it works, and then I can figure out any specific start/stop/step combination.</source>
          <target state="translated">Me resulta más fácil recordar cómo funciona,y luego puedo averiguar cualquier combinación específica de pasos de arranque.</target>
        </trans-unit>
        <trans-unit id="ef399e0ded15774144fa63ae11d01aba3089469e" translate="yes" xml:space="preserve">
          <source>I had to sit down and run several scenarios in my quest for a memorization technique that will help me remember what x and y are and help me slice strings properly at the first attempt.</source>
          <target state="translated">Tuve que sentarme y ejecutar varios escenarios en mi búsqueda de una técnica de memorización que me ayudara a recordar qué son la x y la y y me ayudara a cortar las cuerdas correctamente en el primer intento.</target>
        </trans-unit>
        <trans-unit id="c7d0e42afda61407f67326f1c6eb38abab198765" translate="yes" xml:space="preserve">
          <source>I hope this will help you to model the list in Python.</source>
          <target state="translated">Espero que esto te ayude a modelar la lista en Python.</target>
        </trans-unit>
        <trans-unit id="77b54aef5e492c40146cd9a6d0b499de291945d3" translate="yes" xml:space="preserve">
          <source>I like to encourage users to read the source as well as the documentation. The &lt;a href=&quot;https://github.com/python/cpython/blob/master/Objects/sliceobject.c&quot;&gt;source code for slice objects and this logic is found here&lt;/a&gt;. First we determine if &lt;code&gt;step&lt;/code&gt; is negative:</source>
          <target state="translated">Me gusta animar a los usuarios a leer la fuente y la documentaci&amp;oacute;n. El &lt;a href=&quot;https://github.com/python/cpython/blob/master/Objects/sliceobject.c&quot;&gt;c&amp;oacute;digo fuente para los objetos de corte y esta l&amp;oacute;gica se encuentra aqu&amp;iacute;&lt;/a&gt; . Primero determinamos si el &lt;code&gt;step&lt;/code&gt; es negativo:</target>
        </trans-unit>
        <trans-unit id="5d3b3b36c387b5d0fc042b55acf61c2d549b5f7d" translate="yes" xml:space="preserve">
          <source>I need a good explanation (references are a plus) on Python's slice notation.</source>
          <target state="translated">Necesito una buena explicación (las referencias son un plus)sobre la notación de la rebanada de Python.</target>
        </trans-unit>
        <trans-unit id="ad507a3da03671c61941620ae7a2906912f4a37b" translate="yes" xml:space="preserve">
          <source>I personally think about it like a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">Personalmente lo pienso como un bucle &lt;code&gt;for&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="98382aeb1507eab72853d9ce777b3db6e8f02198" translate="yes" xml:space="preserve">
          <source>I use the &quot;an index points between elements&quot; method of thinking about it myself, but one way of describing it which sometimes helps others get it is this:</source>
          <target state="translated">Yo mismo utilizo el método de &quot;un índice de puntos entre elementos&quot; para pensar en ello,pero una forma de describirlo que a veces ayuda a otros a conseguirlo es esta:</target>
        </trans-unit>
        <trans-unit id="7c6fedebad3f718314d64d61745e8419abe48090" translate="yes" xml:space="preserve">
          <source>I want to add one &lt;em&gt;Hello, World!&lt;/em&gt; example that explains the basics of slices for the very beginners. It helped me a lot.</source>
          <target state="translated">Quiero agregar uno &lt;em&gt;&amp;iexcl;Hola Mundo!&lt;/em&gt; ejemplo que explica los conceptos b&amp;aacute;sicos de rebanadas para los principiantes. Me ayud&amp;oacute; mucho.</target>
        </trans-unit>
        <trans-unit id="152b4bcea4dcb6a08bc28ea6e60677690158dfe0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stride&lt;/code&gt; is negative, the ordering is changed a bit since we're counting down:</source>
          <target state="translated">Si la &lt;code&gt;stride&lt;/code&gt; es negativa, el orden cambia un poco ya que estamos haciendo la cuenta regresiva:</target>
        </trans-unit>
        <trans-unit id="cd1befa8b487c0ecabed83a3de28c3d4c4a8dbce" translate="yes" xml:space="preserve">
          <source>If so, the lower bound is &lt;code&gt;-1&lt;/code&gt;  meaning we slice all the way up to and including the beginning, and the upper bound is the length minus 1, meaning we start at the end. (Note that the semantics of this &lt;code&gt;-1&lt;/code&gt; is &lt;em&gt;different&lt;/em&gt; from a &lt;code&gt;-1&lt;/code&gt; that users may pass indexes in Python indicating the last item.)</source>
          <target state="translated">Si es as&amp;iacute;, el l&amp;iacute;mite inferior es &lt;code&gt;-1&lt;/code&gt; , lo que significa que dividimos todo el camino hasta el principio e incluido, y el l&amp;iacute;mite superior es la longitud menos 1, lo que significa que comenzamos al final. (Tenga en cuenta que la sem&amp;aacute;ntica de este &lt;code&gt;-1&lt;/code&gt; es &lt;em&gt;diferente&lt;/em&gt; de un &lt;code&gt;-1&lt;/code&gt; en el que los usuarios pueden pasar &amp;iacute;ndices en Python que indican el &amp;uacute;ltimo elemento).</target>
        </trans-unit>
        <trans-unit id="2f065d470b215e663b57b87dd50c698f07db3377" translate="yes" xml:space="preserve">
          <source>If the index is out of range, Python will try its best to set the index to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;len(s)&lt;/code&gt; according to the situation. For example:</source>
          <target state="translated">Si el &amp;iacute;ndice est&amp;aacute; fuera de rango, Python har&amp;aacute; todo lo posible para establecer el &amp;iacute;ndice en &lt;code&gt;0&lt;/code&gt; o &lt;code&gt;len(s)&lt;/code&gt; seg&amp;uacute;n la situaci&amp;oacute;n. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="8def849642c7353545fcda04de289db5103721fe" translate="yes" xml:space="preserve">
          <source>If the start and end indexes are omitted when performing an assignment operation, the entire content of the collection will be replaced with a copy of what is referenced:</source>
          <target state="translated">Si al realizar una operación de cesión se omiten los índices de inicio y final,se sustituirá todo el contenido de la colección por una copia de lo referido:</target>
        </trans-unit>
        <trans-unit id="661ece95ee93a03aaa302b463dca836f55c6dd14" translate="yes" xml:space="preserve">
          <source>If you check the source code of &lt;a href=&quot;http://en.wikipedia.org/wiki/CPython&quot;&gt;CPython&lt;/a&gt;, you will find a function called PySlice_GetIndicesEx() which figures out indices to a slice for any given parameters. Here is the logical equivalent code in Python.</source>
          <target state="translated">Si verifica el c&amp;oacute;digo fuente de &lt;a href=&quot;http://en.wikipedia.org/wiki/CPython&quot;&gt;CPython&lt;/a&gt; , encontrar&amp;aacute; una funci&amp;oacute;n llamada PySlice_GetIndicesEx () que calcula los &amp;iacute;ndices de un segmento para cualquier par&amp;aacute;metro dado. Aqu&amp;iacute; est&amp;aacute; el c&amp;oacute;digo l&amp;oacute;gico equivalente en Python.</target>
        </trans-unit>
        <trans-unit id="47b5bc36bf784848f762edafdff62074643233f8" translate="yes" xml:space="preserve">
          <source>If you feel negative indices in slicing is confusing, here's a very easy way to think about it: just replace the negative index with &lt;code&gt;len - index&lt;/code&gt;. So for example, replace -3 with &lt;code&gt;len(list) - 3&lt;/code&gt;.</source>
          <target state="translated">Si siente que los &amp;iacute;ndices negativos en el corte es confuso, aqu&amp;iacute; hay una manera muy f&amp;aacute;cil de pensarlo: simplemente reemplace el &amp;iacute;ndice negativo con &lt;code&gt;len - index&lt;/code&gt; . Entonces, por ejemplo, reemplace -3 con &lt;code&gt;len(list) - 3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa833ad31212b2a3b3d439a0e7c53b383e2b3ca5" translate="yes" xml:space="preserve">
          <source>If you have a slice instance s, you can get more information about it by looking at its
s.start, s.stop, and s.step attributes, respectively. For example:</source>
          <target state="translated">Si tiene una instancia de rebanada s,puede obtener más información sobre ella mirando sus atributos s.start,s.stop y s.step,respectivamente.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="f3d97417ba0181b71f5aaffd104fe653cf71364a" translate="yes" xml:space="preserve">
          <source>If you omit the start and end index, you will make a copy of the collection:</source>
          <target state="translated">Si omite el índice de inicio y final,hará una copia de la colección:</target>
        </trans-unit>
        <trans-unit id="f60db26cf6492e7fc7bbed6f90da520c3f57371b" translate="yes" xml:space="preserve">
          <source>If your choice of a, b, and c allows overlap with the range above as you traverse using rules for a,b,c above you will either get a list with elements (touched during traversal) or you will get an empty list.</source>
          <target state="translated">Si su elección de a,b,y c permite superponerse con el rango anterior a medida que atraviesa utilizando las reglas para a,b,c anteriores,obtendrá una lista con elementos (tocados durante la travesía)o bien obtendrá una lista vacía.</target>
        </trans-unit>
        <trans-unit id="f466c12bda6762ec7169a18df85f167e0081116f" translate="yes" xml:space="preserve">
          <source>Important Definitions</source>
          <target state="translated">Definiciones importantes</target>
        </trans-unit>
        <trans-unit id="f2bb9ecf761b6e88e8102a7536ee8d44abe40249" translate="yes" xml:space="preserve">
          <source>In Python 2.7</source>
          <target state="translated">En Python 2.7</target>
        </trans-unit>
        <trans-unit id="90a6eb777e8cda542826e3c6334816f4f0ee8eb6" translate="yes" xml:space="preserve">
          <source>In Python, the most basic form for slicing is the following:</source>
          <target state="translated">En Python,la forma más básica de rebanar es la siguiente:</target>
        </trans-unit>
        <trans-unit id="0ee248346d0af5cd683e4a36d0a440e60af3c740" translate="yes" xml:space="preserve">
          <source>In fact, compared to indexing, Python slicing is bizarrely error-proof:</source>
          <target state="translated">De hecho,comparado con la indexación,el rebanado de pitón es extrañamente a prueba de errores:</target>
        </trans-unit>
        <trans-unit id="e26167c936dd528fda49f3a0a8e244ad7c09578d" translate="yes" xml:space="preserve">
          <source>In my opinion, you will understand and memorize better the Python string slicing notation if you look at it the following way (read on).</source>
          <target state="translated">En mi opinión,entenderás y memorizarás mejor la notación de corte de la cuerda de Python si la miras de la siguiente manera (sigue leyendo).</target>
        </trans-unit>
        <trans-unit id="f7dabe40d708c905a0cefb23cf2333f28977c80b" translate="yes" xml:space="preserve">
          <source>In short, the colons (&lt;code&gt;:&lt;/code&gt;) in subscript notation (&lt;code&gt;subscriptable[subscriptarg]&lt;/code&gt;) make slice notation - which has the optional arguments, &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt;:</source>
          <target state="translated">En resumen, los dos puntos (:) en la notaci&amp;oacute;n de sub&amp;iacute;ndice ( &lt;code&gt;subscriptable[subscriptarg]&lt;/code&gt; ) hacen la notaci&amp;oacute;n de corte, que tiene los argumentos opcionales, &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; , &lt;code&gt;step&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bb5e2ff5da706301f634ce9ca90e75ed00059cba" translate="yes" xml:space="preserve">
          <source>In these moments I rely on this simple theorem:</source>
          <target state="translated">En estos momentos me baso en este simple teorema:</target>
        </trans-unit>
        <trans-unit id="5870a8ca498a1c74154e2cfd9acc8e21c121fdb0" translate="yes" xml:space="preserve">
          <source>Index the number 3 from A and the number 6 from B.</source>
          <target state="translated">Indice el número 3 de A y el número 6 de B.</target>
        </trans-unit>
        <trans-unit id="3631e9d015a9f2d779f98610e8e9d63664c32ef5" translate="yes" xml:space="preserve">
          <source>Indexing is like dealing with the contents of box. You can check contents of any box. But you can't check the contents of multiple boxes at once. You can even replace the contents of the box. But you can't place two balls in one box or replace two balls at a time.</source>
          <target state="translated">La indexación es como tratar con el contenido de una caja.Puedes comprobar el contenido de cualquier caja.Pero no puedes revisar el contenido de varias cajas a la vez.Incluso puedes reemplazar el contenido de la caja.Pero no puedes colocar dos bolas en una caja o reemplazar dos bolas a la vez.</target>
        </trans-unit>
        <trans-unit id="2e852a9a85a011a4821ea957a6c18af49fdb2384" translate="yes" xml:space="preserve">
          <source>It is a list with six elements in it. To understand slicing better, consider that list as a set of six boxes placed together. Each box has an alphabet in it.</source>
          <target state="translated">Es una lista con seis elementos.Para entender mejor el rebanado,considere esa lista como un conjunto de seis cajas colocadas juntas.Cada caja tiene un alfabeto en ella.</target>
        </trans-unit>
        <trans-unit id="72edc078c44d61355487724654334d433672237e" translate="yes" xml:space="preserve">
          <source>It is also possible to use negative integers for &lt;code&gt;step&lt;/code&gt; as the following example:</source>
          <target state="translated">Tambi&amp;eacute;n es posible usar enteros negativos para el &lt;code&gt;step&lt;/code&gt; como el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="d2e55fc42f854f48df8f7704c2076ef2f0b82f26" translate="yes" xml:space="preserve">
          <source>It is important to note, the first element is index 0, &lt;em&gt;not&lt;/em&gt; index 1. This is why we are using 2 lists for this exercise. List A's elements are numbered according to the ordinal position (the first element is 1, the second element is 2, etc.) while List B's elements are the numbers that would be used to index them ([0] for the first element 0, etc.).</source>
          <target state="translated">Es importante tener en cuenta que el primer elemento es el &amp;iacute;ndice 0, &lt;em&gt;no el&lt;/em&gt; &amp;iacute;ndice 1. Es por eso que estamos utilizando 2 listas para este ejercicio. Los elementos de la Lista A est&amp;aacute;n numerados de acuerdo con la posici&amp;oacute;n ordinal (el primer elemento es 1, el segundo elemento es 2, etc.) mientras que los elementos de la Lista B son los n&amp;uacute;meros que se usar&amp;iacute;an para indexarlos ([0] para el primer elemento 0, etc.)</target>
        </trans-unit>
        <trans-unit id="8437802c00fcb02882fb640fb2f6aa10b7ed41e7" translate="yes" xml:space="preserve">
          <source>It is possible to provide indices that are out of bounds when slicing such as:</source>
          <target state="translated">Es posible proporcionar índices que están fuera de los límites cuando se corta como:</target>
        </trans-unit>
        <trans-unit id="cc08d6b3965c9cd2a7d0a9d353abfe631305e0ce" translate="yes" xml:space="preserve">
          <source>It looks extremely powerful, but I haven't quite got my head around it.</source>
          <target state="translated">Parece extremadamente poderoso,pero no me he dado cuenta.</target>
        </trans-unit>
        <trans-unit id="c3478bf3faba9c41f22e71efd498abcab65d1e72" translate="yes" xml:space="preserve">
          <source>It's instructive to understand &lt;code&gt;range()&lt;/code&gt; first:</source>
          <target state="translated">Es instructivo entender &lt;code&gt;range()&lt;/code&gt; primero:</target>
        </trans-unit>
        <trans-unit id="db93970c161e9b60dc37836b4ad4bcc5e738b56f" translate="yes" xml:space="preserve">
          <source>It's interesting that ranges also take slices:</source>
          <target state="translated">Es interesante que los rangos también toman rebanadas:</target>
        </trans-unit>
        <trans-unit id="393247b02d3798ab868c03bcc3f85e6ad9331f9b" translate="yes" xml:space="preserve">
          <source>It's pretty simple really:</source>
          <target state="translated">Es bastante simple en realidad:</target>
        </trans-unit>
        <trans-unit id="07e297809eb4051826121e82a0caefbf899d3c86" translate="yes" xml:space="preserve">
          <source>Keep in mind that the result of slicing a collection is a whole new collection. In addition, when using slice notation in assignments, the length of the slice assignments do not need to be the same. The values before and after the assigned slice will be kept, and the collection will shrink or grow to contain the new values:</source>
          <target state="translated">Tengan en cuenta que el resultado de cortar una colección es una colección completamente nueva.Además,cuando se utiliza la notación de corte en las asignaciones,la longitud de las asignaciones de corte no tiene por qué ser la misma.Los valores anteriores y posteriores a la rebanada asignada se mantendrán,y la colección se reducirá o crecerá para contener los nuevos valores:</target>
        </trans-unit>
        <trans-unit id="cf594f555786da65b5bbbcfa5d1f5e37ff7665e6" translate="yes" xml:space="preserve">
          <source>Let's finish this answer with examples, explaining everything we have discussed:</source>
          <target state="translated">Terminemos esta respuesta con ejemplos,explicando todo lo que hemos discutido:</target>
        </trans-unit>
        <trans-unit id="26f47aa550adca492b5233c25393b47b841fe5ad" translate="yes" xml:space="preserve">
          <source>Let's have a list with six values &lt;code&gt;['P', 'Y', 'T', 'H', 'O', 'N']&lt;/code&gt;:</source>
          <target state="translated">Tengamos una lista con seis valores &lt;code&gt;['P', 'Y', 'T', 'H', 'O', 'N']&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7137555528de00a0bcf2c040f1daafce2f58347c" translate="yes" xml:space="preserve">
          <source>Let's work with the following string ...</source>
          <target state="translated">Trabajemos con la siguiente cadena...</target>
        </trans-unit>
        <trans-unit id="3f6a7a17387285ecbb29103e91399ef401031fff" translate="yes" xml:space="preserve">
          <source>Making things more confusing is that &lt;strong&gt;&lt;code&gt;step&lt;/code&gt; can be negative too!&lt;/strong&gt;</source>
          <target state="translated">&amp;iexcl;Hacer las cosas m&amp;aacute;s confusas es que ese &lt;strong&gt; &lt;code&gt;step&lt;/code&gt; puede ser negativo!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f4d6fecb17d10399cfa47983f1042cccd5affc47" translate="yes" xml:space="preserve">
          <source>Memory Considerations:</source>
          <target state="translated">Consideraciones sobre la memoria:</target>
        </trans-unit>
        <trans-unit id="1ff1eb25d65b7e8b0b1c5bcc0650dd539ed6fbbd" translate="yes" xml:space="preserve">
          <source>More slicing examples: &lt;a href=&quot;https://docs.python.org/2.3/whatsnew/section-slices.html&quot;&gt;15 Extended Slices&lt;/a&gt;</source>
          <target state="translated">M&amp;aacute;s ejemplos de corte: &lt;a href=&quot;https://docs.python.org/2.3/whatsnew/section-slices.html&quot;&gt;15 rebanadas extendidas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="236384af55aea443e68110eede08ce564e280d4c" translate="yes" xml:space="preserve">
          <source>Most of the previous answers clears up questions about slice notation.</source>
          <target state="translated">La mayoría de las respuestas anteriores aclaran las preguntas sobre la notación de las rebanadas.</target>
        </trans-unit>
        <trans-unit id="258dc3b32b7b8c786022e52d99f1e20b993d915e" translate="yes" xml:space="preserve">
          <source>My brain seems happy to accept that &lt;code&gt;lst[start:end]&lt;/code&gt; contains the &lt;code&gt;start&lt;/code&gt;-th item. I might even say that it is a 'natural assumption'.</source>
          <target state="translated">Mi cerebro parece feliz de aceptar que &lt;code&gt;lst[start:end]&lt;/code&gt; contiene el &amp;iacute;tem &lt;code&gt;start&lt;/code&gt; -th. Incluso podr&amp;iacute;a decir que es una 'suposici&amp;oacute;n natural'.</target>
        </trans-unit>
        <trans-unit id="0e9abc9291766099a35bbc0daca4bfdba74ab393" translate="yes" xml:space="preserve">
          <source>My conclusion is that x and y should be seen as the boundary indexes that are surrounding the strings that we want to extra. So we should see the expression as &lt;code&gt;azString[index1, index2]&lt;/code&gt; or even more clearer as &lt;code&gt;azString[index_of_first_character, index_after_the_last_character]&lt;/code&gt;.</source>
          <target state="translated">Mi conclusi&amp;oacute;n es que x e y deben verse como los &amp;iacute;ndices de l&amp;iacute;mite que rodean las cadenas que queremos agregar. Entonces deber&amp;iacute;amos ver la expresi&amp;oacute;n como &lt;code&gt;azString[index1, index2]&lt;/code&gt; o incluso m&amp;aacute;s clara como &lt;code&gt;azString[index_of_first_character, index_after_the_last_character]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bc0687f0ccd20cd39dcb014b119503d374c4139" translate="yes" xml:space="preserve">
          <source>NOTE: If &lt;code&gt;start &amp;gt;= end&lt;/code&gt; (considering only when &lt;code&gt;step&amp;gt;0&lt;/code&gt;), Python will return a empty slice &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">NOTA: Si &lt;code&gt;start &amp;gt;= end&lt;/code&gt; (considerando solo cuando &lt;code&gt;step&amp;gt;0&lt;/code&gt; ), Python devolver&amp;aacute; un segmento vac&amp;iacute;o &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3924ca69a9c6ef3c94b8adce539357eedbfe98b1" translate="yes" xml:space="preserve">
          <source>Negative indexes</source>
          <target state="translated">Índices negativos</target>
        </trans-unit>
        <trans-unit id="19a3fcc38635b3630af723c1238943e8e1843247" translate="yes" xml:space="preserve">
          <source>Negative integers are useful when doing offsets relative to the end of a collection:</source>
          <target state="translated">Los números enteros negativos son útiles cuando se hacen compensaciones relativas al final de una colección:</target>
        </trans-unit>
        <trans-unit id="afa9d728aad9ce367861bb103920cb5b75e339e7" translate="yes" xml:space="preserve">
          <source>Negative step</source>
          <target state="translated">Paso negativo</target>
        </trans-unit>
        <trans-unit id="96650fe967ba54c6b724f6429dd3614089107d32" translate="yes" xml:space="preserve">
          <source>Normalizing negative indexes first allows start and/or stop to be counted from the end independently: &lt;code&gt;'abcde'[1:-2] == 'abcde'[1:3] == 'bc'&lt;/code&gt; despite &lt;code&gt;range(1,-2) == []&lt;/code&gt;.
The normalization is sometimes thought of as &quot;modulo the length&quot;, but note it adds the length just once: e.g. &lt;code&gt;'abcde'[-53:42]&lt;/code&gt; is just the whole string.</source>
          <target state="translated">La normalizaci&amp;oacute;n de los &amp;iacute;ndices negativos primero permite que el inicio y / o la detenci&amp;oacute;n se cuenten desde el final de forma independiente: &lt;code&gt;'abcde'[1:-2] == 'abcde'[1:3] == 'bc'&lt;/code&gt; pesar del &lt;code&gt;range(1,-2) == []&lt;/code&gt; . La normalizaci&amp;oacute;n a veces se considera como &quot;m&amp;oacute;dulo de la longitud&quot;, pero tenga en cuenta que agrega la longitud solo una vez: por ejemplo, &lt;code&gt;'abcde'[-53:42]&lt;/code&gt; es solo la cadena completa.</target>
        </trans-unit>
        <trans-unit id="4d43af0ad3abe59f6e4fb376c128181bd7bde7b5" translate="yes" xml:space="preserve">
          <source>Note that this theorem is true for any &lt;code&gt;n&lt;/code&gt; at all. For example, you can check that</source>
          <target state="translated">Tenga en cuenta que este teorema es cierto para cualquier &lt;code&gt;n&lt;/code&gt; en absoluto. Por ejemplo, puedes verificar que</target>
        </trans-unit>
        <trans-unit id="2ceb96fc5e9a3dc2bc105bff4a65c7e6742be2cc" translate="yes" xml:space="preserve">
          <source>Note that, since we are not changing the second number of the slice (4), the inserted items always stack right up against the 'o', even when we're assigning to the empty slice. So the position for the empty slice assignment is the logical extension of the positions for the non-empty slice assignments.</source>
          <target state="translated">Obsérvese que,como no estamos cambiando el segundo número de la rebanada (4),los elementos insertados siempre se apilan contra la 'o',incluso cuando estamos asignando a la rebanada vacía.Por lo tanto,la posición para la asignación de la rebanada vacía es la extensión lógica de las posiciones para las asignaciones de las rebanadas no vacías.</target>
        </trans-unit>
        <trans-unit id="967bf0aa1a3677571a7849b566735433ec166495" translate="yes" xml:space="preserve">
          <source>Now if you make a slice &lt;code&gt;[2:5]&lt;/code&gt; of the list above, this will happen:</source>
          <target state="translated">Ahora, si hace un corte &lt;code&gt;[2:5]&lt;/code&gt; de la lista anterior, esto suceder&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="e6df6b2bcf9a3314ee026c4f79df59cdd07fa7f8" translate="yes" xml:space="preserve">
          <source>Now the simplest slices of that list are its sublists. The notation is &lt;code&gt;[&amp;lt;index&amp;gt;:&amp;lt;index&amp;gt;]&lt;/code&gt; and the key is to read it like this:</source>
          <target state="translated">Ahora los sectores m&amp;aacute;s simples de esa lista son sus sublistas. La notaci&amp;oacute;n es &lt;code&gt;[&amp;lt;index&amp;gt;:&amp;lt;index&amp;gt;]&lt;/code&gt; y la clave es leerlo as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="4b69184bd6d629ae67ecbb030f96e1b6febacc6a" translate="yes" xml:space="preserve">
          <source>Of course, if &lt;code&gt;(high-low)%stride != 0&lt;/code&gt;, then the end point will be a little lower than &lt;code&gt;high-1&lt;/code&gt;.</source>
          <target state="translated">Por supuesto, si &lt;code&gt;(high-low)%stride != 0&lt;/code&gt; , entonces el punto final ser&amp;aacute; un poco m&amp;aacute;s bajo que &lt;code&gt;high-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9797498b5445b5a3c49a8d9a5a8bcc115a3f1de4" translate="yes" xml:space="preserve">
          <source>One heuristic is, for a slice from zero to n, think: &quot;zero is the beginning, start at the beginning and take n items in a list&quot;.</source>
          <target state="translated">Una heurística es,para una rebanada de cero a n,pensar:&quot;cero es el principio,empieza por el principio y toma n elementos de una lista&quot;.</target>
        </trans-unit>
        <trans-unit id="1deb5c09927c43e07c799a375e42510fd8ab8301" translate="yes" xml:space="preserve">
          <source>One last thing: if a and b are equal, then also you get an empty list:</source>
          <target state="translated">Una última cosa:si a y b son iguales,entonces también se obtiene una lista vacía:</target>
        </trans-unit>
        <trans-unit id="22de4720e28cbf22dbc85b732b56fab0a497d9da" translate="yes" xml:space="preserve">
          <source>One way to remember how slices work is to think of the indices as pointing &lt;em&gt;between&lt;/em&gt; characters, with the left edge of the first character numbered 0. Then the right edge of the last character of a string of &lt;em&gt;n&lt;/em&gt; characters has index &lt;em&gt;n&lt;/em&gt;.</source>
          <target state="translated">Una forma de recordar c&amp;oacute;mo funcionan las rebanadas es pensar en los &amp;iacute;ndices como apuntando &lt;em&gt;entre&lt;/em&gt; caracteres, con el borde izquierdo del primer car&amp;aacute;cter numerado 0. Luego, el borde derecho del &amp;uacute;ltimo car&amp;aacute;cter de una cadena de &lt;em&gt;n&lt;/em&gt; caracteres tiene el &amp;iacute;ndice &lt;em&gt;n&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="01230747b9914341b6ea0abf3a127d2554050e61" translate="yes" xml:space="preserve">
          <source>Otherwise &lt;code&gt;step&lt;/code&gt; is positive, and the lower bound will be zero and the upper bound (which we go up to but not including) the length of the sliced list.</source>
          <target state="translated">De lo contrario, el &lt;code&gt;step&lt;/code&gt; es positivo, y el l&amp;iacute;mite inferior ser&amp;aacute; cero y el l&amp;iacute;mite superior (que subiremos pero no incluiremos) la longitud de la lista dividida.</target>
        </trans-unit>
        <trans-unit id="6ee09859ae901d353f04d7756fc619a422996265" translate="yes" xml:space="preserve">
          <source>Out of range error?</source>
          <target state="translated">¿Error fuera de rango?</target>
        </trans-unit>
        <trans-unit id="1e32d6d4f298657e76954434ba9df3c467b606d2" translate="yes" xml:space="preserve">
          <source>Positive indices for &lt;code&gt;end&lt;/code&gt; indicate the position &lt;em&gt;after&lt;/em&gt; the last element to be included.</source>
          <target state="translated">Los &amp;iacute;ndices positivos para el &lt;code&gt;end&lt;/code&gt; indican la posici&amp;oacute;n &lt;em&gt;despu&amp;eacute;s&lt;/em&gt; del &amp;uacute;ltimo elemento que se incluir&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="94740c4c4bc99ca509491718d4ba079f2a8f218e" translate="yes" xml:space="preserve">
          <source>Python is kind to the programmer if there are fewer items than you ask for. For example, if you ask for &lt;code&gt;a[:-2]&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen.</source>
          <target state="translated">Python es amable con el programador si hay menos elementos de los que pides. Por ejemplo, si solicita &lt;code&gt;a[:-2]&lt;/code&gt; y &lt;code&gt;a&lt;/code&gt; solo contiene un elemento, obtendr&amp;aacute; una lista vac&amp;iacute;a en lugar de un error. A veces preferir&amp;iacute;a el error, por lo que debe tener en cuenta que esto puede suceder.</target>
        </trans-unit>
        <trans-unit id="b248a1be31c8962b0faa6461a8e1ebdb8bf936b1" translate="yes" xml:space="preserve">
          <source>Python slicing is a computationally fast way to methodically access parts of your data. In my opinion, to be even an intermediate Python programmer, it's one aspect of the language that it is necessary to be familiar with.</source>
          <target state="translated">El rebanado de pitón es una forma computacionalmente rápida de acceder metódicamente a partes de sus datos.En mi opinión,para ser incluso un programador Python intermedio,es un aspecto del lenguaje con el que hay que estar familiarizado.</target>
        </trans-unit>
        <trans-unit id="4be307b534051fdddbb09f680b1f90334e27c87c" translate="yes" xml:space="preserve">
          <source>Python slicing notation:</source>
          <target state="translated">Notación de rebanadas de pitón:</target>
        </trans-unit>
        <trans-unit id="0f99ce71c7cc473f59ebcdd42fafcac7ebb5607c" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&quot;&gt;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&lt;/a&gt;</source>
          <target state="translated">Referencia: &lt;a href=&quot;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&quot;&gt;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="85e3167baf4fe31a5ac66fca1064289b89090879" translate="yes" xml:space="preserve">
          <source>Relation to &lt;code&gt;slice()&lt;/code&gt; object</source>
          <target state="translated">Relaci&amp;oacute;n con el objeto &lt;code&gt;slice()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ded5af84f53bac1b910e783dc1876f40d1930247" translate="yes" xml:space="preserve">
          <source>Remember that we are setting the boundaries. And those boundaries are the positions where you could place some brackets that will be wrapped around the substring like this ...</source>
          <target state="translated">Recuerda que estamos estableciendo los límites.Y esos límites son las posiciones en las que podrías colocar algunos paréntesis que se enrollarán alrededor de la subcadena así...</target>
        </trans-unit>
        <trans-unit id="87aef1727fb2103950e2e345944a306d9d583015" translate="yes" xml:space="preserve">
          <source>Sequence slicing is same, except it first normalizes negative indexes, and it can never go outside the sequence:</source>
          <target state="translated">El corte de la secuencia es el mismo,excepto que primero normaliza los índices negativos,y nunca puede salirse de la secuencia:</target>
        </trans-unit>
        <trans-unit id="96eaebe560215c517ad3e5af8e2a9735ecb8738d" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;step&lt;/code&gt; may be a negative number:</source>
          <target state="translated">Del mismo modo, el &lt;code&gt;step&lt;/code&gt; puede ser un n&amp;uacute;mero negativo:</target>
        </trans-unit>
        <trans-unit id="ae00240360bccc296201ca8138f454fe741d7f58" translate="yes" xml:space="preserve">
          <source>Since slices of Python lists create new objects in memory, another important function to be aware of is &lt;code&gt;itertools.islice&lt;/code&gt;. Typically you'll want to iterate over a slice, not just have it created statically in memory. &lt;code&gt;islice&lt;/code&gt; is perfect for this. A caveat, it doesn't support negative arguments to &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, or &lt;code&gt;step&lt;/code&gt;, so if that's an issue you may need to calculate indices or reverse the iterable in advance.</source>
          <target state="translated">Dado que las secciones de las listas de Python crean nuevos objetos en la memoria, otra funci&amp;oacute;n importante a tener en cuenta es &lt;code&gt;itertools.islice&lt;/code&gt; . Por lo general, querr&amp;aacute;s iterar sobre un segmento, no solo crearlo est&amp;aacute;ticamente en la memoria. &lt;code&gt;islice&lt;/code&gt; es perfecto para esto. Una advertencia, no admite argumentos negativos para &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; o &lt;code&gt;step&lt;/code&gt; , por lo que si ese es un problema, es posible que deba calcular &amp;iacute;ndices o revertir el iterable de antemano.</target>
        </trans-unit>
        <trans-unit id="8c3c2e5e113c75c44c107bde062191fa1ee7c4b5" translate="yes" xml:space="preserve">
          <source>Slice notation to get the last nine elements from a list (or any other sequence that supports it, like a string) would look like this:</source>
          <target state="translated">La notación de corte para obtener los últimos nueve elementos de una lista (o cualquier otra secuencia que la apoye,como una cadena)se vería así:</target>
        </trans-unit>
        <trans-unit id="afd155507ef02b023315f7f2437ce7518f12da0e" translate="yes" xml:space="preserve">
          <source>Slice notation works like this:</source>
          <target state="translated">La notación del corte funciona así:</target>
        </trans-unit>
        <trans-unit id="2bf8562fbd4372800fdbdad7eef6770e5b0c3ac3" translate="yes" xml:space="preserve">
          <source>Slice objects also behave slightly differently depending on the number of arguments, similarly to &lt;code&gt;range()&lt;/code&gt;, i.e. both &lt;code&gt;slice(stop)&lt;/code&gt; and &lt;code&gt;slice(start, stop[, step])&lt;/code&gt; are supported.
To skip specifying a given argument, one might use &lt;code&gt;None&lt;/code&gt;, so that e.g. &lt;code&gt;a[start:]&lt;/code&gt; is equivalent to &lt;code&gt;a[slice(start, None)]&lt;/code&gt; or &lt;code&gt;a[::-1]&lt;/code&gt; is equivalent to &lt;code&gt;a[slice(None, None, -1)]&lt;/code&gt;.</source>
          <target state="translated">Los objetos de divisi&amp;oacute;n tambi&amp;eacute;n se comportan de manera ligeramente diferente dependiendo del n&amp;uacute;mero de argumentos, de manera similar a &lt;code&gt;range()&lt;/code&gt; , es decir, se admiten tanto la &lt;code&gt;slice(stop)&lt;/code&gt; como la &lt;code&gt;slice(start, stop[, step])&lt;/code&gt; . Para omitir la especificaci&amp;oacute;n de un argumento dado, uno podr&amp;iacute;a usar &lt;code&gt;None&lt;/code&gt; , de modo que, por ejemplo, &lt;code&gt;a[start:]&lt;/code&gt; es equivalente a &lt;code&gt;a[slice(start, None)]&lt;/code&gt; o &lt;code&gt;a[::-1]&lt;/code&gt; es equivalente a &lt;code&gt;a[slice(None, None, -1)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0de34fe528d24a6ab78b22ea621d459ea58bcde" translate="yes" xml:space="preserve">
          <source>Slices hold references, not copies, of the array elements.  If you want to make a separate copy an array, you can use &lt;a href=&quot;https://stackoverflow.com/questions/6532881/how-to-make-a-copy-of-a-2d-array-in-python&quot;&gt;&lt;code&gt;deepcopy()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Los sectores contienen referencias, no copias, de los elementos de la matriz. Si desea hacer una copia separada de una matriz, puede usar &lt;a href=&quot;https://stackoverflow.com/questions/6532881/how-to-make-a-copy-of-a-2d-array-in-python&quot;&gt; &lt;code&gt;deepcopy()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7a0ec14b698ea62c178c70915809b11eee0b1d4" translate="yes" xml:space="preserve">
          <source>Slicing example: [start:end:step]</source>
          <target state="translated">Ejemplo de rebanada:[inicio:fin:paso]</target>
        </trans-unit>
        <trans-unit id="0fab7676f1313a7031d732db17a3266ea48b260e" translate="yes" xml:space="preserve">
          <source>Slicing in Python</source>
          <target state="translated">Rebanar en Python</target>
        </trans-unit>
        <trans-unit id="2f82b358ce4a2bd3562b18aca5eb96f4abc16964" translate="yes" xml:space="preserve">
          <source>Slicing is like dealing with boxes themselves. You can pick up the first box and place it on another table. To pick up the box, all you need to know is the position of beginning and ending of the box.</source>
          <target state="translated">Cortar es como tratar con las cajas mismas.Puedes coger la primera caja y colocarla en otra mesa.Para recoger la caja,todo lo que necesitas saber es la posición del principio y el final de la caja.</target>
        </trans-unit>
        <trans-unit id="b6071a94da6c32b2f41ecdb9b7c54c4fc53d3bbe" translate="yes" xml:space="preserve">
          <source>So all you have to do is setting index1 and index2 to the values that will surround the desired substring. For instance, to get the substring &quot;cdefgh&quot;, you can use &lt;code&gt;azString[2:8]&lt;/code&gt;, because the index on the left side of &quot;c&quot; is 2 and the one on the right size of &quot;h&quot; is 8.</source>
          <target state="translated">Entonces, todo lo que tiene que hacer es establecer index1 e index2 a los valores que rodear&amp;aacute;n la subcadena deseada. Por ejemplo, para obtener la subcadena &quot;cdefgh&quot;, puede usar &lt;code&gt;azString[2:8]&lt;/code&gt; , porque el &amp;iacute;ndice en el lado izquierdo de &quot;c&quot; es 2 y el del tama&amp;ntilde;o correcto de &quot;h&quot; es 8.</target>
        </trans-unit>
        <trans-unit id="9d36a8ded558a57acb9a21c94c859b6d67771f8e" translate="yes" xml:space="preserve">
          <source>So possible variations are:</source>
          <target state="translated">Así que las posibles variaciones son:</target>
        </trans-unit>
        <trans-unit id="5e112be622e92277daa08e6daca504e718916de7" translate="yes" xml:space="preserve">
          <source>That trick works all the time and is easy to memorize.</source>
          <target state="translated">Ese truco funciona todo el tiempo y es fácil de memorizar.</target>
        </trans-unit>
        <trans-unit id="fdf01cb06945a582fa2999e094744ca983173e6c" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;:2&lt;/code&gt;&quot; before the comma operates on the first dimension and the &quot;&lt;code&gt;0:3:2&lt;/code&gt;&quot; after the comma operates on the second dimension.</source>
          <target state="translated">El &quot; &lt;code&gt;:2&lt;/code&gt; &quot; antes de la coma opera en la primera dimensi&amp;oacute;n y el &quot; &lt;code&gt;0:3:2&lt;/code&gt; &quot; despu&amp;eacute;s de que la coma opera en la segunda dimensi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="671738aa3584c456b592e354d91684dcd323f399" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://docs.python.org/tutorial/introduction.html#strings&quot;&gt;Python tutorial&lt;/a&gt; talks about it (scroll down a bit until you get to the part about slicing).</source>
          <target state="translated">El &lt;a href=&quot;http://docs.python.org/tutorial/introduction.html#strings&quot;&gt;tutorial de Python&lt;/a&gt; habla de ello (despl&amp;aacute;cese hacia abajo un poco hasta llegar a la parte sobre el corte).</target>
        </trans-unit>
        <trans-unit id="fb121e6f32b2ed82d98fe529053634abd387ad84" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;colon&lt;/strong&gt;, &lt;code&gt;:&lt;/code&gt;,  is what tells Python you're giving it a slice and not a regular index. That's why the idiomatic way of making a shallow copy of lists in Python 2 is</source>
          <target state="translated">Los &lt;strong&gt;dos puntos&lt;/strong&gt; , &lt;code&gt;:&lt;/code&gt; , es lo que le dice a Python que le est&amp;aacute; dando una porci&amp;oacute;n y no un &amp;iacute;ndice regular. Es por eso que la forma idiom&amp;aacute;tica de hacer una copia superficial de listas en Python 2 es</target>
        </trans-unit>
        <trans-unit id="064ca1037f07ebe70ccb6e0e4303cf9c8fd960d8" translate="yes" xml:space="preserve">
          <source>The ASCII art diagram is helpful too for remembering how slices work:</source>
          <target state="translated">El diagrama de arte ASCII también es útil para recordar cómo funcionan los cortes:</target>
        </trans-unit>
        <trans-unit id="c2a53ea7c27bc274090377248543665760dc2d23" translate="yes" xml:space="preserve">
          <source>The above part explains the core features on how slice works, and it will work on most occasions. However, there can be pitfalls you should watch out, and this part explains them.</source>
          <target state="translated">La parte de arriba explica las características principales de cómo funciona la rebanada,y funcionará en la mayoría de las ocasiones.Sin embargo,puede haber dificultades que debes tener en cuenta,y esta parte las explica.</target>
        </trans-unit>
        <trans-unit id="9a0d878051d5575a2cc4db1865d8619aa0945996" translate="yes" xml:space="preserve">
          <source>The answers above don't discuss slice assignment. To understand slice assignment, it's helpful to add another concept to the ASCII art:</source>
          <target state="translated">Las respuestas anteriores no hablan de la asignación de los cortes.Para entender la asignación de los cortes,es útil añadir otro concepto al arte ASCII:</target>
        </trans-unit>
        <trans-unit id="4827bfb62b55032ff3bc19f8d7461338d02ba84c" translate="yes" xml:space="preserve">
          <source>The basic slicing technique is to define the starting point, the stopping point, and the step size - also known as stride.</source>
          <target state="translated">La técnica básica de corte es definir el punto de inicio,el punto de parada y el tamaño del paso,también conocido como zancada.</target>
        </trans-unit>
        <trans-unit id="7afa04f193c1a31833d08e539febf8032a61d69d" translate="yes" xml:space="preserve">
          <source>The below is the example of an index of a string:</source>
          <target state="translated">A continuación se muestra el ejemplo de un índice de una cadena:</target>
        </trans-unit>
        <trans-unit id="a6fdc6b5102e017e74aa1ebfa120ec1728976bd7" translate="yes" xml:space="preserve">
          <source>The best way to illustrate what slicing does internally is just show it in code that implements this operation:</source>
          <target state="translated">La mejor manera de ilustrar lo que hace el rebanado internamente es mostrarlo en el código que implementa esta operación:</target>
        </trans-unit>
        <trans-unit id="9b289ec304478ab3aa8206822ac93132cd9189a0" translate="yes" xml:space="preserve">
          <source>The extended indexing syntax used for slicing is &lt;code&gt;aList[start:stop:step]&lt;/code&gt;, and basic examples are:</source>
          <target state="translated">La sintaxis de indexaci&amp;oacute;n extendida utilizada para &lt;code&gt;aList[start:stop:step]&lt;/code&gt; es aList [start: stop: step] , y los ejemplos b&amp;aacute;sicos son:</target>
        </trans-unit>
        <trans-unit id="835f8ab3b0337722c0f132a2e78a9079b59cded7" translate="yes" xml:space="preserve">
          <source>The fact that list slices make a copy is a feature of lists themselves. If you're slicing advanced objects like a Pandas DataFrame, it may return a view on the original, and not a copy.</source>
          <target state="translated">El hecho de que los trozos de lista hagan una copia es una característica de las propias listas.Si estás rebanando objetos avanzados como un Pandas DataFrame,puede que devuelva una vista del original,y no una copia.</target>
        </trans-unit>
        <trans-unit id="41c12238b9c9bbcd33df30b54dc049e7a8a037bb" translate="yes" xml:space="preserve">
          <source>The first rule of slice assignment is that since slicing &lt;em&gt;returns&lt;/em&gt; a list, slice assignment &lt;em&gt;requires&lt;/em&gt; a list (or other iterable):</source>
          <target state="translated">La primera regla de la asignaci&amp;oacute;n de divisi&amp;oacute;n es que, dado que la divisi&amp;oacute;n &lt;em&gt;devuelve&lt;/em&gt; una lista, la asignaci&amp;oacute;n de divisi&amp;oacute;n &lt;em&gt;requiere&lt;/em&gt; una lista (u otro iterable):</target>
        </trans-unit>
        <trans-unit id="053d4b345613c9e63af290ea87904c13976fb020" translate="yes" xml:space="preserve">
          <source>The full notation is</source>
          <target state="translated">La notación completa es</target>
        </trans-unit>
        <trans-unit id="a279c32eedbdb41ca0663a3f3c7caa14aacb8d48" translate="yes" xml:space="preserve">
          <source>The interesting thing is that you can replace multiple boxes at once. Also you can place multiple boxes wherever you like.</source>
          <target state="translated">Lo interesante es que puedes reemplazar varias cajas a la vez.También puedes colocar varias cajas donde quieras.</target>
        </trans-unit>
        <trans-unit id="cbafdf992eb9b0ec11721982bbb3effe97d12b16" translate="yes" xml:space="preserve">
          <source>The key point to remember is that the &lt;code&gt;:stop&lt;/code&gt; value represents the first value that is &lt;em&gt;not&lt;/em&gt; in the selected slice. So, the difference between &lt;code&gt;stop&lt;/code&gt; and &lt;code&gt;start&lt;/code&gt; is the number of elements selected (if &lt;code&gt;step&lt;/code&gt; is 1, the default).</source>
          <target state="translated">El punto clave a recordar es que el valor &lt;code&gt;:stop&lt;/code&gt; representa el primer valor que &lt;em&gt;no&lt;/em&gt; est&amp;aacute; en el segmento seleccionado. Entonces, la diferencia entre &lt;code&gt;stop&lt;/code&gt; e &lt;code&gt;start&lt;/code&gt; es la cantidad de elementos seleccionados (si el &lt;code&gt;step&lt;/code&gt; es 1, el valor predeterminado).</target>
        </trans-unit>
        <trans-unit id="75586a32a01b71ebd61830c9004e1d99bb7e7f3c" translate="yes" xml:space="preserve">
          <source>The notation extends to (numpy) matrices and multidimensional arrays.  For example, to slice entire columns you can use:</source>
          <target state="translated">La notación se extiende a matrices (numéricas)y conjuntos multidimensionales.Por ejemplo,para cortar columnas enteras se puede usar:</target>
        </trans-unit>
        <trans-unit id="517bdfc38c62e4ed8dbc0ebe6233fdd418806066" translate="yes" xml:space="preserve">
          <source>The other feature is that &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;stop&lt;/code&gt; may be a &lt;em&gt;negative&lt;/em&gt; number, which means it counts from the end of the array instead of the beginning. So:</source>
          <target state="translated">La otra caracter&amp;iacute;stica es que &lt;code&gt;start&lt;/code&gt; o &lt;code&gt;stop&lt;/code&gt; puede ser un n&amp;uacute;mero &lt;em&gt;negativo&lt;/em&gt; , lo que significa que cuenta desde el final de la matriz en lugar del principio. Entonces:</target>
        </trans-unit>
        <trans-unit id="88cb13542cd6c22a7ed79eaff2dca42af648aa1a" translate="yes" xml:space="preserve">
          <source>The previous answers don't discuss multi-dimensional array slicing which is possible using the famous &lt;a href=&quot;http://en.wikipedia.org/wiki/NumPy&quot;&gt;NumPy&lt;/a&gt; package:</source>
          <target state="translated">Las respuestas anteriores no discuten el corte de matriz multidimensional que es posible usando el famoso paquete &lt;a href=&quot;http://en.wikipedia.org/wiki/NumPy&quot;&gt;NumPy&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bcb48bc85f26256a3ee0c0f6a3e5b4429c47ae72" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;code&gt;None&lt;/code&gt;, is required, so that the first argument is interpreted as the &lt;code&gt;start&lt;/code&gt; argument &lt;a href=&quot;https://docs.python.org/2/library/functions.html#slice&quot;&gt;otherwise it would be the &lt;code&gt;stop&lt;/code&gt; argument&lt;/a&gt;.</source>
          <target state="translated">Se requiere el segundo argumento, &lt;code&gt;None&lt;/code&gt; , para que el primer argumento se interprete como el argumento de &lt;code&gt;start&lt;/code&gt; &lt;a href=&quot;https://docs.python.org/2/library/functions.html#slice&quot;&gt;contrario, ser&amp;iacute;a el argumento de &lt;code&gt;stop&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="596e5324916e7331fb73503433bce1ac5233475a" translate="yes" xml:space="preserve">
          <source>The second rule of slice assignment, which you can also see above, is that whatever portion of the list is returned by slice indexing, that's the same portion that is changed by slice assignment:</source>
          <target state="translated">La segunda regla de la asignación de rebanadas,que también se puede ver arriba,es que cualquier porción de la lista se devuelve por la indexación de rebanadas,es la misma porción que se cambia por la asignación de rebanadas:</target>
        </trans-unit>
        <trans-unit id="e952b134f12b0ea29603efb0b559bc9cc9ad704f" translate="yes" xml:space="preserve">
          <source>The slicing operator &lt;code&gt;[]&lt;/code&gt; is actually being used in the above code with a &lt;code&gt;slice()&lt;/code&gt; object using the &lt;code&gt;:&lt;/code&gt; notation (which is only valid within &lt;code&gt;[]&lt;/code&gt;), i.e.:</source>
          <target state="translated">El operador de divisi&amp;oacute;n &lt;code&gt;[]&lt;/code&gt; en realidad se est&amp;aacute; utilizando en el c&amp;oacute;digo anterior con un objeto &lt;code&gt;slice()&lt;/code&gt; usando la notaci&amp;oacute;n &lt;code&gt;:&lt;/code&gt; (que solo es v&amp;aacute;lida dentro de &lt;code&gt;[]&lt;/code&gt; ), es decir:</target>
        </trans-unit>
        <trans-unit id="e691224537259b930d7e6fe4624c31eea62f2d85" translate="yes" xml:space="preserve">
          <source>The thing to remember about negative step is that &lt;code&gt;stop&lt;/code&gt; is always the excluded end, whether it's higher or lower. If you want same slice in opposite order, it's much cleaner to do the reversal separately: e.g. &lt;code&gt;'abcde'[1:-2][::-1]&lt;/code&gt; slices off one char from left, two from right, then reverses. (See also &lt;a href=&quot;http://www.python.org/dev/peps/pep-0322/&quot;&gt;&lt;code&gt;reversed()&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">Lo que hay que recordar sobre el paso negativo es que &lt;code&gt;stop&lt;/code&gt; siempre es el final excluido, ya sea m&amp;aacute;s alto o m&amp;aacute;s bajo. Si desea el mismo corte en el orden opuesto, es mucho m&amp;aacute;s limpio hacer la inversi&amp;oacute;n por separado: por ejemplo, &lt;code&gt;'abcde'[1:-2][::-1]&lt;/code&gt; corta un char desde la izquierda, dos desde la derecha, luego invierte. (Ver tambi&amp;eacute;n &lt;a href=&quot;http://www.python.org/dev/peps/pep-0322/&quot;&gt; &lt;code&gt;reversed()&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="77887242adef23e77fb02d89d877a784f02e2b36" translate="yes" xml:space="preserve">
          <source>The third rule of slice assignment is, the assigned list (iterable) doesn't have to have the same length; the indexed slice is simply sliced out and replaced en masse by whatever is being assigned:</source>
          <target state="translated">La tercera regla de asignación de cortes es que la lista asignada (iterable)no tiene por qué tener la misma longitud;el corte indexado simplemente se corta y se sustituye en masa por lo que se asigna:</target>
        </trans-unit>
        <trans-unit id="29855a6656d9eb287192ae5bff65ab56fdd630e5" translate="yes" xml:space="preserve">
          <source>The trickiest part to get used to is assignment to empty slices. Using heuristic 1 and 2 it's easy to get your head around &lt;em&gt;indexing&lt;/em&gt; an empty slice:</source>
          <target state="translated">La parte m&amp;aacute;s complicada para acostumbrarse es la asignaci&amp;oacute;n a sectores vac&amp;iacute;os. Con la heur&amp;iacute;stica 1 y 2 es f&amp;aacute;cil entender &lt;em&gt;c&amp;oacute;mo indexar&lt;/em&gt; una porci&amp;oacute;n vac&amp;iacute;a:</target>
        </trans-unit>
        <trans-unit id="4443911b7fa6e0ec19af60b9f6f8c54543309dbe" translate="yes" xml:space="preserve">
          <source>The very first thing that confuses Python learners is that &lt;strong&gt;an index can be negative!&lt;/strong&gt;
Don't panic: &lt;strong&gt;a negative index means count backwards.&lt;/strong&gt;</source>
          <target state="translated">&amp;iexcl;Lo primero que confunde a los estudiantes de Python es que &lt;strong&gt;un &amp;iacute;ndice puede ser negativo!&lt;/strong&gt; No entre en p&amp;aacute;nico: &lt;strong&gt;un &amp;iacute;ndice negativo significa contar hacia atr&amp;aacute;s.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc233fdd4b1aa1d0eec08f781b67af8b6d1de6f5" translate="yes" xml:space="preserve">
          <source>Then the negative indexing just needs you to add the length of the string to the negative indices to understand it.</source>
          <target state="translated">Entonces el índice negativo sólo necesita que añadas la longitud de la cadena a los índices negativos para entenderlo.</target>
        </trans-unit>
        <trans-unit id="849becd57d4d9dfce3e88751e6e091a0dece7725" translate="yes" xml:space="preserve">
          <source>Then, we may need to apply the defaults for &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; - the default then for &lt;code&gt;start&lt;/code&gt; is calculated as the upper bound when &lt;code&gt;step&lt;/code&gt; is negative:</source>
          <target state="translated">Entonces, es posible que necesitemos aplicar los valores predeterminados para &lt;code&gt;start&lt;/code&gt; y &lt;code&gt;stop&lt;/code&gt; : el valor predeterminado para &lt;code&gt;start&lt;/code&gt; se calcula como el l&amp;iacute;mite superior cuando el &lt;code&gt;step&lt;/code&gt; es negativo:</target>
        </trans-unit>
        <trans-unit id="b7d7ff65eee8f921208cc372c6ebb7dfee9bb661" translate="yes" xml:space="preserve">
          <source>There are some weird consequences to the &quot;once you're done, you're done&quot; rule:</source>
          <target state="translated">Hay algunas consecuencias extrañas en la regla de &quot;una vez que terminas,terminas&quot;:</target>
        </trans-unit>
        <trans-unit id="d9a00425fdfcba9c3b6367238a922973214a9b04" translate="yes" xml:space="preserve">
          <source>There is also the &lt;code&gt;step&lt;/code&gt; value, which can be used with any of the above:</source>
          <target state="translated">Tambi&amp;eacute;n est&amp;aacute; el valor del &lt;code&gt;step&lt;/code&gt; , que se puede usar con cualquiera de los anteriores:</target>
        </trans-unit>
        <trans-unit id="8748ae39a14aa6c556cf400a604d76f7a5986f03" translate="yes" xml:space="preserve">
          <source>This can come in handy sometimes, but it can also lead to somewhat strange behavior:</source>
          <target state="translated">Esto puede ser útil a veces,pero también puede conducir a un comportamiento algo extraño:</target>
        </trans-unit>
        <trans-unit id="096585dfd11ee121086fdfe39adc2486eb298a85" translate="yes" xml:space="preserve">
          <source>This function takes a Python object and optional parameters for slicing and returns the start, stop, step, and slice length for the requested slice.</source>
          <target state="translated">Esta función toma un objeto Python y parámetros opcionales para el rebanado y devuelve el inicio,la parada,el paso y la longitud del rebanado para el rebanado solicitado.</target>
        </trans-unit>
        <trans-unit id="5c019865eaefe89398d12a470966b9e731ebcceb" translate="yes" xml:space="preserve">
          <source>This is how I teach slices to newbies:</source>
          <target state="translated">Así es como enseño rebanadas a los novatos:</target>
        </trans-unit>
        <trans-unit id="93ec6623e85643a7f24c84166f00188e862c3121" translate="yes" xml:space="preserve">
          <source>This is just for some extra info...
Consider the list below</source>
          <target state="translated">Esto es sólo para tener información extra...Considere la siguiente lista</target>
        </trans-unit>
        <trans-unit id="2f3bd8ad9ced207179166369787553277fa774f3" translate="yes" xml:space="preserve">
          <source>This is the diagram:</source>
          <target state="translated">Este es el diagrama:</target>
        </trans-unit>
        <trans-unit id="30363f59507d9db8769972ab941783b864dbd2ab" translate="yes" xml:space="preserve">
          <source>This is the intelligence that is present behind slices. Since Python has an built-in function called slice, you can pass some parameters and check how smartly it calculates missing parameters.</source>
          <target state="translated">Esta es la inteligencia que está presente detrás de las rebanadas.Como Python tiene una función incorporada llamada &quot;slice&quot;,puedes pasar algunos parámetros y comprobar con qué inteligencia calcula los parámetros que faltan.</target>
        </trans-unit>
        <trans-unit id="d57f5dd395014f54497c19cddb5a2ce5c7ea7a57" translate="yes" xml:space="preserve">
          <source>This may also clarify the difference between slicing and indexing.</source>
          <target state="translated">Esto también puede aclarar la diferencia entre el corte y la indexación.</target>
        </trans-unit>
        <trans-unit id="b95f0acc0a5d079ab45b81544212226023725e34" translate="yes" xml:space="preserve">
          <source>This pretty property tells me that &lt;code&gt;lst[start:end]&lt;/code&gt; does not contain the &lt;code&gt;end&lt;/code&gt;-th item because it is in &lt;code&gt;lst[end:]&lt;/code&gt;.</source>
          <target state="translated">Esta bonita propiedad me dice que &lt;code&gt;lst[start:end]&lt;/code&gt; no contiene el elemento &lt;code&gt;end&lt;/code&gt; -th porque est&amp;aacute; en &lt;code&gt;lst[end:]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8007629ae4bd6492e6ac3709a0f6817d52e38741" translate="yes" xml:space="preserve">
          <source>This way, I can think of &lt;code&gt;a[-4:-6:-1]&lt;/code&gt; as &lt;code&gt;a(-6,-4]&lt;/code&gt; in interval terminology.</source>
          <target state="translated">De esta manera, puedo pensar en &lt;code&gt;a[-4:-6:-1]&lt;/code&gt; como &lt;code&gt;a(-6,-4]&lt;/code&gt; en terminolog&amp;iacute;a de intervalo.</target>
        </trans-unit>
        <trans-unit id="88160c485e5bf5fb043177dc6d2bf96217e61ab0" translate="yes" xml:space="preserve">
          <source>This works for me anyway...</source>
          <target state="translated">Esto funciona para mí de todos modos...</target>
        </trans-unit>
        <trans-unit id="36a968ddf7619f1775f5b9341d45ab5c6d7d9f33" translate="yes" xml:space="preserve">
          <source>Thus a negative slice will change the defaults for &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;!</source>
          <target state="translated">Por lo tanto, un segmento negativo cambiar&amp;aacute; los valores predeterminados para &lt;code&gt;start&lt;/code&gt; y &lt;code&gt;stop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c35d5a48cbaacaa30e85a96cdc7b46a6bf157e1" translate="yes" xml:space="preserve">
          <source>Till now you have picked boxes continuously. But sometimes you need to pick up discretely. For example, you can pick up every second box. You can even pick up every third box from the end. This value is called step size. This represents the gap between your successive pickups. The step size should be positive if You are picking boxes from the beginning to end and vice versa.</source>
          <target state="translated">Hasta ahora has escogido cajas continuamente.Pero a veces necesitas recoger discretamente.Por ejemplo,puedes recoger cada segunda caja.Incluso puedes recoger una de cada tres cajas desde el final.Este valor se llama tamaño de paso.Representa el espacio entre las sucesivas recogidas.El tamaño del paso debe ser positivo si recoge las cajas desde el principio hasta el final y viceversa.</target>
        </trans-unit>
        <trans-unit id="31ee61905e41466bdf813b3f8668d410b0e1fa58" translate="yes" xml:space="preserve">
          <source>To begin with, let's define a few terms:</source>
          <target state="translated">Para empezar,definamos algunos términos:</target>
        </trans-unit>
        <trans-unit id="2e1c54513da531934e461b5f4aa70c3c39a3e784" translate="yes" xml:space="preserve">
          <source>To make it simple, remember &lt;strong&gt;slice has only one form：&lt;/strong&gt;</source>
          <target state="translated">Para hacerlo simple, recuerde que la &lt;strong&gt;rebanada solo tiene una forma:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6133370c4351e43ebcb470ed39b01c2df88aa87a" translate="yes" xml:space="preserve">
          <source>To me, this notation needs a bit of picking up.</source>
          <target state="translated">Para mí,esta notación necesita un poco de atención.</target>
        </trans-unit>
        <trans-unit id="427ca464e82784a054828caeff41890bcf767d80" translate="yes" xml:space="preserve">
          <source>To retrieve a subset of elements, the start and stop positions need to be defined.</source>
          <target state="translated">Para recuperar un subconjunto de elementos,es necesario definir las posiciones de inicio y parada.</target>
        </trans-unit>
        <trans-unit id="8e7a6a811c35a7adca15b7530f42f47e0dda5845" translate="yes" xml:space="preserve">
          <source>To use slice notation with a sequence that supports it, you must include at least one colon in the square brackets that follow the sequence (which actually &lt;a href=&quot;https://docs.python.org/2/reference/datamodel.html#object.__getitem__&quot;&gt;implement the &lt;code&gt;__getitem__&lt;/code&gt; method of the sequence, according to the Python data model&lt;/a&gt;.)</source>
          <target state="translated">Para usar la notaci&amp;oacute;n de corte con una secuencia que lo admita, debe incluir al menos dos puntos en los corchetes que siguen la secuencia (que en realidad &lt;a href=&quot;https://docs.python.org/2/reference/datamodel.html#object.__getitem__&quot;&gt;implementan el m&amp;eacute;todo &lt;code&gt;__getitem__&lt;/code&gt; de la secuencia, de acuerdo con el modelo de datos de Python&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0e7a206b9021aa8d0ea3e3c6e22e9c2a9fd3b850" translate="yes" xml:space="preserve">
          <source>Understanding index assignment is very important.</source>
          <target state="translated">Entender la asignación de los índices es muy importante.</target>
        </trans-unit>
        <trans-unit id="eb8117520c3958acd43c0f8e454eeec3f534d349" translate="yes" xml:space="preserve">
          <source>Understanding slice notation</source>
          <target state="translated">Comprensión de la notación de la rebanada</target>
        </trans-unit>
        <trans-unit id="10c5a38a7a014349bab2658d201f411e1780237b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;step&lt;/code&gt; provides a useful trick to reverse a collection in Python:</source>
          <target state="translated">El uso del &lt;code&gt;step&lt;/code&gt; proporciona un truco &amp;uacute;til para revertir una colecci&amp;oacute;n en Python:</target>
        </trans-unit>
        <trans-unit id="625b0998df7fa1a8b226d789e201ac2c633e1b85" translate="yes" xml:space="preserve">
          <source>Using a negative step reverses the interpretation of &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;</source>
          <target state="translated">El uso de un paso negativo invierte la interpretaci&amp;oacute;n de &lt;code&gt;start&lt;/code&gt; y &lt;code&gt;end&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="62654d2560fca6df984a34445f5e3dec93d4d93b" translate="yes" xml:space="preserve">
          <source>What always work is to think in characters or slots and use indexing as a half-open interval -- right-open if positive stride, left-open if negative stride.</source>
          <target state="translated">Lo que siempre funciona es pensar en caracteres o ranuras y usar la indexación como un intervalo medio abierto-abierto a la derecha si es una zancada positiva,abierto a la izquierda si es una zancada negativa.</target>
        </trans-unit>
        <trans-unit id="526db1adfef28b92b75500e179ee7473e39b4025" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;step&lt;/code&gt; is negative, the defaults for &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; change</source>
          <target state="translated">Cuando el &lt;code&gt;step&lt;/code&gt; es negativo, los valores predeterminados para &lt;code&gt;start&lt;/code&gt; y &lt;code&gt;stop&lt;/code&gt; cambio</target>
        </trans-unit>
        <trans-unit id="2c8d0413ebb06c76b410bc829582598046a90e73" translate="yes" xml:space="preserve">
          <source>When I see this, I read the part in the brackets as &quot;9th from the end, to the end.&quot; (Actually, I abbreviate it mentally as &quot;-9, on&quot;)</source>
          <target state="translated">Cuando veo esto,leo la parte entre paréntesis como &quot;9º desde el final,hasta el final&quot;.(En realidad,lo abreviaré mentalmente como &quot;-9,sobre&quot;)</target>
        </trans-unit>
        <trans-unit id="6847d5ecc89aafb251c20bc69d5137967a12634d" translate="yes" xml:space="preserve">
          <source>When slicing from the start, you can omit the zero index, and when slicing to the end, you can omit the final index since it is redundant, so do not be verbose:</source>
          <target state="translated">Cuando se corta desde el principio,se puede omitir el índice cero,y cuando se corta hasta el final,se puede omitir el índice final ya que es redundante,así que no sea verboso:</target>
        </trans-unit>
        <trans-unit id="0331d52f669a9d089e322197c2a42b467d18a25b" translate="yes" xml:space="preserve">
          <source>When slicing, if you leave out any parameter, Python tries to figure it out automatically.</source>
          <target state="translated">Al cortar,si dejas fuera cualquier parámetro,Python intenta averiguarlo automáticamente.</target>
        </trans-unit>
        <trans-unit id="ec05e68a3474403744db580556c5b4b5147a48ab" translate="yes" xml:space="preserve">
          <source>When using a negative step, notice that the answer is shifted to the right by 1.</source>
          <target state="translated">Cuando use un paso negativo,note que la respuesta se desplaza a la derecha en 1.</target>
        </trans-unit>
        <trans-unit id="d52f5e951410da3205e348d328fbec3fed74bc94" translate="yes" xml:space="preserve">
          <source>When you say [a:b:c], you are saying depending on the sign of c (forward or backward), start at a and end at b (excluding element at bth index). Use the indexing rule above and remember you will only find elements in this range:</source>
          <target state="translated">Cuando dices [a:b:c],estás diciendo que dependiendo del signo de c (adelante o atrás),empieza en a y termina en b (excluyendo el elemento en el índice bth).Utilice la regla de indexación anterior y recuerde que sólo encontrará elementos en este rango:</target>
        </trans-unit>
        <trans-unit id="60ffa2bfa59ad91cfa5b5fac46b9f1af335ca27a" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;:&lt;/code&gt;-based notation is very helpful for simple slicing, the explicit use of &lt;code&gt;slice()&lt;/code&gt; objects simplifies the programmatic generation of slicing.</source>
          <target state="translated">Si bien la notaci&amp;oacute;n basada en &lt;code&gt;:&lt;/code&gt; es muy &amp;uacute;til para la divisi&amp;oacute;n simple, el uso expl&amp;iacute;cito de los objetos &lt;code&gt;slice()&lt;/code&gt; simplifica la generaci&amp;oacute;n program&amp;aacute;tica de la divisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1fac29e5b50e4050ea0c9107b01d2b1be0ad4b52" translate="yes" xml:space="preserve">
          <source>Wiki Python has this amazing picture which clearly distinguishes indexing and slicing.</source>
          <target state="translated">Wiki Python tiene esta asombrosa imagen que distingue claramente la indexación y el corte.</target>
        </trans-unit>
        <trans-unit id="dc7857679c446d31b3fa48d4d430634f0052baba" translate="yes" xml:space="preserve">
          <source>With extended indexing syntax, we retrieve a range of values. For example, all values are retrieved with a colon.</source>
          <target state="translated">Con una sintaxis de indexación extendida,recuperamos un rango de valores.Por ejemplo,todos los valores se recuperan con un colon.</target>
        </trans-unit>
        <trans-unit id="48850a7b49c3ba2cdae5d4c04076f27217921200" translate="yes" xml:space="preserve">
          <source>With slicing, once you're done, you're done; it doesn't start slicing backwards. In Python you don't get negative strides unless you explicitly ask for them by using a negative number.</source>
          <target state="translated">Con el rebanado,una vez que terminas,terminas;no empieza a rebanar al revés.En Python no obtienes avances negativos a menos que los pidas explícitamente usando un número negativo.</target>
        </trans-unit>
        <trans-unit id="8e6854e86dbd642a89919deb5004ced1375069af" translate="yes" xml:space="preserve">
          <source>X is the index of the first element you want.</source>
          <target state="translated">X es el índice del primer elemento que quieres.</target>
        </trans-unit>
        <trans-unit id="1caf266993cb78b65a51c14f80f90f52a48c1ad0" translate="yes" xml:space="preserve">
          <source>Y is the index of the first element you &lt;em&gt;don't&lt;/em&gt; want.</source>
          <target state="translated">Y es el &amp;iacute;ndice del primer elemento que &lt;em&gt;no&lt;/em&gt; desea.</target>
        </trans-unit>
        <trans-unit id="37c763665adfe6c32f74ceb3ab85198ed95e14f3" translate="yes" xml:space="preserve">
          <source>You can also use slice assignment to remove one or more elements from a list:</source>
          <target state="translated">También puede utilizar la asignación de cortes para eliminar uno o más elementos de una lista:</target>
        </trans-unit>
        <trans-unit id="f6537afebf0730bd8d23b3fe9847bf52f1415c3b" translate="yes" xml:space="preserve">
          <source>You can even pick up the first three boxes or the last two boxes or all boxes between 1 and 4. So, you can pick any set of boxes if you know the beginning and ending. These positions are called start and stop positions.</source>
          <target state="translated">Incluso puedes recoger las tres primeras cajas o las dos últimas o todas las cajas entre 1 y 4.Por lo tanto,puedes recoger cualquier conjunto de cajas si conoces el principio y el final.Estas posiciones se llaman posiciones de inicio y final.</target>
        </trans-unit>
        <trans-unit id="c778f916c05737b62b181e6441afcd1a4fe8b894" translate="yes" xml:space="preserve">
          <source>You can make any of these positive or negative numbers. The meaning of the positive numbers is straightforward, but for negative numbers, just like indexes in Python, you count backwards from the end for the &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;stop&lt;/em&gt;, and for the &lt;em&gt;step&lt;/em&gt;, you simply decrement your index. This example is &lt;a href=&quot;https://docs.python.org/2/tutorial/introduction.html&quot;&gt;from the documentation's tutorial&lt;/a&gt;, but I've modified it slightly to indicate which item in a sequence each index references:</source>
          <target state="translated">Puedes hacer cualquiera de estos n&amp;uacute;meros positivos o negativos. El significado de los n&amp;uacute;meros positivos es sencillo, pero para los n&amp;uacute;meros negativos, al igual que los &amp;iacute;ndices en Python, cuenta hacia atr&amp;aacute;s desde el final para el &lt;em&gt;inicio&lt;/em&gt; y el &lt;em&gt;final&lt;/em&gt; , y para el &lt;em&gt;paso&lt;/em&gt; , simplemente disminuye su &amp;iacute;ndice. Este ejemplo es &lt;a href=&quot;https://docs.python.org/2/tutorial/introduction.html&quot;&gt;del tutorial de la documentaci&amp;oacute;n&lt;/a&gt; , pero lo he modificado ligeramente para indicar a qu&amp;eacute; elemento de una secuencia hace referencia cada &amp;iacute;ndice:</target>
        </trans-unit>
        <trans-unit id="9b7644b509b2bf8e1ff27f855c7f83b37789181c" translate="yes" xml:space="preserve">
          <source>You can run this script and experiment with it, below is some samples that I got from the script.</source>
          <target state="translated">Puedes ejecutar este guión y experimentar con él,abajo hay algunas muestras que obtuve del guión.</target>
        </trans-unit>
        <trans-unit id="64faa3902ada5ca110aa668c8de78a324815760c" translate="yes" xml:space="preserve">
          <source>You can then pass the slice object to your sequence:</source>
          <target state="translated">Entonces puedes pasar el objeto cortado a tu secuencia:</target>
        </trans-unit>
        <trans-unit id="195e61f26a2fef8e34f3db23bd78fcb41bfedb3e" translate="yes" xml:space="preserve">
          <source>You made a cut &lt;strong&gt;before&lt;/strong&gt; the element with index &lt;code&gt;2&lt;/code&gt; and another cut &lt;strong&gt;before&lt;/strong&gt; the element with index &lt;code&gt;5&lt;/code&gt;. So the result will be a slice between those two cuts, a list &lt;code&gt;['T', 'H', 'O']&lt;/code&gt;.</source>
          <target state="translated">Hiciste un corte &lt;strong&gt;antes&lt;/strong&gt; del elemento con &amp;iacute;ndice &lt;code&gt;2&lt;/code&gt; y otro corte &lt;strong&gt;antes&lt;/strong&gt; del elemento con &amp;iacute;ndice &lt;code&gt;5&lt;/code&gt; . Por lo tanto, el resultado ser&amp;aacute; una divisi&amp;oacute;n entre esos dos cortes, una lista &lt;code&gt;['T', 'H', 'O']&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89d9115fa306118ea0f00933e8378ed5c6878642" translate="yes" xml:space="preserve">
          <source>You may find it useful to separate forming the slice from passing it to the &lt;code&gt;list.__getitem__&lt;/code&gt; method (&lt;a href=&quot;https://docs.python.org/2/reference/datamodel.html#object.__getitem__&quot;&gt;that's what the square brackets do&lt;/a&gt;). Even if you're not new to it, it keeps your code more readable so that others that may have to read your code can more readily understand what you're doing.</source>
          <target state="translated">Puede resultarle &amp;uacute;til separar la formaci&amp;oacute;n de la porci&amp;oacute;n de pasarla a la &lt;code&gt;list.__getitem__&lt;/code&gt; m&amp;eacute;todo getitem__ ( &lt;a href=&quot;https://docs.python.org/2/reference/datamodel.html#object.__getitem__&quot;&gt;eso es lo que hacen los corchetes&lt;/a&gt; ). Incluso si no es nuevo en &amp;eacute;l, mantiene su c&amp;oacute;digo m&amp;aacute;s legible para que otros que tengan que leer su c&amp;oacute;digo puedan comprender m&amp;aacute;s f&amp;aacute;cilmente lo que est&amp;aacute; haciendo.</target>
        </trans-unit>
        <trans-unit id="8e3e016f8f3879b55e19d0fb4c4a1a15482a3faa" translate="yes" xml:space="preserve">
          <source>a b &lt;strong&gt;[&lt;/strong&gt; c d e f g h &lt;strong&gt;]&lt;/strong&gt; i j</source>
          <target state="translated">ab &lt;strong&gt;[&lt;/strong&gt; cdefgh &lt;strong&gt;]&lt;/strong&gt; ij</target>
        </trans-unit>
        <trans-unit id="a604aec6cdc49c95cd2d0c53292ad902a479d32d" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;stop&lt;/code&gt;, the lower bound:</source>
          <target state="translated">y &lt;code&gt;stop&lt;/code&gt; , el l&amp;iacute;mite inferior:</target>
        </trans-unit>
        <trans-unit id="631cab8239639a1208a15258a7f7aeda4d018888" translate="yes" xml:space="preserve">
          <source>and here is how it works:</source>
          <target state="translated">y así es como funciona:</target>
        </trans-unit>
        <trans-unit id="9ed5a643d410a394491f567e56e051b01be293d5" translate="yes" xml:space="preserve">
          <source>and now:</source>
          <target state="translated">y ahora:</target>
        </trans-unit>
        <trans-unit id="ce39fead1872adb72fba2b688bc7e4b8311fc7f4" translate="yes" xml:space="preserve">
          <source>and to substitute the defaults (actually when &lt;code&gt;step&lt;/code&gt; is negative, &lt;code&gt;stop&lt;/code&gt;'s default is &lt;code&gt;-len(my_list) - 1&lt;/code&gt;, so &lt;code&gt;None&lt;/code&gt; for stop really just means it goes to whichever end step takes it to):</source>
          <target state="translated">y para sustituir los valores predeterminados (en realidad, cuando el &lt;code&gt;step&lt;/code&gt; es negativo, el valor predeterminado de &lt;code&gt;-len(my_list) - 1&lt;/code&gt; es -len (my_list) - 1 , por lo que &lt;code&gt;None&lt;/code&gt; for stop realmente significa que va a cualquier paso final al que lo lleve):</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">es equivalente a:</target>
        </trans-unit>
        <trans-unit id="1110fd3a6c30458a698644d555d607d113a08279" translate="yes" xml:space="preserve">
          <source>returns &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">devuelve &lt;code&gt;True&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d9adbb8529fa7bf42a21e2483f8aa574d755b96e" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;l&lt;/code&gt; is a collection, &lt;code&gt;start&lt;/code&gt; is an inclusive index, &lt;code&gt;end&lt;/code&gt; is an exclusive index, and &lt;code&gt;step&lt;/code&gt; is a stride that can be used to take every &lt;em&gt;nth&lt;/em&gt; item in &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">donde &lt;code&gt;l&lt;/code&gt; es una colecci&amp;oacute;n, &lt;code&gt;start&lt;/code&gt; es un &amp;iacute;ndice inclusivo, &lt;code&gt;end&lt;/code&gt; es un &amp;iacute;ndice exclusivo y &lt;code&gt;step&lt;/code&gt; es un paso que puede usarse para tomar cada &lt;em&gt;en&amp;eacute;simo&lt;/em&gt; elemento en &lt;code&gt;l&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b8a81384b7443c9cbeaad37bd4704f2d8b3165a" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;l&lt;/code&gt; is some collection, &lt;code&gt;start&lt;/code&gt; is an inclusive index, and &lt;code&gt;end&lt;/code&gt; is an exclusive index.</source>
          <target state="translated">donde &lt;code&gt;l&lt;/code&gt; es una colecci&amp;oacute;n, &lt;code&gt;start&lt;/code&gt; es un &amp;iacute;ndice inclusivo y &lt;code&gt;end&lt;/code&gt; es un &amp;iacute;ndice exclusivo.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
