<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/208105">
    <body>
      <group id="208105">
        <trans-unit id="d0c785d16c2347fee547f3127b424f77909312a7" translate="yes" xml:space="preserve">
          <source>(Destructuring + Spread operator)</source>
          <target state="translated">(è§£æ„+ç‚¹å·®è¿ç®—å™¨)</target>
        </trans-unit>
        <trans-unit id="63d63c34165213cae85c0283076b58a13c886dbf" translate="yes" xml:space="preserve">
          <source>(ES6)</source>
          <target state="translated">(ES6)</target>
        </trans-unit>
        <trans-unit id="7d50cf7543cd430338fe6fd7172b5d7ec7565f89" translate="yes" xml:space="preserve">
          <source>* &lt;em&gt;&lt;code&gt;foo&lt;/code&gt; will be a new variable with the value of &lt;code&gt;a&lt;/code&gt; (which is 1).&lt;/em&gt;</source>
          <target state="translated">* &lt;em&gt; &lt;code&gt;foo&lt;/code&gt; å°†æ˜¯ä¸€ä¸ªæ–°å˜é‡ï¼Œå…¶å€¼ä¸º &lt;code&gt;a&lt;/code&gt; ï¼ˆä¸º1ï¼‰ã€‚&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8aa44c32c47930ef0f4bc07bf1b584a5b6b0e2f" translate="yes" xml:space="preserve">
          <source>...It's stupid, I know.</source>
          <target state="translated">...è¿™å¾ˆè ¢,æˆ‘çŸ¥é“ã€‚</target>
        </trans-unit>
        <trans-unit id="ff34d7bfb44f74504dbcecb1c791e02877f620e3" translate="yes" xml:space="preserve">
          <source>1.With explicit prop key:</source>
          <target state="translated">1ã€æœ‰æ˜ç¡®çš„é“å…·é”®ã€‚</target>
        </trans-unit>
        <trans-unit id="145f4a070da96e31a48d8d444babf929a09a782a" translate="yes" xml:space="preserve">
          <source>2.With variable prop key:</source>
          <target state="translated">2ã€å¸¦å¯å˜é“å…·é”®ã€‚</target>
        </trans-unit>
        <trans-unit id="75c350f4599bd395c8e57950299bcd4efdaca57e" translate="yes" xml:space="preserve">
          <source>3.Cool arrow function ğŸ˜:</source>
          <target state="translated">3.å†·ç®­åŠŸèƒ½ğŸ˜ã€‚</target>
        </trans-unit>
        <trans-unit id="b31d7d6cbd9fc3e49f4feaeef410e7cee592b5fa" translate="yes" xml:space="preserve">
          <source>4. For multiple properties</source>
          <target state="translated">4.å¯¹äºå¤šå±æ€§</target>
        </trans-unit>
        <trans-unit id="cecf2bde461c486918fed98467ea58414d0dd173" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;Object.freeze()&lt;/a&gt; makes all properties of object not configurable (besides other things). &lt;code&gt;deleteProperty&lt;/code&gt; function (as well as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;delete operator&lt;/a&gt;) returns &lt;code&gt;false&lt;/code&gt; when tries to delete any of it's properties. If property is configurable it returns &lt;code&gt;true&lt;/code&gt;, even if property does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;Object.freezeï¼ˆï¼‰&lt;/a&gt;ä½¿å¯¹è±¡çš„æ‰€æœ‰å±æ€§å‡ä¸å¯é…ç½®ï¼ˆé™¤å…¶ä»–å› ç´ å¤–ï¼‰ã€‚ å½“è¯•å›¾åˆ é™¤å…¶ä»»ä½•å±æ€§æ—¶ï¼Œ &lt;code&gt;deleteProperty&lt;/code&gt; å‡½æ•°ï¼ˆä»¥åŠ&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;deleteè¿ç®—ç¬¦&lt;/a&gt; ï¼‰å°†è¿”å› &lt;code&gt;false&lt;/code&gt; ã€‚ å¦‚æœpropertyæ˜¯å¯é…ç½®çš„ï¼Œåˆ™å³ä½¿propertyä¸å­˜åœ¨ï¼Œå®ƒä¹Ÿä¼šè¿”å› &lt;code&gt;true&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="d2f5341f96365af83c99b7c7d47dba6c4b1a96cb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;Spread Syntax&lt;/a&gt; (ES6)</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;ä¼ æ’­è¯­æ³•&lt;/a&gt; ï¼ˆES6ï¼‰</target>
        </trans-unit>
        <trans-unit id="e4d9e924d09e0b750a05547c2f0bf5fa2c195878" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.slice()&lt;/code&gt; is non-destructive and returns a new array containing the indicated indices from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;end&lt;/code&gt;. If &lt;code&gt;end&lt;/code&gt; is left unspecified, the behavior is the same as &lt;code&gt;.splice()&lt;/code&gt; (&lt;code&gt;end = array.length&lt;/code&gt;). The behavior is a bit tricky since, for some reason, &lt;code&gt;end&lt;/code&gt; indexes from 1 instead of 0. I don't know why it does this, but that's how it is. Also, if &lt;code&gt;end &amp;lt;= start&lt;/code&gt;, the result is an empty array.</source>
          <target state="translated">&lt;code&gt;.slice()&lt;/code&gt; æ˜¯éç ´åæ€§çš„ï¼Œ ä»å¤´åˆ°å°¾è¿”å›ä¸€ä¸ªåŒ…å«æŒ‡å®šç´¢å¼•çš„æ–°æ•°ç»„ã€‚ å¦‚æœæœªæŒ‡å®š &lt;code&gt;end&lt;/code&gt; ï¼Œåˆ™å…¶è¡Œä¸ºä¸ &lt;code&gt;.splice()&lt;/code&gt; ç›¸åŒï¼ˆ &lt;code&gt;end = array.length&lt;/code&gt; ï¼‰ã€‚ è¡Œä¸ºæœ‰ç‚¹æ£˜æ‰‹ï¼Œå› ä¸ºå‡ºäºæŸç§åŸå› ï¼Œ &lt;code&gt;end&lt;/code&gt; ç´¢å¼•ä»1è€Œä¸æ˜¯0å¼€å§‹ã€‚æˆ‘ä¸çŸ¥é“ä¸ºä»€ä¹ˆè¿™æ ·åšï¼Œä½†æ˜¯äº‹å®å°±æ˜¯å¦‚æ­¤ã€‚ å¦å¤–ï¼Œå¦‚æœ &lt;code&gt;end &amp;lt;= start&lt;/code&gt; ï¼Œåˆ™ç»“æœä¸ºç©ºæ•°ç»„ã€‚</target>
        </trans-unit>
        <trans-unit id="da2a0c1e98a822064cc6b913222774a91ac62044" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.splice()&lt;/code&gt; mutates the array, and returns the removed indices. The array is sliced starting from the index, &lt;code&gt;start&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; elements are sliced out. If n is unspecified, the entire array after &lt;code&gt;start&lt;/code&gt; is sliced out (&lt;code&gt;n = array.length - start&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;.splice()&lt;/code&gt; æ›´æ”¹æ•°ç»„ï¼Œå¹¶è¿”å›åˆ é™¤çš„ç´¢å¼•ã€‚ ä»ç´¢å¼•index &lt;code&gt;start&lt;/code&gt; ï¼Œå¯¹æ•°ç»„è¿›è¡Œåˆ‡ç‰‡ï¼Œå¯¹ &lt;code&gt;n&lt;/code&gt; ä¸ªå…ƒç´ è¿›è¡Œåˆ‡ç‰‡ã€‚ å¦‚æœæœªæŒ‡å®šnï¼Œåˆ™å°† &lt;code&gt;start&lt;/code&gt; ä¹‹åçš„æ•´ä¸ªæ•°ç»„åˆ‡å‡ºï¼ˆ &lt;code&gt;n = array.length - start&lt;/code&gt; ï¼‰ã€‚</target>
        </trans-unit>
        <trans-unit id="578e0d997316ced94b2f7c292e4269507a0730b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Delete Operator&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;åˆ é™¤è¿ç®—ç¬¦&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="10a7b7e3a95023fb9f5d4f97bbeb1e856756bc60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;EXTENDED ANSWER&lt;/em&gt;&lt;/strong&gt; ğŸ˜‡</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;æ‰©å±•ç­”æ¡ˆ&lt;/em&gt;&lt;/strong&gt; ğŸ˜‡</target>
        </trans-unit>
        <trans-unit id="3393b3743a22fd0193ab2fa39735ae2f646b06ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Or&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Or&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="710a4e957cc23ae95eb9aa6e13030731ab1c9d56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Reassignment&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Reassignment&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e590196d99e29b0fb26cc981e8c241732f76e4ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Spread Operator&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;ç‚¹å·®ç®—å­&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="64d050dff57dceee4d758cc0912b8d402b405b10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Usage&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Usage&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b02479449faf2e3a74dc8a9ef6000bfbe7ea1f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In other words, a JavaScript object gets killed as soon as there is no reference left in your code pointed to that object.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;æ¢å¥è¯è¯´ï¼Œåªè¦æ‚¨çš„ä»£ç ä¸­æ²¡æœ‰æŒ‡å‘è¯¥å¯¹è±¡çš„å¼•ç”¨ï¼ŒJavaScriptå¯¹è±¡å°±ä¼šè¢«æ€æ­»ã€‚&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ecc8000feff4d7f65f5786df06cc101796ac4edd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To clone object without property:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;è¦å…‹éš†æ²¡æœ‰å±æ€§çš„å¯¹è±¡ï¼š&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ca5c58827bf40e3a97a098228081f1f64d66b7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update 2018-07-21:&lt;/strong&gt; For a long time, I have felt embarrassed about this answer, so I think it's time that I touch it up a little bit. Just a little commentary, clarification, and formatting to help expedite the reading of the needlessly long and convoluted parts of this answer.</source>
          <target state="translated">&lt;strong&gt;2018å¹´7æœˆ21æ—¥æ›´æ–°ï¼š&lt;/strong&gt;å¾ˆé•¿ä¸€æ®µæ—¶é—´ä»¥æ¥ï¼Œæˆ‘å¯¹è¿™ä¸ªç­”æ¡ˆæ„Ÿåˆ°å¾ˆå°´å°¬ï¼Œæ‰€ä»¥æˆ‘è®¤ä¸ºç°åœ¨æ˜¯æˆ‘åº”è¯¥ç¨å¾®åŠ ä»¥è§£å†³çš„æ—¶å€™äº†ã€‚ åªéœ€ä¸€ç‚¹æ³¨é‡Šï¼Œæ¾„æ¸…å’Œæ ¼å¼åŒ–ï¼Œå³å¯å¸®åŠ©å¿«é€Ÿé˜…è¯»æ­¤ç­”æ¡ˆä¸­ä¸å¿…è¦çš„å†—é•¿å’Œå¤æ‚çš„éƒ¨åˆ†ã€‚</target>
        </trans-unit>
        <trans-unit id="c099f37767111dc60103bd8696ed4fcf3e7a64d4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;
Thanks to @AgentME:</source>
          <target state="translated">&lt;strong&gt;æ›´æ–°ï¼š&lt;/strong&gt;æ„Ÿè°¢@AgentMEï¼š</target>
        </trans-unit>
        <trans-unit id="cd7c415e1d4039a5febeafd32c836a75f6b919e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;delete&lt;/code&gt;,&lt;/strong&gt; when you are passing the result object to the code on which you don't have control (or when you are not sure about your team or yourself).</source>
          <target state="translated">å½“æ‚¨å°†ç»“æœå¯¹è±¡ä¼ é€’ç»™æ‚¨æ— æ³•æ§åˆ¶çš„ä»£ç æ—¶ï¼ˆæˆ–è€…ä¸ç¡®å®šæ‚¨çš„å›¢é˜Ÿæˆ–æ‚¨è‡ªå·±æ—¶ï¼‰ &lt;strong&gt;ï¼Œè¯·ä½¿ç”¨ &lt;code&gt;delete&lt;/code&gt; &lt;/strong&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="0af0c0606dbb967654f58c35fa2988459afb9a19" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use setting to &lt;code&gt;undefined&lt;/code&gt;,&lt;/strong&gt; when you care about performance. It can give a serious boost to your code.</source>
          <target state="translated">å½“æ‚¨å…³å¿ƒæ€§èƒ½æ—¶&lt;strong&gt;ï¼Œè¯·ä½¿ç”¨è®¾ç½®ä¸º &lt;code&gt;undefined&lt;/code&gt; &lt;/strong&gt; ã€‚ å®ƒå¯ä»¥å¤§å¤§æé«˜æ‚¨çš„ä»£ç ã€‚</target>
        </trans-unit>
        <trans-unit id="9dfe20a67d61ae6b75beddf80cff0434cb3f7a9f" translate="yes" xml:space="preserve">
          <source>A live example to show:</source>
          <target state="translated">ä¸€ä¸ªæ´»ç”Ÿç”Ÿç”Ÿçš„ä¾‹å­æ¥è¯´æ˜ã€‚</target>
        </trans-unit>
        <trans-unit id="aabd2b7839024463c3c18626551d6893b70879bd" translate="yes" xml:space="preserve">
          <source>About now, you're at your wit's end. This guy has been complaining non-stop about your app, and you want to tell him to shut up and go get a better computer.</source>
          <target state="translated">ç°åœ¨,ä½ å·²ç»æ— è®¡å¯æ–½äº†ã€‚è¿™å®¶ä¼™ä¸€ç›´åœ¨ä¸åœåœ°æŠ±æ€¨ä½ çš„åº”ç”¨ç¨‹åº,ä½ æƒ³è®©ä»–é—­å˜´,å»æ¢ä¸€å°æ›´å¥½çš„ç”µè„‘ã€‚</target>
        </trans-unit>
        <trans-unit id="692f82b2a7574a467099a421e634c28a19087f50" translate="yes" xml:space="preserve">
          <source>Alternatively, you could also do this:</source>
          <target state="translated">å¦å¤–,ä½ ä¹Ÿå¯ä»¥è¿™æ ·åšã€‚</target>
        </trans-unit>
        <trans-unit id="8dd6b6a5cb398077b2e61b33860df5233162a369" translate="yes" xml:space="preserve">
          <source>An object may be seen as a set of key-value pairs. What I call a 'value' is a primitive or a reference to other object, connected to that 'key'.</source>
          <target state="translated">ä¸€ä¸ªå¯¹è±¡å¯ä»¥è¢«çœ‹ä½œæ˜¯ä¸€ç»„é”®-å€¼å¯¹ã€‚æˆ‘æ‰€è¯´çš„ &quot;å€¼ &quot;æ˜¯ä¸€ä¸ªåŸºå…ƒæˆ–å¯¹å…¶ä»–å¯¹è±¡çš„å¼•ç”¨,è¿æ¥åˆ°è¿™ä¸ª &quot;é”®&quot;ã€‚</target>
        </trans-unit>
        <trans-unit id="97f362e729192c077ada3f5241fec0dea0e6f9ad" translate="yes" xml:space="preserve">
          <source>And just like that, you've pleased Mr. PDP-11. Hooray! &lt;sub&gt;(I'd still tell him off, though...)&lt;/sub&gt;</source>
          <target state="translated">å°±åƒé‚£æ ·ï¼Œæ‚¨ä½¿PDP-11å…ˆç”Ÿæ„Ÿåˆ°é«˜å…´ã€‚ ä¸‡å²ï¼ &lt;sub&gt;ï¼ˆä¸è¿‡ï¼Œæˆ‘è¿˜æ˜¯å‘Šè¯‰ä»–...ï¼‰&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="38fedc2f5a59cd30ac658c92ac34226c9870e485" translate="yes" xml:space="preserve">
          <source>And we need to delete 'a'.</source>
          <target state="translated">è€Œæˆ‘ä»¬éœ€è¦åˆ é™¤ &quot;A&quot;ã€‚</target>
        </trans-unit>
        <trans-unit id="15728408349a51726fa4d7a495f586b8e25e36f1" translate="yes" xml:space="preserve">
          <source>Another alternative is to use the &lt;a href=&quot;https://underscorejs.org&quot;&gt;Underscore.js&lt;/a&gt; library.</source>
          <target state="translated">å¦ä¸€ç§é€‰æ‹©æ˜¯ä½¿ç”¨&lt;a href=&quot;https://underscorejs.org&quot;&gt;Underscore.js&lt;/a&gt;åº“ã€‚</target>
        </trans-unit>
        <trans-unit id="130c3bce337f7ed92461a0af093bf0dd8b4d970c" translate="yes" xml:space="preserve">
          <source>Another solution, using &lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;&lt;code&gt;Array#reduce&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">å¦ä¸€ç§è§£å†³æ–¹æ¡ˆï¼Œä½¿ç”¨&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt; &lt;code&gt;Array#reduce&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="75aa366398b31b18c07d678c84ff7223a1b76dbe" translate="yes" xml:space="preserve">
          <source>Any property declared with let or const cannot be deleted from the scope  within which they were defined. Non-configurable properties cannot be removed. This includes properties of built-in objects like Math, Array, Object and properties that are created as non-configurable with methods like Object.defineProperty().</source>
          <target state="translated">ä»»ä½•ç”¨letæˆ–constå£°æ˜çš„å±æ€§éƒ½ä¸èƒ½ä»å®šä¹‰å®ƒä»¬çš„èŒƒå›´ä¸­åˆ é™¤ã€‚ä¸å¯é…ç½®çš„å±æ€§ä¸èƒ½è¢«åˆ é™¤ã€‚è¿™åŒ…æ‹¬å†…ç½®å¯¹è±¡(å¦‚Mathã€Arrayã€Object)çš„å±æ€§,ä»¥åŠä½¿ç”¨Object.defineProperty()ç­‰æ–¹æ³•åˆ›å»ºçš„ä¸å¯é…ç½®å±æ€§ã€‚</target>
        </trans-unit>
        <trans-unit id="b2ecb35283325b0622c879acc81ba757d7accad0" translate="yes" xml:space="preserve">
          <source>Any property declared with var cannot be deleted from the global scope
  or from a function's scope.</source>
          <target state="translated">ä»»ä½•ç”¨varå£°æ˜çš„å±æ€§éƒ½ä¸èƒ½ä»å…¨å±€ä½œç”¨åŸŸæˆ–å‡½æ•°çš„ä½œç”¨åŸŸä¸­åˆ é™¤ã€‚</target>
        </trans-unit>
        <trans-unit id="6c333dd9449a548b822691fcab373abce8f8f850" translate="yes" xml:space="preserve">
          <source>Are you looking to achieve this in pure JavaScript or are you willing &amp;amp; able to use a 3rd-party library?</source>
          <target state="translated">æ‚¨æ˜¯è¦ä½¿ç”¨çº¯JavaScriptå®ç°è¿™ä¸€ç›®æ ‡ï¼Œè¿˜æ˜¯æ„¿æ„å¹¶èƒ½å¤Ÿä½¿ç”¨ç¬¬ä¸‰æ–¹åº“ï¼Ÿ</target>
        </trans-unit>
        <trans-unit id="1fea0155471c15e540c5b31c3594a45754e6cc6c" translate="yes" xml:space="preserve">
          <source>Array equivalent</source>
          <target state="translated">é˜µåˆ—ç­‰ä»·ç‰©</target>
        </trans-unit>
        <trans-unit id="10f82eff0fb408011ffeabc374c6234764312dea" translate="yes" xml:space="preserve">
          <source>Array.prototype.slice(start, end)</source>
          <target state="translated">Array.prototype.slice(start,end)</target>
        </trans-unit>
        <trans-unit id="dfe829210c0c25d8779de7fe65fb3158cefd4290" translate="yes" xml:space="preserve">
          <source>Array.prototype.splice vs Array.prototype.slice</source>
          <target state="translated">Array.prototype.splice vs Array.prototype.slice</target>
        </trans-unit>
        <trans-unit id="99ba4898ce91c3e3945c33ecd292283940427b38" translate="yes" xml:space="preserve">
          <source>Array.prototype.splice(start, n)</source>
          <target state="translated">Array.prototype.splice(start,n)</target>
        </trans-unit>
        <trans-unit id="bc85e8ead32cd6185d2f6ca2b34c7fbc94aadd58" translate="yes" xml:space="preserve">
          <source>As others have said, you can use &lt;code&gt;delete&lt;/code&gt;.</source>
          <target state="translated">æ­£å¦‚å…¶ä»–äººæ‰€è¯´ï¼Œå¯ä»¥ä½¿ç”¨ &lt;code&gt;delete&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="fc6de88f57fe2bcbd39aa2ddf8ca667c26f222a3" translate="yes" xml:space="preserve">
          <source>As seen in the above code snippet, there are some rare appropriate use cases for the &lt;code&gt;delete&lt;/code&gt; operator. However, do not worry about this problem too much. This will only become a problem with long-lifespan objects that get new keys constantly added to them. In any other case (which is almost every case in real-world programming), it is most appropriate to use &lt;code&gt;obj[prop] = undefined&lt;/code&gt;. The main purpose of this section is just to bring this to your attention so that in the rare chance that this does become a problem in your code, then you can more easily understand the problem and thus not have to waste hours dissecting your code to locate and understand this problem.</source>
          <target state="translated">å¦‚ä¸Šé¢çš„ä»£ç ç‰‡æ®µæ‰€ç¤ºï¼Œå¯¹äº &lt;code&gt;delete&lt;/code&gt; è¿ç®—ç¬¦ï¼Œæœ‰ä¸€äº›ç½•è§çš„é€‚å½“ç”¨ä¾‹ã€‚ ä½†æ˜¯ï¼Œä¸å¿…è¿‡å¤šæ‹…å¿ƒæ­¤é—®é¢˜ã€‚ è¿™å°†æˆä¸ºå…·æœ‰é•¿å¯¿å‘½å¯¹è±¡çš„é—®é¢˜ï¼Œè¿™äº›å¯¹è±¡ä¼šä¸æ–­å‘å…¶æ·»åŠ æ–°å¯†é’¥ã€‚ åœ¨ä»»ä½•å…¶ä»–æƒ…å†µä¸‹ï¼ˆåœ¨ç°å®ä¸–ç•Œç¼–ç¨‹ä¸­å‡ ä¹æ˜¯æ‰€æœ‰æƒ…å†µï¼‰ï¼Œæœ€é€‚åˆä½¿ç”¨ &lt;code&gt;obj[prop] = undefined&lt;/code&gt; ã€‚ æœ¬éƒ¨åˆ†çš„ä¸»è¦ç›®çš„åªæ˜¯å¼•èµ·æ‚¨çš„æ³¨æ„ï¼Œä»¥ä¾¿åœ¨æå°‘æ•°æƒ…å†µä¸‹ç¡®å®åœ¨ä»£ç ä¸­æˆä¸ºé—®é¢˜ï¼Œç„¶åæ‚¨å¯ä»¥æ›´è½»æ¾åœ°ç†è§£é—®é¢˜ï¼Œå› æ­¤ä¸å¿…æµªè´¹æ—¶é—´å‰–æä»£ç æ¥æŸ¥æ‰¾å¹¶äº†è§£è¿™ä¸ªé—®é¢˜ã€‚</target>
        </trans-unit>
        <trans-unit id="0a1a7281b5e3e0adcbcee6c0378231475ce1d077" translate="yes" xml:space="preserve">
          <source>As such, delete cannot delete any functions in the global scope (whether this is part from a function definition or a function  (expression).</source>
          <target state="translated">å› æ­¤,deleteä¸èƒ½åˆ é™¤å…¨å±€èŒƒå›´å†…çš„ä»»ä½•å‡½æ•°(ä¸ç®¡æ˜¯æ¥è‡ªå‡½æ•°å®šä¹‰çš„ä¸€éƒ¨åˆ†è¿˜æ˜¯å‡½æ•°(è¡¨è¾¾å¼)ã€‚</target>
        </trans-unit>
        <trans-unit id="19292906404cfee69ce728ffea847a3cb5d23580" translate="yes" xml:space="preserve">
          <source>As you can see, &lt;code&gt;delete&lt;/code&gt; doesn't always work as one might expect. The value is overwritten, but the memory is not reallocated. That is to say, &lt;code&gt;array[4]&lt;/code&gt; isn't relocated to &lt;code&gt;array[3]&lt;/code&gt;. Which is in contrast to &lt;code&gt;Array.prototype.unshift&lt;/code&gt;, which inserts an element at the beginning of the array and shifts everything up (&lt;code&gt;array[0]&lt;/code&gt; becomes &lt;code&gt;array[1]&lt;/code&gt;, etc.)</source>
          <target state="translated">å¦‚æ‚¨æ‰€è§ï¼Œ &lt;code&gt;delete&lt;/code&gt; å¹¶éæ€»æ˜¯å¯ä»¥åƒé¢„æœŸçš„é‚£æ ·è¿›è¡Œã€‚ è¯¥å€¼å°†è¢«è¦†ç›–ï¼Œä½†ä¸ä¼šé‡æ–°åˆ†é…å†…å­˜ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œ &lt;code&gt;array[4]&lt;/code&gt; ä¸ä¼šé‡å®šä½åˆ° &lt;code&gt;array[3]&lt;/code&gt; ã€‚ ä¸ &lt;code&gt;Array.prototype.unshift&lt;/code&gt; ç›¸åï¼Œåè€…åœ¨æ•°ç»„çš„å¼€å¤´æ’å…¥ä¸€ä¸ªå…ƒç´ å¹¶å°†æ‰€æœ‰å†…å®¹å‘ä¸Šç§»åŠ¨ï¼ˆ &lt;code&gt;array[0]&lt;/code&gt; å˜ä¸º &lt;code&gt;array[1]&lt;/code&gt; ç­‰ï¼‰ã€‚</target>
        </trans-unit>
        <trans-unit id="2c856c5e5c5be4265462b9644119ace1784d98d0" translate="yes" xml:space="preserve">
          <source>Beware Of Memory Leaks!</source>
          <target state="translated">å°å¿ƒè®°å¿†æ³„æ¼!</target>
        </trans-unit>
        <trans-unit id="76829795257d4b98172b51f389192e4a9f633cf6" translate="yes" xml:space="preserve">
          <source>But if the property of the object is not configurable it cannot be deleted neither with deleteProperty function nor delete operator:</source>
          <target state="translated">ä½†æ˜¯,å¦‚æœå¯¹è±¡çš„å±æ€§æ˜¯ä¸å¯é…ç½®çš„,é‚£ä¹ˆæ— è®ºæ˜¯DeletePropertyå‡½æ•°è¿˜æ˜¯Deleteoperatoréƒ½æ— æ³•åˆ é™¤ã€‚</target>
        </trans-unit>
        <trans-unit id="5d2ae2c0c3d231052d20df4bc0d378c5068295e8" translate="yes" xml:space="preserve">
          <source>But the point is if you care about memory and you want to whole the object gets removed from the memory, it is recommended to set it to null before you delete the key:</source>
          <target state="translated">ä½†é—®é¢˜æ˜¯,å¦‚æœä½ å…³å¿ƒå†…å­˜,æƒ³æŠŠå¯¹è±¡ä»å†…å­˜ä¸­æ•´ä½“åˆ é™¤,å»ºè®®å°†å…¶è®¾ç½®ä¸ºç©º,ç„¶åå†åˆ é™¤å¯†é’¥ã€‚</target>
        </trans-unit>
        <trans-unit id="083882684bcd539a61f754c832b4192934d833e3" translate="yes" xml:space="preserve">
          <source>But, how does a drug trip analogy relate to the &lt;code&gt;delete&lt;/code&gt; operation? The answer inheres the last line of code in the snippet above. Thus let it be reexamined, this time with a twist.</source>
          <target state="translated">ä½†æ˜¯ï¼Œæ¯’å“æ—…è¡Œç±»æ¨ä¸ &lt;code&gt;delete&lt;/code&gt; æ“ä½œæœ‰ä½•å…³ç³»ï¼Ÿ ç­”æ¡ˆä½äºä¸Šé¢ä»£ç æ®µçš„æœ€åä¸€è¡Œä»£ç ä¸­ã€‚ å› æ­¤ï¼Œè¿™ä¸€æ¬¡è¦é‡æ–°æ£€æŸ¥ä¸€ä¸‹ã€‚</target>
        </trans-unit>
        <trans-unit id="0eb16d4b50dbacc8475f57ed2dfb88409bd56da6" translate="yes" xml:space="preserve">
          <source>Consider creating a new object without the &lt;code&gt;&quot;regex&quot;&lt;/code&gt; property because the original object could always be referenced by other parts of your program. Thus you should avoid manipulating it.</source>
          <target state="translated">è€ƒè™‘åˆ›å»ºæ²¡æœ‰ &lt;code&gt;&quot;regex&quot;&lt;/code&gt; å±æ€§çš„æ–°å¯¹è±¡ï¼Œå› ä¸ºåŸå§‹å¯¹è±¡å§‹ç»ˆå¯ä»¥è¢«ç¨‹åºçš„å…¶ä»–éƒ¨åˆ†å¼•ç”¨ã€‚ å› æ­¤ï¼Œæ‚¨åº”è¯¥é¿å…å¯¹å…¶è¿›è¡Œæ“ä½œã€‚</target>
        </trans-unit>
        <trans-unit id="1b8bae88ce3f716fc88f086ba5df71aa742b0ee5" translate="yes" xml:space="preserve">
          <source>Dan's assertion that 'delete' is very slow and the benchmark he posted were doubted. So I carried out the test myself in Chrome 59. It does seem that 'delete' is about 30 times slower:</source>
          <target state="translated">Danè¯´'åˆ é™¤'é€Ÿåº¦å¾ˆæ…¢,ä»–è´´å‡ºçš„æ ‡æ†ä¹Ÿå—åˆ°äº†æ€€ç–‘ã€‚äºæ˜¯æˆ‘è‡ªå·±åœ¨Chrome 59ä¸­è¿›è¡Œäº†æµ‹è¯•ã€‚çœ‹æ¥'åˆ é™¤'ç¡®å®æ…¢äº†30å€å·¦å³ã€‚</target>
        </trans-unit>
        <trans-unit id="d8b13a816456ec85d6f3ace2de0c50288edaa6ea" translate="yes" xml:space="preserve">
          <source>Delete is the only true way to remove object's properties without any leftovers, but it works &lt;strong&gt;~ 100 times slower&lt;/strong&gt;, 
compared to its &quot;alternative&quot;, setting &lt;code&gt;object[key] = undefined&lt;/code&gt;.</source>
          <target state="translated">åˆ é™¤æ˜¯åˆ é™¤å¯¹è±¡å±æ€§è€Œæ²¡æœ‰ä»»ä½•å‰©ä½™ç‰©çš„å”¯ä¸€æ­£ç¡®æ–¹æ³•ï¼Œä½†ä¸&amp;ldquo;æ›¿ä»£&amp;rdquo;è®¾ç½® &lt;code&gt;object[key] = undefined&lt;/code&gt; ç›¸æ¯”ï¼Œå®ƒçš„å·¥ä½œ&lt;strong&gt;é€Ÿåº¦è¦æ…¢å¤§çº¦100å€&lt;/strong&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="45dc7ea9ea6f9f47fa401db4115a5eee26a4be14" translate="yes" xml:space="preserve">
          <source>Deleting an array index</source>
          <target state="translated">åˆ é™¤ä¸€ä¸ªæ•°ç»„ç´¢å¼•</target>
        </trans-unit>
        <trans-unit id="42034d05fb5ec8b92965ea89f328c840dc4a3ac4" translate="yes" xml:space="preserve">
          <source>Deleting an object property</source>
          <target state="translated">åˆ é™¤ä¸€ä¸ªå¯¹è±¡å±æ€§</target>
        </trans-unit>
        <trans-unit id="e52c854d5631eec7468ba4727b4c77eb745f2965" translate="yes" xml:space="preserve">
          <source>Demo</source>
          <target state="translated">Demo</target>
        </trans-unit>
        <trans-unit id="0298196b206bc7b4a96725653dbc77fafc2e7815" translate="yes" xml:space="preserve">
          <source>Do Not Always Set To &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">å¹¶ä¸æ€»æ˜¯è®¾ç½®ä¸º &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e813a63a91f53696f818ac595a5fddc09cb30338" translate="yes" xml:space="preserve">
          <source>Don't &lt;code&gt;delete&lt;/code&gt; from an array. Use &lt;code&gt;Array.prototype.splice&lt;/code&gt; instead.</source>
          <target state="translated">ä¸è¦ä»æ•°ç»„ä¸­ &lt;code&gt;delete&lt;/code&gt; ã€‚ è¯·æ”¹ç”¨ &lt;code&gt;Array.prototype.splice&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="9cff8f35d333fc23fef816a20f879c35c001ee7e" translate="yes" xml:space="preserve">
          <source>Due to the dynamic nature of JavaScript there are often cases where you simply don't know if the property exists or not. Checking if obj exists before the &amp;amp;&amp;amp; also makes sure you don't throw an error due to calling the hasOwnProperty() function on an undefined object.</source>
          <target state="translated">ç”±äºJavaScriptçš„åŠ¨æ€ç‰¹æ€§ï¼Œé€šå¸¸åœ¨æŸäº›æƒ…å†µä¸‹æ‚¨æ ¹æœ¬ä¸çŸ¥é“è¯¥å±æ€§æ˜¯å¦å­˜åœ¨ã€‚ æ£€æŸ¥objåœ¨&amp;amp;&amp;amp;ä¹‹å‰æ˜¯å¦å­˜åœ¨ï¼Œè¿˜å¯ä»¥ç¡®ä¿æ‚¨ä¸ä¼šç”±äºæœªå®šä¹‰å¯¹è±¡ä¸Šè°ƒç”¨hasOwnPropertyï¼ˆï¼‰å‡½æ•°è€Œå¼•å‘é”™è¯¯ã€‚</target>
        </trans-unit>
        <trans-unit id="f30ca853155d96f4ff4a7523ad41da4989438529" translate="yes" xml:space="preserve">
          <source>E.g</source>
          <target state="translated">E.g</target>
        </trans-unit>
        <trans-unit id="48886c6e98adf5c4a9c9282a2441dfe3015faacb" translate="yes" xml:space="preserve">
          <source>ECMAScript 2015 (or ES6) came with built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect&quot;&gt;Reflect&lt;/a&gt; object. It is possible to delete object property by calling &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty&quot;&gt;Reflect.deleteProperty()&lt;/a&gt; function with target object and property key as parameters:</source>
          <target state="translated">ECMAScript 2015ï¼ˆæˆ–ES6ï¼‰å¸¦æœ‰å†…ç½®çš„&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect&quot;&gt;Reflect&lt;/a&gt;å¯¹è±¡ã€‚ å¯ä»¥é€šè¿‡ä½¿ç”¨ç›®æ ‡å¯¹è±¡å’Œå±æ€§é”®ä½œä¸ºå‚æ•°è°ƒç”¨&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty&quot;&gt;Reflect.deletePropertyï¼ˆï¼‰&lt;/a&gt;å‡½æ•°æ¥åˆ é™¤å¯¹è±¡å±æ€§ï¼š</target>
        </trans-unit>
        <trans-unit id="4c2dbb36a3a214bec101207bfb72cd18b86e453e" translate="yes" xml:space="preserve">
          <source>Each one has it's own pros and cons (&lt;a href=&quot;https://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;check this performance comparison&lt;/a&gt;):</source>
          <target state="translated">æ¯ä¸ªäººéƒ½æœ‰è‡ªå·±çš„ä¼˜ç¼ºç‚¹ï¼ˆ &lt;a href=&quot;https://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;è¯·æ£€æŸ¥æ­¤æ€§èƒ½æ¯”è¾ƒ&lt;/a&gt; ï¼‰ï¼š</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">æ‰©å±•ç‰‡æ®µ</target>
        </trans-unit>
        <trans-unit id="5cb7b7c35055238b90a33971ff368cff01dd0bbb" translate="yes" xml:space="preserve">
          <source>For anyone interested in reading more about it, Stack Overflow user &lt;a href=&quot;https://stackoverflow.com/users/130652/kangax&quot;&gt;kangax&lt;/a&gt; has written an incredibly in-depth blog post about the &lt;code&gt;delete&lt;/code&gt; statement on their blog, &lt;em&gt;&lt;a href=&quot;http://perfectionkills.com/understanding-delete/&quot;&gt;Understanding delete&lt;/a&gt;&lt;/em&gt;. It is highly recommended.</source>
          <target state="translated">å¯¹äºä»»ä½•æœ‰å…´è¶£é˜…è¯»æ›´å¤šå†…å®¹çš„äººï¼ŒStack Overflowç”¨æˆ·&lt;a href=&quot;https://stackoverflow.com/users/130652/kangax&quot;&gt;kangax&lt;/a&gt;éƒ½å†™äº†ä¸€ç¯‡éå¸¸æ·±å…¥çš„åšå®¢æ–‡ç« ï¼Œå…³äºå…¶åšå®¢ä¸Šçš„ &lt;code&gt;delete&lt;/code&gt; è¯­å¥ï¼Œ&amp;ldquo; &lt;em&gt;&lt;a href=&quot;http://perfectionkills.com/understanding-delete/&quot;&gt;äº†è§£åˆ é™¤&amp;rdquo;&lt;/a&gt;&lt;/em&gt; ã€‚ å¼ºçƒˆå»ºè®®ã€‚</target>
        </trans-unit>
        <trans-unit id="7de0c8678ad3582ef48a786c2a12849c95f613d2" translate="yes" xml:space="preserve">
          <source>For arrays, &lt;code&gt;_.filter()&lt;/code&gt; and &lt;code&gt;_.reject()&lt;/code&gt; can be used in a similar manner.</source>
          <target state="translated">å¯¹äºæ•°ç»„ï¼Œå¯ä»¥ç±»ä¼¼çš„æ–¹å¼ä½¿ç”¨ &lt;code&gt;_.filter()&lt;/code&gt; å’Œ &lt;code&gt;_.reject()&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="ae20664549d9e3ccd77991be79f76a86f10d159f" translate="yes" xml:space="preserve">
          <source>For example, say you are creating a webapp that uses JSON-serialization to store an array used for 'tabs' in a string (in this case, &lt;code&gt;localStorage&lt;/code&gt;). Let's also say that the code uses the numerical indices of the array's members to &quot;title&quot; them when drawing to the screen. Why are you doing this rather than just storing the &quot;title&quot; as well? Because... &lt;em&gt;reasons&lt;/em&gt;.</source>
          <target state="translated">ä¾‹å¦‚ï¼Œå‡è®¾æ‚¨æ­£åœ¨åˆ›å»ºä¸€ä¸ªä½¿ç”¨JSONåºåˆ—åŒ–çš„Webåº”ç”¨ç¨‹åºï¼Œä»¥å°†ç”¨äº&amp;ldquo;é€‰é¡¹å¡&amp;rdquo;çš„æ•°ç»„å­˜å‚¨åœ¨å­—ç¬¦ä¸²ä¸­ï¼ˆæœ¬ä¾‹ä¸­ä¸º &lt;code&gt;localStorage&lt;/code&gt; ï¼‰ã€‚ æˆ‘ä»¬è¿˜è¯´ï¼Œä»£ç åœ¨ç»˜åˆ¶åˆ°å±å¹•æ—¶ä½¿ç”¨æ•°ç»„æˆå‘˜çš„æ•°å­—ç´¢å¼•ä¸ºå®ƒä»¬&amp;ldquo;æ·»åŠ æ ‡é¢˜&amp;rdquo;ã€‚ æ‚¨ä¸ºä»€ä¹ˆè¦è¿™æ ·åšï¼Œè€Œä¸ä»…ä»…æ˜¯å­˜å‚¨&amp;ldquo;æ ‡é¢˜&amp;rdquo;ï¼Ÿ å› ä¸º... &lt;em&gt;åŸå› &lt;/em&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">ä¾‹å¦‚:</target>
        </trans-unit>
        <trans-unit id="cdad74d0486512dc3bc4f850907cd467e5fc5e3c" translate="yes" xml:space="preserve">
          <source>For more info about and seeing more example, visit the link below:</source>
          <target state="translated">æ¬²äº†è§£æ›´å¤šä¿¡æ¯å’ŒæŸ¥çœ‹æ›´å¤šç¤ºä¾‹,è¯·è®¿é—®ä¸‹é¢çš„é“¾æ¥ã€‚</target>
        </trans-unit>
        <trans-unit id="3053a4eaab6ecc9daa630f23887af0a663b64dcc" translate="yes" xml:space="preserve">
          <source>Functions which are part of an object (apart from the</source>
          <target state="translated">ä½œä¸ºå¯¹è±¡çš„ä¸€éƒ¨åˆ†çš„å‡½æ•°(é™¤äº†</target>
        </trans-unit>
        <trans-unit id="a355b0b1f78d396cf69cf859538e8172e1e8345c" translate="yes" xml:space="preserve">
          <source>Hello You Can try this simple an sort</source>
          <target state="translated">ä½ å¥½,ä½ å¯ä»¥è¯•è¯•è¿™ä¸ªç®€å•çš„æ’åº</target>
        </trans-unit>
        <trans-unit id="ca27c0a83d24961b91d263af64d922d82a55909c" translate="yes" xml:space="preserve">
          <source>Honestly, aside from setting to &lt;code&gt;null&lt;/code&gt; rather than &lt;code&gt;undefined&lt;/code&gt;--which is legitimately weird--this behavior &lt;em&gt;shouldn't&lt;/em&gt; be surprising, since &lt;code&gt;delete&lt;/code&gt; is a unary operator, like &lt;code&gt;typeof&lt;/code&gt;, that is hard-boiled into the language and is not supposed to care about the &lt;em&gt;type&lt;/em&gt; of object it's being used on, whereas &lt;code&gt;Array&lt;/code&gt; is a subclass of &lt;code&gt;Object&lt;/code&gt; with methods &lt;em&gt;specifically designed for&lt;/em&gt; working with arrays. So there's no good reason for &lt;code&gt;delete&lt;/code&gt; to have a special case cooked in for re-shifting the array, as that would just slow things down with unnecessary work. In retrospect, my expectations were unrealistic.</source>
          <target state="translated">å¦ç™½åœ°è¯´ï¼Œé™¤äº†è®¾ç½®ä¸º &lt;code&gt;null&lt;/code&gt; è€Œä¸æ˜¯ &lt;code&gt;undefined&lt;/code&gt; ï¼ˆè¿™ç¡®å®å¾ˆå¥‡æ€ªï¼‰ä¹‹å¤–ï¼Œè¿™ç§è¡Œä¸ºä¹Ÿå°±ä¸è¶³ä¸ºå¥‡äº†ï¼Œå› ä¸º &lt;code&gt;delete&lt;/code&gt; æ˜¯ä¸€å…ƒè¿ç®—ç¬¦ï¼Œä¾‹å¦‚ &lt;code&gt;typeof&lt;/code&gt; ï¼Œå®ƒè¢«ç¡¬åŒ–åˆ°è¯­è¨€ä¸­å¹¶ä¸”ä¸åº”è¯¥åœ¨æ„å…³äºå®ƒæ‰€ä½¿ç”¨çš„å¯¹è±¡çš„&lt;em&gt;ç±»å‹&lt;/em&gt; ï¼Œè€Œ &lt;code&gt;Array&lt;/code&gt; æ˜¯ &lt;code&gt;Object&lt;/code&gt; çš„å­ç±»ï¼Œå…¶å¯¹è±¡ &lt;em&gt;ä¸“é—¨ç”¨äº&lt;/em&gt;å¤„ç†æ•°ç»„ã€‚ å› æ­¤ï¼Œæ²¡æœ‰å……åˆ†çš„ç†ç”± &lt;code&gt;delete&lt;/code&gt; æ¥å‡†å¤‡ç‰¹æ®Šæƒ…å†µä»¥é‡æ–°ç§»åŠ¨é˜µåˆ—ï¼Œå› ä¸ºé‚£æ ·åªä¼šå› ä¸å¿…è¦çš„å·¥ä½œè€Œå‡æ…¢é€Ÿåº¦ã€‚ å›æƒ³èµ·æ¥ï¼Œæˆ‘çš„æœŸæœ›æ˜¯ä¸ç°å®çš„ã€‚</target>
        </trans-unit>
        <trans-unit id="dc3989e98834042a9457a0de8b90b5c9f3024f13" translate="yes" xml:space="preserve">
          <source>How do I remove a property from a JavaScript object</source>
          <target state="translated">å¦‚ä½•ä»JavaScriptå¯¹è±¡ä¸­åˆ é™¤ä¸€ä¸ªå±æ€§?</target>
        </trans-unit>
        <trans-unit id="b47475af69db5ae110b477abd31ec35a3c7d497a" translate="yes" xml:space="preserve">
          <source>However, be mindful! Do not suddenly start doing this with all your preexisting code now as it would likely break such preexisting code and/or introduce strange bugs. Rather, such an efficient practice needs to be implemented from the start, and when converting preexisting code, it is recommended that you double, triple, quadruple check all the lines relating to that as trying to upgrade old code to this new practice can be as risky as it is rewarding.</source>
          <target state="translated">ä½†æ˜¯,è¦æ³¨æ„!ä¸è¦çªç„¶å¼€å§‹å¯¹æ‰€æœ‰å·²ç»å­˜åœ¨çš„ä»£ç è¿›è¡Œè¿™æ ·çš„æ“ä½œã€‚ä¸è¦çªç„¶å¼€å§‹å¯¹ä½ æ‰€æœ‰çš„é¢„å­˜ä»£ç è¿›è¡Œè¿™æ ·çš„æ“ä½œ,å› ä¸ºè¿™æ ·åšå¾ˆå¯èƒ½ä¼šç ´åè¿™æ ·çš„é¢„å­˜ä»£ç ,æˆ–è€…å¼•å…¥å¥‡æ€ªçš„bugã€‚ç›¸å,è¿™ç§æœ‰æ•ˆçš„åšæ³•éœ€è¦ä»ä¸€å¼€å§‹å°±å¼€å§‹å®æ–½,åœ¨è½¬æ¢ä¹‹å‰å·²ç»å­˜åœ¨çš„ä»£ç æ—¶,å»ºè®®ä½ å¯¹æ‰€æœ‰ä¸ä¹‹ç›¸å…³çš„è¡Œè¿›è¡Œä¸¤éã€ä¸‰éã€å››éçš„æ£€æŸ¥,å› ä¸ºè¯•å›¾å°†æ—§çš„ä»£ç å‡çº§åˆ°è¿™ä¸ªæ–°çš„åšæ³•å¯èƒ½ä¼šæœ‰å¾ˆå¤§çš„é£é™©,ä¹Ÿä¼šæœ‰å¾ˆå¤§çš„æ”¶è·ã€‚</target>
        </trans-unit>
        <trans-unit id="491f0bae14ec381e286ea282ba5b10bae8f240b9" translate="yes" xml:space="preserve">
          <source>However, it will &lt;strong&gt;mutate&lt;/strong&gt; the original object. If you want to create a new object &lt;strong&gt;without&lt;/strong&gt; the specified key, just assign the reduce function to a new variable, e.g.:</source>
          <target state="translated">ä½†æ˜¯ï¼Œå®ƒå°†&lt;strong&gt;å˜å¼‚&lt;/strong&gt;åŸå§‹å¯¹è±¡ã€‚ å¦‚æœè¦åˆ›å»º&lt;strong&gt;æ²¡æœ‰&lt;/strong&gt;æŒ‡å®šé”®çš„æ–°å¯¹è±¡ï¼Œåªéœ€å°†reduceå‡½æ•°åˆ†é…ç»™æ–°å˜é‡ï¼Œä¾‹å¦‚ï¼š</target>
        </trans-unit>
        <trans-unit id="b18c3a88c501a6c91766f406a1e129e6aaa98cea" translate="yes" xml:space="preserve">
          <source>However, there are two major unfixable problems with polymorphic arrays:</source>
          <target state="translated">ç„¶è€Œ,å¤šæ€æ•°ç»„æœ‰ä¸¤å¤§æ— æ³•è§£å†³çš„é—®é¢˜ã€‚</target>
        </trans-unit>
        <trans-unit id="3486394d0c7c983de3c5268328e537d9b15cb8f7" translate="yes" xml:space="preserve">
          <source>However, this code:</source>
          <target state="translated">ç„¶è€Œ,è¿™ä¸ªä»£ç ã€‚</target>
        </trans-unit>
        <trans-unit id="4a71f7845929b0f0df07acdfaf7d379b182e9259" translate="yes" xml:space="preserve">
          <source>I feel it's important to point out the difference between these two similarly-named functions, as they are both very useful.</source>
          <target state="translated">æˆ‘è§‰å¾—æœ‰å¿…è¦æŒ‡å‡ºè¿™ä¸¤ä¸ªåŒååŠŸèƒ½çš„åŒºåˆ«,å› ä¸ºè¿™ä¸¤ä¸ªåŒååŠŸèƒ½éƒ½å¾ˆæœ‰ç”¨ã€‚</target>
        </trans-unit>
        <trans-unit id="459a68f17b246b077cb24b6614e54636e1f0783c" translate="yes" xml:space="preserve">
          <source>I personally use &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; or &lt;a href=&quot;https://lodash.com&quot;&gt;Lodash&lt;/a&gt; for object and array manipulation:</source>
          <target state="translated">æˆ‘ä¸ªäººä½¿ç”¨&lt;a href=&quot;https://lodash.com&quot;&gt;Underscore.js&lt;/a&gt;æˆ–Lodashè¿›è¡Œå¯¹è±¡å’Œæ•°ç»„æ“ä½œï¼š</target>
        </trans-unit>
        <trans-unit id="a8613a5b1880d971e632b3352e4bfe554f971c46" translate="yes" xml:space="preserve">
          <source>If a property with the same name exists on the object's prototype
  chain, then, after deletion, the object will use the property from the
  prototype chain (in other words, delete only has an effect on own
  properties).</source>
          <target state="translated">å¦‚æœå¯¹è±¡çš„åŸå‹é“¾ä¸Šå­˜åœ¨åŒåçš„å±æ€§,é‚£ä¹ˆåˆ é™¤å,è¯¥å¯¹è±¡å°†ä½¿ç”¨åŸå‹é“¾ä¸­çš„å±æ€§(æ¢å¥è¯è¯´,åˆ é™¤åªå¯¹è‡ªå·±çš„å±æ€§æœ‰å½±å“)ã€‚</target>
        </trans-unit>
        <trans-unit id="1e20c9e61654d816a6093dde8b64312b7bd4779b" translate="yes" xml:space="preserve">
          <source>If the property which you are trying to delete does not exist, delete
  will not have any effect and will return true</source>
          <target state="translated">å¦‚æœæ‚¨è¦åˆ é™¤çš„å±æ€§ä¸å­˜åœ¨,åˆ é™¤å°†æ²¡æœ‰ä»»ä½•æ•ˆæœ,å¹¶è¿”å›trueã€‚</target>
        </trans-unit>
        <trans-unit id="28ec183a3184d93a675028a4e725a85c94f1f649" translate="yes" xml:space="preserve">
          <source>If you do not know the index, you'll also have to do an index search:</source>
          <target state="translated">å¦‚æœä½ ä¸çŸ¥é“ç´¢å¼•,ä¹Ÿè¦åšä¸€ä¸ªç´¢å¼•æŸ¥è¯¢ã€‚</target>
        </trans-unit>
        <trans-unit id="3204a3a58282102b99263134aa04e4bbd9031c97" translate="yes" xml:space="preserve">
          <source>If you do:</source>
          <target state="translated">å¦‚æœä½ æœ‰çš„è¯ã€‚</target>
        </trans-unit>
        <trans-unit id="3204f4d5aa25757c4ed3063f2b869d5fde0626d5" translate="yes" xml:space="preserve">
          <source>If you know the index of your staff member, you could simply do this:</source>
          <target state="translated">å¦‚æœä½ çŸ¥é“ä½ çš„å·¥ä½œäººå‘˜çš„æŒ‡æ•°,ä½ å¯ä»¥ç®€å•åœ°è¿™æ ·åšã€‚</target>
        </trans-unit>
        <trans-unit id="9b546f76f9301b299e7ed78305baf0ef1addfe1c" translate="yes" xml:space="preserve">
          <source>If you want to delete a property deeply nested in the object then you can use the following recursive function with path to the property as the second argument:</source>
          <target state="translated">å¦‚æœä½ æƒ³åˆ é™¤ä¸€ä¸ªæ·±åµŒå¥—åœ¨å¯¹è±¡ä¸­çš„å±æ€§,é‚£ä¹ˆä½ å¯ä»¥ä½¿ç”¨ä¸‹é¢çš„é€’å½’å‡½æ•°,å¹¶å°†è¯¥å±æ€§çš„è·¯å¾„ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°ã€‚</target>
        </trans-unit>
        <trans-unit id="506bf20b873a7a4cd476c438c371ecd4bcca65fc" translate="yes" xml:space="preserve">
          <source>If you want to experiment with this, you can use &lt;a href=&quot;http://jsfiddle.net/cb57dusv/46/&quot;&gt;&lt;strong&gt;this Fiddle&lt;/strong&gt;&lt;/a&gt; as a starting point.</source>
          <target state="translated">å¦‚æœæ‚¨æƒ³å°è¯•ä¸€ä¸‹ï¼Œå¯ä»¥ä½¿ç”¨&lt;a href=&quot;http://jsfiddle.net/cb57dusv/46/&quot;&gt;&lt;strong&gt;æ­¤å°æç´&lt;/strong&gt;&lt;/a&gt;ä½œä¸ºèµ·ç‚¹ã€‚</target>
        </trans-unit>
        <trans-unit id="a4e72696da1b895cd7644dbb4f08034ae76c1836" translate="yes" xml:space="preserve">
          <source>If you want to use the entire &lt;code&gt;staff&lt;/code&gt; array, the proper way to do this, would be to do this:</source>
          <target state="translated">å¦‚æœè¦ä½¿ç”¨æ•´ä¸ª &lt;code&gt;staff&lt;/code&gt; æ•°ç»„ï¼Œæ‰§è¡Œæ­¤æ“ä½œçš„æ­£ç¡®æ–¹æ³•æ˜¯ï¼š</target>
        </trans-unit>
        <trans-unit id="43cf8d099321d601790e8b3431ad74fdf17809c0" translate="yes" xml:space="preserve">
          <source>Ignoring the dangers and problems inherent in &lt;code&gt;null&lt;/code&gt;, and the space wasted, this can be problematic if the array needs to be precise.</source>
          <target state="translated">å¿½ç•¥ &lt;code&gt;null&lt;/code&gt; å›ºæœ‰çš„å±é™©å’Œé—®é¢˜ä»¥åŠæµªè´¹çš„ç©ºé—´ï¼Œå¦‚æœæ•°ç»„éœ€è¦ç²¾ç¡®ï¼Œåˆ™å¯èƒ½ä¼šå‡ºç°é—®é¢˜ã€‚</target>
        </trans-unit>
        <trans-unit id="c138b726889b4f8045cc8db17ba22f8faa709ac8" translate="yes" xml:space="preserve">
          <source>In addition, while mutating objects in-place isn't stateless, you can use the functional nature of &lt;code&gt;Reflect.deleteProperty&lt;/code&gt; to do partial application and other functional techniques that aren't possible with &lt;code&gt;delete&lt;/code&gt; statements.</source>
          <target state="translated">æ­¤å¤–ï¼Œå°½ç®¡å°±åœ°æ”¹å˜å¯¹è±¡ä¸æ˜¯æ— çŠ¶æ€çš„ï¼Œä½†æ‚¨å¯ä»¥ä½¿ç”¨ &lt;code&gt;Reflect.deleteProperty&lt;/code&gt; çš„åŠŸèƒ½æ€§è´¨æ¥æ‰§è¡Œéƒ¨åˆ†åº”ç”¨ç¨‹åºå’Œå…¶ä»– &lt;code&gt;delete&lt;/code&gt; è¯­å¥æ— æ³•å®ç°çš„åŠŸèƒ½æŠ€æœ¯ã€‚</target>
        </trans-unit>
        <trans-unit id="5b114aff6680bfc75db078ff75477b94c1c576aa" translate="yes" xml:space="preserve">
          <source>In arrays, unlike plain old objects, using &lt;code&gt;delete&lt;/code&gt; leaves behind garbage in the form of &lt;code&gt;null&lt;/code&gt;, creating a &quot;hole&quot; in the array.</source>
          <target state="translated">åœ¨æ•°ç»„ä¸­ï¼Œä¸æ™®é€šçš„æ—§å¯¹è±¡ä¸åŒï¼Œä½¿ç”¨ &lt;code&gt;delete&lt;/code&gt; ä¼šä»¥ &lt;code&gt;null&lt;/code&gt; çš„å½¢å¼åœ¨åƒåœ¾åé¢ç•™ä¸‹åƒåœ¾ï¼Œä»è€Œåœ¨æ•°ç»„ä¸­åˆ›å»ºä¸€ä¸ª&amp;ldquo;æ´&amp;rdquo;ã€‚</target>
        </trans-unit>
        <trans-unit id="acf20d554a4832d04b9fb4c2dfc6cc9d34eda721" translate="yes" xml:space="preserve">
          <source>In the code above, simply doing &lt;code&gt;nodeRecords[i][lastTime] = undefined;&lt;/code&gt; will cause a massive memory leak because each animation frame. Each frame, all 65536 DOM elements will take up another 65536 individual slots, but the previous 65536 slots will only be set to undefined which leaves them hanging in the memory. Go ahead, try to run the above code in the console and see for yourself. After forcing an out-of-memory error, attempt to run it again except with the following version of the code that uses the &lt;code&gt;delete&lt;/code&gt; operator instead.</source>
          <target state="translated">åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œåªéœ€æ‰§è¡Œ &lt;code&gt;nodeRecords[i][lastTime] = undefined;&lt;/code&gt; å› ä¸ºæ¯ä¸ªåŠ¨ç”»å¸§éƒ½ä¼šå¯¼è‡´å¤§é‡å†…å­˜æ³„æ¼ã€‚ æ¯å¸§ï¼Œæ‰€æœ‰65536ä¸ªDOMå…ƒç´ å°†å ç”¨å¦ä¸€ä¸ª65536ä¸ªå•ç‹¬çš„æ’æ§½ï¼Œä½†æ˜¯ä»¥å‰çš„65536ä¸ªæ’æ§½å°†ä»…è¢«è®¾ç½®ä¸ºundefinedï¼Œè¿™ä¼šä½¿å®ƒä»¬æŒ‚åœ¨å†…å­˜ä¸­ã€‚ ç»§ç»­ï¼Œå°è¯•åœ¨æ§åˆ¶å°ä¸­è¿è¡Œä»¥ä¸Šä»£ç å¹¶äº²è‡ªæŸ¥çœ‹ã€‚ å¼ºåˆ¶æ‰§è¡Œå†…å­˜ä¸è¶³é”™è¯¯åï¼Œè¯·å°è¯•å†æ¬¡è¿è¡Œå®ƒï¼Œä½†ä»¥ä¸‹ç‰ˆæœ¬çš„ä»£ç ä½¿ç”¨ &lt;code&gt;delete&lt;/code&gt; è¿ç®—ç¬¦ä»£æ›¿ã€‚</target>
        </trans-unit>
        <trans-unit id="271f117734d63131f8d6a45f399a766357be7419" translate="yes" xml:space="preserve">
          <source>Increasingly stupid edge-case scenario aside, using &lt;code&gt;delete&lt;/code&gt; on said array will result in &lt;code&gt;null&lt;/code&gt; polluting the array, and probably causing bugs in the app later on. And if you check for &lt;code&gt;null&lt;/code&gt;, it would straight up skip the numbers resulting in the tabs being rendered like &lt;code&gt;[1] [2] [4] [5] ...&lt;/code&gt;.</source>
          <target state="translated">é™¤äº†è¶Šæ¥è¶Šæ„šè ¢çš„è¾¹ç¼˜æƒ…å†µä¹‹å¤–ï¼Œåœ¨æ‰€è¿°é˜µåˆ—ä¸Šä½¿ç”¨ &lt;code&gt;delete&lt;/code&gt; å°†å¯¼è‡´ &lt;code&gt;null&lt;/code&gt; æ±¡æŸ“é˜µåˆ—ï¼Œå¹¶å¯èƒ½ç¨åå¯¼è‡´åº”ç”¨ç¨‹åºä¸­çš„é”™è¯¯ã€‚ å¹¶ä¸”ï¼Œå¦‚æœæ‚¨æ£€æŸ¥æ˜¯å¦ä¸º &lt;code&gt;null&lt;/code&gt; ï¼Œå®ƒå°†ç›´æ¥è·³è¿‡æ•°å­—ï¼Œä»è€Œå¯¼è‡´åˆ¶è¡¨ç¬¦åƒ &lt;code&gt;[1] [2] [4] [5] ...&lt;/code&gt; é‚£æ ·å‘ˆç°ã€‚</target>
        </trans-unit>
        <trans-unit id="67a2e0451ade99e58384dc55f1327e29e5977c70" translate="yes" xml:space="preserve">
          <source>It &lt;strong&gt;deletes the key from the hashmap&lt;/strong&gt;.</source>
          <target state="translated">å®ƒ&lt;strong&gt;ä»å“ˆå¸Œå›¾ä¸­åˆ é™¤å¯†é’¥&lt;/strong&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="593fba807066e533a5fe4a2443019f46d7ca31da" translate="yes" xml:space="preserve">
          <source>JavaScript is an OOP Language, so everything is an object, including &lt;em&gt;arrays&lt;/em&gt;. Thus, I feel it necessary to point out a particular caveat.</source>
          <target state="translated">JavaScriptæ˜¯ä¸€ç§OOPè¯­è¨€ï¼Œå› æ­¤ä¸€åˆ‡éƒ½æ˜¯å¯¹è±¡ï¼ŒåŒ…æ‹¬&lt;em&gt;arrays&lt;/em&gt; ã€‚ å› æ­¤ï¼Œæˆ‘è§‰å¾—æœ‰å¿…è¦æŒ‡å‡ºä¸€ä¸ªç‰¹åˆ«çš„è­¦å‘Šã€‚</target>
        </trans-unit>
        <trans-unit id="b86b332c3f3aa1433f370f7189813a6381eb2178" translate="yes" xml:space="preserve">
          <source>Library-based property omission</source>
          <target state="translated">åŸºäºå›¾ä¹¦é¦†çš„è´¢äº§é—æ¼</target>
        </trans-unit>
        <trans-unit id="59b86486aed4edafd59a372a9da15c32460385f0" translate="yes" xml:space="preserve">
          <source>Like this:</source>
          <target state="translated">å°±åƒè¿™æ ·ã€‚</target>
        </trans-unit>
        <trans-unit id="23ee237b458378f4f66052abb7c903c28cbb18e4" translate="yes" xml:space="preserve">
          <source>Look at the &lt;strong&gt;&lt;a href=&quot;http://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;benchmark&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">çœ‹&lt;strong&gt;&lt;a href=&quot;http://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;åŸºå‡†&lt;/a&gt;&lt;/strong&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="d0447456284f7feabbe03be15bd344b6f319890b" translate="yes" xml:space="preserve">
          <source>Luckily, arrays &lt;em&gt;do&lt;/em&gt; have a specialized method for deleting indices and reallocating memory: &lt;code&gt;Array.prototype.splice()&lt;/code&gt;. You could write something like this:</source>
          <target state="translated">å¹¸è¿çš„æ˜¯ï¼Œæ•°ç»„&lt;em&gt;ç¡®å®&lt;/em&gt;å…·æœ‰åˆ é™¤ç´¢å¼•å’Œé‡æ–°åˆ†é…å†…å­˜çš„ä¸“ç”¨æ–¹æ³•ï¼š &lt;code&gt;Array.prototype.splice()&lt;/code&gt; ã€‚ æ‚¨å¯ä»¥è¿™æ ·å†™ï¼š</target>
        </trans-unit>
        <trans-unit id="098d9f24825c866c84675902efcb46bcadb54327" translate="yes" xml:space="preserve">
          <source>More than 2X faster than &lt;code&gt;delete&lt;/code&gt;, however the property is &lt;strong&gt;not&lt;/strong&gt; deleted and can be iterated.</source>
          <target state="translated">æ¯” &lt;code&gt;delete&lt;/code&gt; å¿«2å€ä»¥ä¸Šï¼Œä½†æ˜¯&lt;strong&gt;ä¸ä¼š&lt;/strong&gt;åˆ é™¤è¯¥å±æ€§ï¼Œå¹¶ä¸”å¯ä»¥å¯¹å…¶è¿›è¡Œè¿­ä»£ã€‚</target>
        </trans-unit>
        <trans-unit id="ccc762c5d3373bf8a3cde8b635c9825605d01c63" translate="yes" xml:space="preserve">
          <source>Mutative object property deletion, safe</source>
          <target state="translated">çªå˜å¯¹è±¡å±æ€§åˆ é™¤,å®‰å…¨</target>
        </trans-unit>
        <trans-unit id="9ce68ac5a3111b339ada2a12dd8cc6eea0e45ffa" translate="yes" xml:space="preserve">
          <source>Mutative object property deletion, unsafe</source>
          <target state="translated">çªå˜å¯¹è±¡å±æ€§åˆ é™¤,ä¸å®‰å…¨</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="089de7283699cfb1ed6d519cb14e7b0cf6326b5b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;_.pick()&lt;/code&gt; and &lt;code&gt;_.omit()&lt;/code&gt; both return a copy of the object and don't directly modify the original object. Assigning the result to the original object should do the trick (not shown).</source>
          <target state="translated">è¯·æ³¨æ„ï¼Œ &lt;code&gt;_.pick()&lt;/code&gt; å’Œ &lt;code&gt;_.omit()&lt;/code&gt; éƒ½è¿”å›å¯¹è±¡çš„å‰¯æœ¬ï¼Œå¹¶ä¸”ä¸ç›´æ¥ä¿®æ”¹åŸå§‹å¯¹è±¡ã€‚ å°†ç»“æœåˆ†é…ç»™åŸå§‹å¯¹è±¡åº”è¯¥å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼ˆæœªæ˜¾ç¤ºï¼‰ã€‚</target>
        </trans-unit>
        <trans-unit id="74d18dd16f1da3ac16685fb7e2b20e82dd3d4708" translate="yes" xml:space="preserve">
          <source>Note that I purposedly carried out more than one 'delete' operations in one loop cycle to minimize the effect caused by the other operations.</source>
          <target state="translated">æ³¨æ„,æˆ‘ç‰¹æ„åœ¨ä¸€ä¸ªå¾ªç¯å‘¨æœŸå†…è¿›è¡Œäº†å¤šä¸ª &quot;åˆ é™¤ &quot;æ“ä½œ,ä»¥å‡å°‘å…¶ä»–æ“ä½œé€ æˆçš„å½±å“ã€‚</target>
        </trans-unit>
        <trans-unit id="cbc78d0538f8d0b1ea57d6e615c0173c54cc2f85" translate="yes" xml:space="preserve">
          <source>Note that the wrapper function is designed to be very strict about types, and will return &lt;code&gt;null&lt;/code&gt; if anything is off. That includes putting in a string like &lt;code&gt;&quot;3&quot;&lt;/code&gt;. It is left up to the programmer to be diligent about his types. This is to encourage good programming practice.</source>
          <target state="translated">è¯·æ³¨æ„ï¼ŒåŒ…è£…å‡½æ•°çš„ç±»å‹éå¸¸ä¸¥æ ¼ï¼Œå¦‚æœç¦ç”¨ä»»ä½•å†…å®¹ï¼Œåˆ™è¿”å› &lt;code&gt;null&lt;/code&gt; ã€‚ è¿™åŒ…æ‹¬æ”¾å…¥ç±»ä¼¼ &lt;code&gt;&quot;3&quot;&lt;/code&gt; çš„å­—ç¬¦ä¸²ã€‚ ç¨‹åºå‘˜è¦å‹¤äºè‡ªå·±çš„ç±»å‹ã€‚ è¿™æ˜¯ä¸ºäº†é¼“åŠ±è‰¯å¥½çš„ç¼–ç¨‹ä¹ æƒ¯ã€‚</target>
        </trans-unit>
        <trans-unit id="0cd1e1c286ff1b960d2aa87f0e85fe9bd6a35fdd" translate="yes" xml:space="preserve">
          <source>Now, if you want to remove a single staff member or student, the procedure is a bit different, because both properties are arrays themselves.</source>
          <target state="translated">ç°åœ¨,å¦‚æœä½ æƒ³åˆ é™¤å•ä¸ªæ•™èŒå·¥æˆ–å­¦ç”Ÿ,è¿‡ç¨‹å°±æœ‰ç‚¹ä¸åŒäº†,å› ä¸ºè¿™ä¸¤ä¸ªå±æ€§æœ¬èº«å°±æ˜¯æ•°ç»„ã€‚</target>
        </trans-unit>
        <trans-unit id="e14273e8bb73415bec8db17e1b9d548211a7aed0" translate="yes" xml:space="preserve">
          <source>Now, you &lt;em&gt;could&lt;/em&gt; keep a second iterator, like &lt;code&gt;j&lt;/code&gt;, to increment only when valid values are read from the array. But that wouldn't exactly solve the &lt;code&gt;null&lt;/code&gt; issue, and you still have to please that &lt;s&gt;troll&lt;/s&gt; PDP-11 user. Alas, his computer just &lt;em&gt;doesn't&lt;/em&gt; have enough memory to hold that last integer &lt;sub&gt;(don't ask how he manages to handle a variable-width array...)&lt;/sub&gt;.</source>
          <target state="translated">ç°åœ¨ï¼Œæ‚¨&lt;em&gt;å¯ä»¥&lt;/em&gt;ä¿ç•™ç¬¬äºŒä¸ªè¿­ä»£å™¨ï¼Œå¦‚ &lt;code&gt;j&lt;/code&gt; ï¼Œä»…åœ¨ä»æ•°ç»„ä¸­è¯»å–æœ‰æ•ˆå€¼æ—¶æ‰é€’å¢ã€‚ ä½†è¿™å¹¶ä¸èƒ½å®Œå…¨è§£å†³ &lt;code&gt;null&lt;/code&gt; é—®é¢˜ï¼Œæ‚¨ä»ç„¶å¿…é¡»è¯·é‚£ä¸ª&lt;s&gt;å·¨é­”&lt;/s&gt; PDP-11ç”¨æˆ·ä½¿ç”¨ã€‚ lasï¼Œä»–çš„è®¡ç®—æœº&lt;em&gt;æ²¡æœ‰&lt;/em&gt;è¶³å¤Ÿçš„å†…å­˜æ¥å®¹çº³æœ€åä¸€ä¸ªæ•´æ•°&lt;sub&gt;ï¼ˆä¸è¦é—®ä»–å¦‚ä½•å¤„ç†å¯å˜å®½åº¦æ•°ç»„...ï¼‰&lt;/sub&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="e28b55f542be9cce84f1cc3f1bdb29e2a2eb72e0" translate="yes" xml:space="preserve">
          <source>Object.assign() &amp;amp; Object.keys() &amp;amp; Array.map()</source>
          <target state="translated">Object.assignï¼ˆï¼‰å’ŒObject.keysï¼ˆï¼‰å’ŒArray.mapï¼ˆï¼‰</target>
        </trans-unit>
        <trans-unit id="c643fe374f1dfb8aa281ee046c5ea254b1b7b942" translate="yes" xml:space="preserve">
          <source>Observe. &lt;code&gt;bar[1] = &quot;&quot;&lt;/code&gt; does not coerce polymorphism whereas &lt;code&gt;bar[1] = undefined&lt;/code&gt; does. Therefore, one should always, whenever possible use the corresponding type for their objects so as to not accidentally cause polymorphism. One such person may use the following list as a general reference to get them going. However, please do not explicitly use the below ideas. Instead, use whatever works well for your code.</source>
          <target state="translated">è§‚å¯Ÿä¸€ä¸‹ã€‚ &lt;code&gt;bar[1] = &quot;&quot;&lt;/code&gt; ä¸ä¼šå¼ºåˆ¶å¤šæ€æ€§ï¼Œè€Œ &lt;code&gt;bar[1] = undefined&lt;/code&gt; å¯ä»¥ã€‚ å› æ­¤ï¼Œåº”è¯¥å§‹ç»ˆå°½å¯èƒ½åœ°ä¸ºå…¶å¯¹è±¡ä½¿ç”¨ç›¸åº”çš„ç±»å‹ï¼Œä»¥å…å¶ç„¶å¯¼è‡´å¤šæ€ã€‚ ä¸€ä¸ªè¿™æ ·çš„äººå¯ä»¥ä½¿ç”¨ä»¥ä¸‹åˆ—è¡¨ä½œä¸ºä¸€èˆ¬å‚è€ƒï¼Œä»¥ä½¿ä»–ä»¬ç»§ç»­å‰è¿›ã€‚ ä½†æ˜¯ï¼Œè¯·ä¸è¦æ˜ç¡®ä½¿ç”¨ä»¥ä¸‹æƒ³æ³•ã€‚ ç›¸åï¼Œè¯·ä½¿ç”¨é€‚ç”¨äºæ‚¨ä»£ç çš„ä»»ä½•æ–¹æ³•ã€‚</target>
        </trans-unit>
        <trans-unit id="e583eed26b5bb4eb2fe3ea98e3d4481f60fbfae9" translate="yes" xml:space="preserve">
          <source>Of course, it &lt;em&gt;did&lt;/em&gt; surprise me. Because I wrote this to justify my crusade against &quot;null garbage&quot;:</source>
          <target state="translated">å½“ç„¶ï¼Œè¿™&lt;em&gt;ç¡®å®&lt;/em&gt;è®©æˆ‘æ„Ÿåˆ°æƒŠè®¶ã€‚ å› ä¸ºæˆ‘å†™è¿™æ˜¯ä¸ºäº†è¯æ˜æˆ‘çš„è¿åŠ¨åå¯¹&amp;ldquo;ç©ºåƒåœ¾&amp;rdquo;ï¼š</target>
        </trans-unit>
        <trans-unit id="9d008b07517f4d9dbae6df29270e3dfc66dcea5d" translate="yes" xml:space="preserve">
          <source>Okay, let's just say that you're trying to save memory at the request of this &lt;em&gt;one&lt;/em&gt; user who runs a PDP-11 minicomputer from the 1960's running UNIX and wrote his own Elinks-based, JavaScript-compliant, line-printer-friendly browser because X11 is &lt;em&gt;out of the question&lt;/em&gt;.</source>
          <target state="translated">å¥½çš„ï¼Œæˆ‘ä»¬åªæ˜¯è¯´ï¼Œæ‚¨æ­£åœ¨å°è¯•æ ¹æ®ä¸€ä½è¿è¡Œ1960å¹´ä»£è¿è¡ŒUNIXçš„PDP-11å¾®å‹è®¡ç®—æœºçš„ç”¨æˆ·çš„è¯·æ±‚æ¥èŠ‚çœå†…å­˜ï¼Œå¹¶ç¼–å†™äº†è‡ªå·±çš„åŸºäºElinksï¼ŒJavaScriptå…¼å®¹ï¼Œå¯¹è¡Œæ‰“å°æœºå‹å¥½çš„æµè§ˆå™¨å› ä¸ºX11æ˜¯ä¸å¯èƒ½&lt;em&gt;çš„&lt;/em&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="0746b7ec72e10adab007597141d3dddd2450c60e" translate="yes" xml:space="preserve">
          <source>Old question, modern answer. Using object destructuring, an &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015&quot;&gt;ECMAScript&amp;nbsp;6&lt;/a&gt; feature, it's as simple as:</source>
          <target state="translated">æ—§é—®é¢˜ï¼Œç°ä»£ç­”æ¡ˆã€‚ ä½¿ç”¨å¯¹è±¡åˆ†è§£ï¼ˆ &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015&quot;&gt;ECMAScript 6&lt;/a&gt;åŠŸèƒ½ï¼‰ï¼Œå®ƒå¾ˆç®€å•ï¼š</target>
        </trans-unit>
        <trans-unit id="88891f47a253aa57bb1cb91937b9715b281db53b" translate="yes" xml:space="preserve">
          <source>Once polymorphic, always polymorphic. When an array is made polymorphic, the polymorphism cannot be undone in Webkit browsers. So, even if you restore a polymorphic array to being non-polymorphic, it will still be stored by the browser as a polymorphic array.</source>
          <target state="translated">ä¸€æ—¦å¤šæ€åŒ–,å°±æ°¸è¿œæ˜¯å¤šæ€åŒ–ã€‚å½“ä¸€ä¸ªæ•°ç»„è¢«å¤šæ€åŒ–å,åœ¨Webkitæµè§ˆå™¨ä¸­æ— æ³•æ’¤é”€å¤šæ€åŒ–ã€‚å› æ­¤,å³ä½¿ä½ å°†ä¸€ä¸ªå¤šæ€åŒ–çš„æ•°ç»„æ¢å¤ä¸ºéå¤šæ€åŒ–,å®ƒä»ç„¶ä¼šè¢«æµè§ˆå™¨ä½œä¸ºå¤šæ€åŒ–æ•°ç»„å­˜å‚¨ã€‚</target>
        </trans-unit>
        <trans-unit id="b248f1b8652c2d4ab474434fceed81458cb94383" translate="yes" xml:space="preserve">
          <source>Once those four queries have been answered, there are essentially four categories of &quot;property removal&quot; in JavaScript to chose from in order to meet your goals. They are:</source>
          <target state="translated">åœ¨å›ç­”äº†è¿™å››ä¸ªé—®é¢˜ä¹‹å,åŸºæœ¬ä¸Šæœ‰å››ç±» &quot;å±æ€§åˆ é™¤ &quot;JavaScriptä¸­çš„ &quot;å±æ€§åˆ é™¤ &quot;å¯ä»¥é€‰æ‹©,ä»¥æ»¡è¶³ä½ çš„ç›®æ ‡ã€‚å®ƒä»¬åˆ†åˆ«æ˜¯ã€‚</target>
        </trans-unit>
        <trans-unit id="547c95266578e4dba22f41101c7fbe880f75e156" translate="yes" xml:space="preserve">
          <source>One aspect of Javascript that is important to consider is polymorphism. Polymorphism is when assigning the same variable/slot-in-an-object different types as seen below.</source>
          <target state="translated">Javascriptä¸­éœ€è¦è€ƒè™‘çš„ä¸€ä¸ªæ–¹é¢æ˜¯å¤šæ€æ€§ã€‚å¤šæ€æ€§æ˜¯å½“åˆ†é…ç›¸åŒçš„å˜é‡lot-in-an-objectä¸åŒçš„ç±»å‹æ—¶,å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚</target>
        </trans-unit>
        <trans-unit id="d59804a9108998189135354633d8b85aa6ac9872" translate="yes" xml:space="preserve">
          <source>One may liken polymorphism to a drug addiction. At first glance, it seems awesomely lucrative: nice pretty fluffy code. Then, the coder introduces their array to the drug of polymorphism. Instantly, the polymorphic array becomes less efficient, and it can never become as efficient as it was before since it is drugged. To correlate such circumstance to real life, someone on cocaine might not even be capable of operating a simple door handle, much less be able to calculate digits of PI. Likewise, an array on the drug of polymorphism cannot ever be as efficient as a monomorphic array.</source>
          <target state="translated">æœ‰äººå¯èƒ½ä¼šæŠŠå¤šæ€æ€§æ¯”å–»ä¸ºå¸æ¯’æˆç˜¾ã€‚ä¹çœ‹ä¹‹ä¸‹,å®ƒä¼¼ä¹éå¸¸æœ‰åˆ©å¯å›¾:æ¼‚äº®æ¼‚äº®çš„è“¬æ¾çš„ä»£ç ã€‚ç„¶å,ç¼–ç å‘˜å°†ä»–ä»¬çš„æ•°ç»„å¼•å…¥åˆ°å¤šæ€åŒ–çš„æ¯’å“ä¸­ã€‚ç¬é—´,å¤šæ€æ•°ç»„çš„æ•ˆç‡å°±ä¼šå˜å¾—å¾ˆä½,è‡ªä»è¢«ä¸‹è¯å,å®ƒçš„æ•ˆç‡å°±å†ä¹Ÿæ— æ³•åƒä»¥å‰é‚£æ ·é«˜äº†ã€‚å°†è¿™æ ·çš„æƒ…å†µä¸ç°å®ç”Ÿæ´»è”ç³»èµ·æ¥,ä¸€ä¸ªäººå¸é£Ÿäº†å¯å¡å› ,å¯èƒ½è¿ç®€å•çš„é—¨æŠŠæ‰‹éƒ½æ— æ³•æ“ä½œ,æ›´ä¸ç”¨è¯´èƒ½å¤Ÿè®¡ç®—å‡ºPIçš„æ•°å­—äº†ã€‚åŒæ ·çš„,å¤šæ€æ€§çš„è¯ç‰©ä¸Šçš„é˜µåˆ—ä¹Ÿä¸å¯èƒ½åƒå•æ€æ€§çš„é˜µåˆ—é‚£æ ·é«˜æ•ˆã€‚</target>
        </trans-unit>
        <trans-unit id="81ec1a879d1bcac8eaeb3bcd6cca8f51d459b6e9" translate="yes" xml:space="preserve">
          <source>Operator &lt;code&gt;delete&lt;/code&gt; is unexpectedly slow!</source>
          <target state="translated">æ“ä½œå‘˜ &lt;code&gt;delete&lt;/code&gt; å¼‚å¸¸ç¼“æ…¢ï¼</target>
        </trans-unit>
        <trans-unit id="b0213d049275e53829195e4fb176386bc570f98e" translate="yes" xml:space="preserve">
          <source>Or add it as a new pointer to another object like:</source>
          <target state="translated">æˆ–è€…å°†å…¶ä½œä¸ºä¸€ä¸ªæ–°çš„æŒ‡é’ˆæ·»åŠ åˆ°å¦ä¸€ä¸ªå¯¹è±¡,å¦‚ã€‚</target>
        </trans-unit>
        <trans-unit id="b02fc9813af3fdbb140c9b950f4bb96861bf726a" translate="yes" xml:space="preserve">
          <source>Or with the questions sample:</source>
          <target state="translated">æˆ–å¸¦ç€é—®é¢˜çš„æ ·æœ¬ã€‚</target>
        </trans-unit>
        <trans-unit id="e9b0d0e32654faf6fc06ca2ce8663172c501d507" translate="yes" xml:space="preserve">
          <source>Or you can also use array-like notation:</source>
          <target state="translated">æˆ–è€…ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ç±»ä¼¼æ•°ç»„çš„è®°å·æ³•ã€‚</target>
        </trans-unit>
        <trans-unit id="040435ad5191a6323d4b61a949b35014d90fb332" translate="yes" xml:space="preserve">
          <source>Or you can dynamically exclude properties like this,</source>
          <target state="translated">æˆ–è€…ä½ å¯ä»¥åƒè¿™æ ·åŠ¨æ€æ’é™¤å±æ€§ã€‚</target>
        </trans-unit>
        <trans-unit id="a7ca816fcb165b225c5a6969cca6cd3afa101c70" translate="yes" xml:space="preserve">
          <source>Properties can be removed using &lt;strong&gt;destructuring&lt;/strong&gt; in combination with the &lt;strong&gt;rest operator&lt;/strong&gt;. In your example regex is destructured out (ignored) and the rest of the properties are returned as rest.</source>
          <target state="translated">å¯ä»¥é€šè¿‡ä¸&lt;strong&gt;restè¿ç®—ç¬¦&lt;/strong&gt;ç»“åˆä½¿ç”¨&lt;strong&gt;åˆ†è§£&lt;/strong&gt;æ¥åˆ é™¤å±æ€§ã€‚ åœ¨æ‚¨çš„ç¤ºä¾‹ä¸­ï¼Œæ­£åˆ™è¡¨è¾¾å¼è¢«è§£æ„ï¼ˆå¿½ç•¥ï¼‰ï¼Œå…¶ä½™å±æ€§ä½œä¸ºå…¶ä½™éƒ¨åˆ†è¿”å›ã€‚</target>
        </trans-unit>
        <trans-unit id="257bb222f1c06e8c1d8edf559d64e06deb75f2f0" translate="yes" xml:space="preserve">
          <source>Property Removal in JavaScript</source>
          <target state="translated">JavaScriptä¸­çš„å±æ€§ç§»é™¤</target>
        </trans-unit>
        <trans-unit id="83a4727bcff27e1d95598a97b2a871336f59a8c8" translate="yes" xml:space="preserve">
          <source>Readable and short, however, it might not be the best choice if you are operating on a large number of objects as its performance is not optimized.</source>
          <target state="translated">å¯è¯»æ€§å¼º,æ—¶é—´çŸ­,ä½†æ˜¯,å¦‚æœä½ åœ¨æ“ä½œå¤§é‡çš„å¯¹è±¡æ—¶,å®ƒå¯èƒ½ä¸æ˜¯æœ€å¥½çš„é€‰æ‹©,å› ä¸ºå®ƒçš„æ€§èƒ½æ²¡æœ‰å¾—åˆ°ä¼˜åŒ–ã€‚</target>
        </trans-unit>
        <trans-unit id="ce7827682ca4a098e50c7905bb13aa7c7e60006c" translate="yes" xml:space="preserve">
          <source>Ref: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;MDN&lt;/a&gt;.</source>
          <target state="translated">å‚è€ƒï¼š &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;MDN&lt;/a&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="f02218cedd8e4fd7e585302dc05d8d0a5833d5f0" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://underscorejs.org/#omit&quot;&gt;link&lt;/a&gt;&lt;strong&gt;_.omit(object, *keys)&lt;/strong&gt;</source>
          <target state="translated">å‚è€ƒï¼š &lt;a href=&quot;http://underscorejs.org/#omit&quot;&gt;link&lt;/a&gt; &lt;strong&gt;_.omitï¼ˆobjectï¼Œ* keysï¼‰&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a3c1aeff97f5a6d2ba0a975a623e96c949b36be" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://underscorejs.org/#pick&quot;&gt;link&lt;/a&gt;&lt;strong&gt;_.pick(object, *keys)&lt;/strong&gt;</source>
          <target state="translated">å‚è€ƒï¼š &lt;a href=&quot;http://underscorejs.org/#pick&quot;&gt;é“¾æ¥&lt;/a&gt; &lt;strong&gt;_.pickï¼ˆobjectï¼Œ* keysï¼‰&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5817e749619edf322d60f85b86cab9c7f83094af" translate="yes" xml:space="preserve">
          <source>Rest-based string property omission</source>
          <target state="translated">åŸºäºä¼‘æ¯çš„å­—ç¬¦ä¸²å±æ€§çœç•¥</target>
        </trans-unit>
        <trans-unit id="ab303515578a450fdf614933afe415b6528c01d1" translate="yes" xml:space="preserve">
          <source>Return a copy of the object, filtered to omit the 
blacklisted keys (or array of keys).</source>
          <target state="translated">è¿”å›ä¸€ä¸ªå¯¹è±¡çš„å‰¯æœ¬,é€šè¿‡è¿‡æ»¤æ¥çœç•¥é»‘åå•ä¸­çš„å¯†é’¥(æˆ–å¯†é’¥æ•°ç»„)ã€‚</target>
        </trans-unit>
        <trans-unit id="011a1cad4539d30348ba24adcd37dceade1f93c1" translate="yes" xml:space="preserve">
          <source>Return a copy of the object, filtered to only have values for the 
whitelisted keys (or array of valid keys).</source>
          <target state="translated">è¿”å›ä¸€ä¸ªå¯¹è±¡çš„å‰¯æœ¬,è¿‡æ»¤åä»…æœ‰ç™½é”®(æˆ–æœ‰æ•ˆé”®æ•°ç»„)çš„å€¼ã€‚</target>
        </trans-unit>
        <trans-unit id="650045349baef87a1fa74815eb1e6653f73e4e45" translate="yes" xml:space="preserve">
          <source>Say I create an object as follows:</source>
          <target state="translated">è¯´æˆ‘åˆ›å»ºä¸€ä¸ªå¯¹è±¡å¦‚ä¸‹:</target>
        </trans-unit>
        <trans-unit id="f5d2829fcf8f71f8331358342fe9021d00422606" translate="yes" xml:space="preserve">
          <source>Setting a property to null before deleting it doesn't accomplish
  anything (unless the object has been sealed by Object.seal and the
  delete fails. That's not usually the case unless you specifically
  try).</source>
          <target state="translated">åœ¨åˆ é™¤ä¹‹å‰å°†å±æ€§è®¾ç½®ä¸ºnullå¹¶æ²¡æœ‰ä»€ä¹ˆæ•ˆæœ(é™¤éå¯¹è±¡å·²ç»è¢«Object.sealå°å°,å¹¶ä¸”åˆ é™¤å¤±è´¥ã€‚é™¤éä½ ç‰¹åˆ«å°è¯•,å¦åˆ™é€šå¸¸ä¸ä¼šå‡ºç°è¿™ç§æƒ…å†µ)ã€‚)</target>
        </trans-unit>
        <trans-unit id="a1aeff6040cbaf4a052232c94541c2b536b4a1f3" translate="yes" xml:space="preserve">
          <source>Similarly, removing the entire students array would be done by calling &lt;code&gt;delete Hogwarts.students;&lt;/code&gt; or &lt;code&gt;delete Hogwarts['students'];&lt;/code&gt;.</source>
          <target state="translated">åŒæ ·ï¼Œåˆ é™¤æ•´ä¸ªå­¦ç”Ÿæ•°ç»„å¯ä»¥é€šè¿‡è°ƒç”¨ &lt;code&gt;delete Hogwarts.students;&lt;/code&gt; æ¥å®Œæˆã€‚ æˆ– &lt;code&gt;delete Hogwarts['students'];&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="fd410e78d809f27ec1e3bdad4ee5576324a4212e" translate="yes" xml:space="preserve">
          <source>So as it turns out, there actually IS a built-in way to tell if an array is truly an array, and that is &lt;code&gt;Array.isArray()&lt;/code&gt;, introduced in ECMAScript 5 (December 2009). I found this while looking to see if there was a question asking about telling arrays from objects, to see if there was either a better solution than mine, or to add mine if there were none. So, if you're using a version of JavaScript that is earlier than ECMA 5, there's your polyfill. However, I strongly recommend against using my &lt;code&gt;is_array()&lt;/code&gt; function, as continuing to support old versions of JavaScript means continuing to support the old browsers that implement them, which means encouraging the use of insecure software and putting users at risk for malware. So please, use &lt;code&gt;Array.isArray()&lt;/code&gt;. Use &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. Use the new features that get added to the language. &lt;em&gt;Don't&lt;/em&gt; use vendor prefixes. &lt;em&gt;Delete&lt;/em&gt; that IE polyfill crap from your website. Delete that XHTML &lt;code&gt;&amp;lt;!CDATA[[...&lt;/code&gt; crap, too--we moved to HTML5 back in 2014. The sooner everybody withdraws support for those old/esoteric browsers, the sooner the browser vendors will actually follow the web standard and embrace the new technology, and the sooner we can move on to a more secure web.</source>
          <target state="translated">äº‹å®è¯æ˜ï¼Œå®é™…ä¸Šå­˜åœ¨ä¸€ç§å†…ç½®æ–¹æ³•æ¥åˆ¤æ–­æ•°ç»„æ˜¯å¦çœŸæ­£æ˜¯æ•°ç»„ï¼Œè¿™å°±æ˜¯ECMAScript 5ï¼ˆ2009å¹´12æœˆï¼‰ä¸­å¼•å…¥çš„ &lt;code&gt;Array.isArray()&lt;/code&gt; ï¼‰ã€‚ æˆ‘åœ¨å¯»æ‰¾æ˜¯å¦æœ‰ä¸€ä¸ªé—®é¢˜æ¥è¯¢é—®å¯¹è±¡æ•°ç»„æ—¶å‘ç°äº†è¿™ä¸ªé—®é¢˜ï¼Œä»¥æŸ¥çœ‹æ˜¯å¦æœ‰æ¯”æˆ‘çš„æ›´å¥½çš„è§£å†³æ–¹æ¡ˆï¼Œæˆ–è€…æ˜¯å¦æœ‰æ²¡æœ‰æ¯”æˆ‘çš„æ›´å¥½çš„è§£å†³æ–¹æ¡ˆã€‚ å› æ­¤ï¼Œå¦‚æœä½¿ç”¨çš„JavaScriptç‰ˆæœ¬æ—©äºECMA 5ï¼Œåˆ™å¯ä»¥ä½¿ç”¨polyfillã€‚ ä½†æ˜¯ï¼Œæˆ‘å¼ºçƒˆå»ºè®®æ‚¨ä¸è¦ä½¿ç”¨ &lt;code&gt;is_array()&lt;/code&gt; å‡½æ•°ï¼Œå› ä¸ºç»§ç»­æ”¯æŒæ—§ç‰ˆæœ¬çš„JavaScriptæ„å‘³ç€ç»§ç»­æ”¯æŒå®ç°æ—§ç‰ˆæœ¬JavaScriptçš„æµè§ˆå™¨ï¼Œè¿™æ„å‘³ç€é¼“åŠ±ä½¿ç”¨ä¸å®‰å…¨çš„è½¯ä»¶ï¼Œå¹¶ä½¿ç”¨æˆ·é¢ä¸´æ¶æ„è½¯ä»¶çš„é£é™©ã€‚ å› æ­¤ï¼Œè¯·ä½¿ç”¨ &lt;code&gt;Array.isArray()&lt;/code&gt; ã€‚ ä½¿ç”¨ &lt;code&gt;let&lt;/code&gt; å’Œ &lt;code&gt;const&lt;/code&gt; ã€‚ ä½¿ç”¨æ·»åŠ åˆ°è¯¥è¯­è¨€çš„æ–°åŠŸèƒ½ã€‚ &lt;em&gt;ä¸è¦&lt;/em&gt;ä½¿ç”¨ä¾›åº”å•†å‰ç¼€ã€‚ ä»æ‚¨çš„ç½‘ç«™ä¸­&lt;em&gt;åˆ é™¤&lt;/em&gt;è¯¥IE polyfillåºŸè¯ã€‚ åˆ é™¤XHTML &lt;code&gt;&amp;lt;!CDATA[[...&lt;/code&gt; åºŸè¯ï¼Œä¹ŸåºŸè¯äº†&amp;ndash;æˆ‘ä»¬åœ¨2014å¹´æ”¹ç”¨äº†HTML5ã€‚æ–°æŠ€æœ¯ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°½å¿«è¿›å…¥æ›´å®‰å…¨çš„ç½‘ç»œã€‚</target>
        </trans-unit>
        <trans-unit id="c1074a68b7264ece395e8476f70ae784fc36b406" translate="yes" xml:space="preserve">
          <source>So, he sends you an email in anger:</source>
          <target state="translated">æ‰€ä»¥,ä»–ç”Ÿæ°”åœ°ç»™ä½ å‘äº†ä¸€å°é‚®ä»¶ã€‚</target>
        </trans-unit>
        <trans-unit id="1c63c8fdc7a32a45814f6f70f31838cecabdb16b" translate="yes" xml:space="preserve">
          <source>So, when deleting values from an object, always first consider whether you're dealing with object properties or whether you're dealing with array values, and choose the appropriate strategy based on that.</source>
          <target state="translated">æ‰€ä»¥,åœ¨åˆ é™¤å¯¹è±¡ä¸­çš„å€¼æ—¶,ä¸€å®šè¦å…ˆè€ƒè™‘ä½ æ˜¯åœ¨å¤„ç†å¯¹è±¡çš„å±æ€§,è¿˜æ˜¯åœ¨å¤„ç†æ•°ç»„çš„å€¼,å¹¶æ ¹æ®è¿™ä¸€ç‚¹é€‰æ‹©åˆé€‚çš„ç­–ç•¥ã€‚</target>
        </trans-unit>
        <trans-unit id="da5db28dd16264310f46eacb87a0cb2b9ceef675" translate="yes" xml:space="preserve">
          <source>Sorry if this didn't add to your specific use case but I believe this to be a good design to adapt when managing objects and their properties.</source>
          <target state="translated">å¦‚æœè¿™æ²¡æœ‰å¢åŠ ä½ çš„å…·ä½“ç”¨ä¾‹,å¾ˆæŠ±æ­‰,ä½†æˆ‘ç›¸ä¿¡è¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„è®¾è®¡,å¯ä»¥åœ¨ç®¡ç†å¯¹è±¡åŠå…¶å±æ€§æ—¶è¿›è¡Œè°ƒæ•´ã€‚</target>
        </trans-unit>
        <trans-unit id="ace92799b8ad9dc2af653b95d2a4f16910423d4b" translate="yes" xml:space="preserve">
          <source>Suppose you have an object that looks like this:</source>
          <target state="translated">å‡è®¾ä½ æœ‰ä¸€ä¸ªçœ‹èµ·æ¥åƒè¿™æ ·çš„å¯¹è±¡ã€‚</target>
        </trans-unit>
        <trans-unit id="c5229642bf5961f2b277471727e88e647035ac9e" translate="yes" xml:space="preserve">
          <source>Syntax-based string property omission</source>
          <target state="translated">åŸºäºè¯­æ³•çš„å­—ç¬¦ä¸²å±æ€§çœç•¥</target>
        </trans-unit>
        <trans-unit id="07c468c127104c88b077c6e07b9d9ec7d4fdbf7d" translate="yes" xml:space="preserve">
          <source>THE LONG VERSION</source>
          <target state="translated">é•¿ç¯‡</target>
        </trans-unit>
        <trans-unit id="11405ca028271229b8731c4ce6c20d04dc54cc92" translate="yes" xml:space="preserve">
          <source>THE SHORT VERSION</source>
          <target state="translated">ç®€ç•¥ç‰ˆ</target>
        </trans-unit>
        <trans-unit id="39fdec1194d94212b871a28b2aa04a73cd40fce1" translate="yes" xml:space="preserve">
          <source>Tests</source>
          <target state="translated">Tests</target>
        </trans-unit>
        <trans-unit id="748beb2ad7204d2997b5d2a12f2e0bc89bcc8e5e" translate="yes" xml:space="preserve">
          <source>That actually isn't what's happening, but it's easier to think of that way. According to MDN, here's what's actually happening:</source>
          <target state="translated">å®é™…ä¸Šä¸æ˜¯è¿™æ ·çš„,ä½†è¿™æ ·æƒ³èµ·æ¥æ¯”è¾ƒå®¹æ˜“ã€‚æ ¹æ®MDNçš„è¯´æ³•,å®é™…æƒ…å†µæ˜¯è¿™æ ·çš„ã€‚</target>
        </trans-unit>
        <trans-unit id="cf85fec62dde51f1637af10a625442c3baea4c48" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;delete operator&lt;/a&gt; is the best way to do so.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;åˆ é™¤è¿ç®—ç¬¦&lt;/a&gt;æ˜¯æœ€å¥½çš„æ–¹æ³•ã€‚</target>
        </trans-unit>
        <trans-unit id="881ea24ac20b3a2b7bbbd8208c871ee412db982f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;key remains on its place in the hashmap&lt;/strong&gt;, only the value is replaced with &lt;code&gt;undefined&lt;/code&gt;. Understand, that &lt;code&gt;for..in&lt;/code&gt; loop will still iterate over that key.</source>
          <target state="translated">&lt;strong&gt;é”®ä¿ç•™åœ¨å“ˆå¸Œå›¾ä¸­çš„ä½ç½®&lt;/strong&gt; ï¼Œä»…å°†å€¼æ›¿æ¢ä¸º &lt;code&gt;undefined&lt;/code&gt; ã€‚ å¯ä»¥ç†è§£ï¼Œ &lt;code&gt;for..in&lt;/code&gt; å¾ªç¯ä»ä¼šå¯¹è¯¥é”®è¿›è¡Œè¿­ä»£ã€‚</target>
        </trans-unit>
        <trans-unit id="edc38116420d64a21ebfee30ed9c7476267110df" translate="yes" xml:space="preserve">
          <source>The Solution: &lt;code&gt;Array.prototype.splice&lt;/code&gt;</source>
          <target state="translated">è§£å†³æ–¹æ¡ˆï¼š &lt;code&gt;Array.prototype.splice&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="071cbdf7a24a78eb243d7c493b80aadba4657908" translate="yes" xml:space="preserve">
          <source>The actual answer to the question</source>
          <target state="translated">å®é™…å›ç­”è¿™ä¸ªé—®é¢˜</target>
        </trans-unit>
        <trans-unit id="c0ec14910cf4674ceea7f9ad991e964445d6c9ac" translate="yes" xml:space="preserve">
          <source>The answer would be to &lt;strong&gt;delete all the references you have in your code, pointed to that very object&lt;/strong&gt; and also &lt;strong&gt;not use &lt;code&gt;var&lt;/code&gt; statements to create new references to that object&lt;/strong&gt;. This last point regarding &lt;code&gt;var&lt;/code&gt; statements, is one of the most crucial issues that we are usually faced with, because using &lt;code&gt;var&lt;/code&gt; statements would prevent the created object from getting removed.</source>
          <target state="translated">ç­”æ¡ˆæ˜¯&lt;strong&gt;åˆ é™¤ä»£ç ä¸­æŒ‡å‘è¯¥å¯¹è±¡çš„æ‰€æœ‰å¼•ç”¨ï¼Œ&lt;/strong&gt;å¹¶ä¸”&lt;strong&gt;ä¸ä½¿ç”¨ &lt;code&gt;var&lt;/code&gt; è¯­å¥åˆ›å»ºå¯¹è¯¥å¯¹è±¡çš„æ–°å¼•ç”¨&lt;/strong&gt; ã€‚ å…³äº &lt;code&gt;var&lt;/code&gt; è¯­å¥çš„æœ€åä¸€ç‚¹æ˜¯æˆ‘ä»¬é€šå¸¸é¢ä¸´çš„æœ€å…³é”®çš„é—®é¢˜ä¹‹ä¸€ï¼Œå› ä¸ºä½¿ç”¨ &lt;code&gt;var&lt;/code&gt; è¯­å¥å°†é˜»æ­¢åˆ é™¤åˆ›å»ºçš„å¯¹è±¡ã€‚</target>
        </trans-unit>
        <trans-unit id="c25007fa1063a6b669074a068e8e0d9c200dbaad" translate="yes" xml:space="preserve">
          <source>The contrived and long-winded PDP-11 scenario</source>
          <target state="translated">è¿‚å›æ›²æŠ˜çš„PDP-11è®¡åˆ’æ–¹æ¡ˆ</target>
        </trans-unit>
        <trans-unit id="f621835acbbff87822c037f614ae8feebd84f7e5" translate="yes" xml:space="preserve">
          <source>The delete operator removes a given property from an object. On
  successful deletion, it will return true, else false will be returned.
  However, it is important to consider the following scenarios:</source>
          <target state="translated">åˆ é™¤æ“ä½œç¬¦å°†ä»ä¸€ä¸ªå¯¹è±¡ä¸­åˆ é™¤ç»™å®šçš„å±æ€§ã€‚åœ¨æˆåŠŸåˆ é™¤æ—¶,å®ƒå°†è¿”å›true,å¦åˆ™å°†è¿”å›falseã€‚ä½†æ˜¯,å¿…é¡»è€ƒè™‘ä»¥ä¸‹æƒ…å†µã€‚</target>
        </trans-unit>
        <trans-unit id="88d438bbfeb05c4266f6e27b90dcb851c6f60ce6" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;deleteProperty&lt;/code&gt; is when using strict mode:</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; å’Œ &lt;code&gt;deleteProperty&lt;/code&gt; ä¹‹é—´çš„åŒºåˆ«åœ¨äºä½¿ç”¨ä¸¥æ ¼æ¨¡å¼æ—¶ï¼š</target>
        </trans-unit>
        <trans-unit id="efccd6cd704a79d07bccddefc3adbae94e968c39" translate="yes" xml:space="preserve">
          <source>The following snippet gives another simple example:</source>
          <target state="translated">ä¸‹é¢çš„ç‰‡æ®µå†ä¸¾ä¸€ä¸ªç®€å•çš„ä¾‹å­ã€‚</target>
        </trans-unit>
        <trans-unit id="bf8a2a946389853c6d0799bf61400c9d604dd48d" translate="yes" xml:space="preserve">
          <source>The index specified by &lt;code&gt;end&lt;/code&gt; is simply excluded from the slice. The parenthesized indices indicate what gets sliced. Either way, the behavior is not intuitive and it's bound to cause its fair share of off-by-one errors, so you might find it useful to make a wrapper function to more closely emulate the behavior of &lt;code&gt;.splice()&lt;/code&gt;:</source>
          <target state="translated">ç”± &lt;code&gt;end&lt;/code&gt; æŒ‡å®šçš„ç´¢å¼•ä»…ä»åˆ‡ç‰‡ä¸­æ’é™¤ã€‚ æ‹¬å·ä¸­çš„ç´¢å¼•æŒ‡ç¤ºè¦åˆ‡çš„å†…å®¹ã€‚ æ— è®ºå“ªç§æ–¹å¼ï¼Œè¡Œä¸ºéƒ½ä¸æ˜¯ç›´è§‚çš„ï¼Œå¹¶ä¸”åŠ¿å¿…ä¼šé€ æˆä¸€å®šæ¯”ä¾‹çš„ä¸€æ¬¡æ€§é”™è¯¯ï¼Œå› æ­¤æ‚¨å¯èƒ½ä¼šå‘ç°ä½¿åŒ…è£…å‡½æ•°æ›´ç´§å¯†åœ°æ¨¡æ‹Ÿ &lt;code&gt;.splice()&lt;/code&gt; çš„è¡Œä¸ºå¾ˆæœ‰ç”¨ ï¼š</target>
        </trans-unit>
        <trans-unit id="367c08658a0eaac4d7f551272d9531077bdd6a38" translate="yes" xml:space="preserve">
          <source>The other important point here is to be careful about your other references to the same object. For instance, if you create a variable like:</source>
          <target state="translated">è¿™é‡Œè¿˜æœ‰ä¸€ç‚¹å¾ˆé‡è¦,é‚£å°±æ˜¯è¦æ³¨æ„ä½ å¯¹åŒä¸€å¯¹è±¡çš„å…¶ä»–å¼•ç”¨ã€‚ä¾‹å¦‚,å¦‚æœä½ åˆ›å»ºäº†ä¸€ä¸ªåƒ.....è¿™æ ·çš„å˜é‡ã€‚</target>
        </trans-unit>
        <trans-unit id="556ff37bb94e5cbb3dd116d5ddf709d4c4f7ed56" translate="yes" xml:space="preserve">
          <source>The programming ethos/patterns you and your team use. Do you favor functional approaches and mutation is verboten on your team, or do you employ wild west mutative object-oriented techniques?</source>
          <target state="translated">ä½ å’Œä½ çš„å›¢é˜Ÿä½¿ç”¨çš„ç¼–ç¨‹ä¼¦ç†æ¨¡å¼ã€‚åœ¨ä½ çš„å›¢é˜Ÿä¸­,ä½ æ˜¯åå‘äºåŠŸèƒ½åŒ–çš„æ–¹æ³•,ç¦æ­¢çªå˜,è¿˜æ˜¯é‡‡ç”¨è¥¿éƒ¨çªå˜çš„é¢å‘å¯¹è±¡æŠ€æœ¯?</target>
        </trans-unit>
        <trans-unit id="6357292b24fba94284af6389041f255b8a00f04f" translate="yes" xml:space="preserve">
          <source>The range of object types you want to remove properties on and the type of property names you need to be able to omit (Strings only? Symbols? Weak references mapped from arbitrary objects? These have all been types of property pointers in JavaScript for years now)</source>
          <target state="translated">ä½ è¦åˆ é™¤çš„å¯¹è±¡ç±»å‹èŒƒå›´,ä»¥åŠä½ éœ€è¦çœç•¥çš„å±æ€§åç§°ç±»å‹(åªç”¨å­—ç¬¦ä¸²?ç¬¦å·?ä»ä»»æ„å¯¹è±¡ä¸­æ˜ å°„çš„å¼±å¼•ç”¨?è¿™äº›éƒ½æ˜¯å¤šå¹´æ¥JavaScriptä¸­çš„å±æ€§æŒ‡é’ˆç±»å‹)ã€‚)</target>
        </trans-unit>
        <trans-unit id="3fea2fb86e2276224dff32e33243b1e22287ed2d" translate="yes" xml:space="preserve">
          <source>The reason for writing this new &lt;code&gt;unset&lt;/code&gt; function, is to keep the index of all other variables in this hash_map. Look at the following example, and see how the index of &quot;test2&quot; did not change after removing a value from the hash_map.</source>
          <target state="translated">ç¼–å†™æ­¤æ–°çš„ &lt;code&gt;unset&lt;/code&gt; å‡½æ•°çš„åŸå› æ˜¯å°†æ‰€æœ‰å…¶ä»–å˜é‡çš„ç´¢å¼•ä¿ç•™åœ¨æ­¤hash_mapä¸­ã€‚ æŸ¥çœ‹ä¸‹é¢çš„ç¤ºä¾‹ï¼Œçœ‹çœ‹ä»hash_mapä¸­åˆ é™¤ä¸€ä¸ªå€¼åï¼Œ&amp;ldquo; test2&amp;rdquo;çš„ç´¢å¼•å¦‚ä½•ä¿æŒä¸å˜ã€‚</target>
        </trans-unit>
        <trans-unit id="e16825f749b4e5fb7d1fecf43d4e6b653061e2e8" translate="yes" xml:space="preserve">
          <source>The result would be &lt;code&gt;false&lt;/code&gt;, which means that your delete statement haven't been executed as you expected. But if you had not created that variable before, and you only had &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; as your last existing reference, you could have done this just by removing it like:</source>
          <target state="translated">ç»“æœå°†ä¸º &lt;code&gt;false&lt;/code&gt; ï¼Œè¿™æ„å‘³ç€æ‚¨çš„deleteè¯­å¥æœªæŒ‰é¢„æœŸæ‰§è¡Œã€‚ ä½†æ˜¯ï¼Œå¦‚æœæ‚¨ä»¥å‰æ²¡æœ‰åˆ›å»ºè¿‡è¯¥å˜é‡ï¼Œè€Œä»…ä½¿ç”¨ &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; ä½œä¸ºæœ€åä¸€ä¸ªç°æœ‰å¼•ç”¨ï¼Œåˆ™å¯ä»¥é€šè¿‡åˆ é™¤å®ƒæ¥å®Œæˆæ­¤æ“ä½œï¼Œä¾‹å¦‚ï¼š</target>
        </trans-unit>
        <trans-unit id="f6481accf44872d4ef8745c055193c2829ccd3cb" translate="yes" xml:space="preserve">
          <source>The term you have used in your question title &lt;code&gt;Remove a property from a JavaScript object&lt;/code&gt;, can be interpreted in some different ways. The one is to remove it for whole the memory and the list of object keys or the other is just to remove it from your object. As it has been mentioned in some other answers, the &lt;code&gt;delete&lt;/code&gt; keyword is the main part. Let's say you have your object like:</source>
          <target state="translated">æ‚¨åœ¨é—®é¢˜æ ‡é¢˜ä¸­ä½¿ç”¨çš„æœ¯è¯­ &lt;code&gt;Remove a property from a JavaScript object&lt;/code&gt; å¯ä»¥ç”¨å‡ ç§ä¸åŒçš„æ–¹å¼è§£é‡Šã€‚ ä¸€ç§æ˜¯å°†å…¶æ•´ä¸ªå†…å­˜å’Œå¯¹è±¡é”®åˆ—è¡¨åˆ é™¤ï¼Œå¦ä¸€ç§æ˜¯å°†å…¶ä»å¯¹è±¡ä¸­åˆ é™¤ã€‚ æ­£å¦‚åœ¨å…¶ä»–ä¸€äº›ç­”æ¡ˆä¸­æåˆ°çš„é‚£æ ·ï¼Œ &lt;code&gt;delete&lt;/code&gt; å…³é”®å­—æ˜¯ä¸»è¦éƒ¨åˆ†ã€‚ å‡è®¾æ‚¨æœ‰å¦‚ä¸‹å¯¹è±¡ï¼š</target>
        </trans-unit>
        <trans-unit id="d7c42d645c208dfd4e3c38a50db94ab5a07bdf03" translate="yes" xml:space="preserve">
          <source>The version of ECMAScript you're targeting</source>
          <target state="translated">æ‚¨æ‰€é’ˆå¯¹çš„ECMAScriptçš„ç‰ˆæœ¬</target>
        </trans-unit>
        <trans-unit id="2d17e745883099706ab5b904d19b87cebce1764f" translate="yes" xml:space="preserve">
          <source>Then even if you remove it from your object &lt;code&gt;myJSONObject&lt;/code&gt;, that specific object won't get deleted from the memory, since the &lt;code&gt;regex&lt;/code&gt; variable and &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; still have their values. Then how could we remove the object from the memory for sure?</source>
          <target state="translated">ç„¶åï¼Œå³ä½¿å°†å…¶ä»å¯¹è±¡ &lt;code&gt;myJSONObject&lt;/code&gt; ä¸­åˆ é™¤ï¼Œè¯¥ç‰¹å®šå¯¹è±¡ä¹Ÿä¸ä¼šä»å†…å­˜ä¸­åˆ é™¤ï¼Œå› ä¸º &lt;code&gt;regex&lt;/code&gt; å˜é‡å’Œ &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; ä»ç„¶å…·æœ‰å…¶å€¼ã€‚ é‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•æ‰èƒ½ç¡®å®šä»å†…å­˜ä¸­åˆ é™¤å¯¹è±¡å‘¢ï¼Ÿ</target>
        </trans-unit>
        <trans-unit id="9f315ff9ba259ec4af4aad477da9caf99c783595" translate="yes" xml:space="preserve">
          <source>Then your objects key using &lt;code&gt;Object.keys(myJSONObject)&lt;/code&gt; would be:</source>
          <target state="translated">ç„¶åï¼Œä½¿ç”¨ &lt;code&gt;Object.keys(myJSONObject)&lt;/code&gt; çš„å¯¹è±¡é”®å°†æ˜¯ï¼š</target>
        </trans-unit>
        <trans-unit id="950ba1d1f6aad6e3258d15bc7f08a5e034f6a816" translate="yes" xml:space="preserve">
          <source>There are a lot of good answers here but I just want to chime in that when using delete to remove a property in JavaScript, it is often wise to first check if that property exists to prevent errors.</source>
          <target state="translated">è¿™é‡Œæœ‰å¾ˆå¤šå¥½çš„ç­”æ¡ˆ,ä½†æˆ‘åªæƒ³è¯´,åœ¨ä½¿ç”¨deleteæ¥åˆ é™¤JavaScriptä¸­çš„ä¸€ä¸ªå±æ€§æ—¶,é€šå¸¸æ˜æ™ºçš„åšæ³•æ˜¯é¦–å…ˆæ£€æŸ¥è¯¥å±æ€§æ˜¯å¦å­˜åœ¨,ä»¥é˜²æ­¢é”™è¯¯ã€‚</target>
        </trans-unit>
        <trans-unit id="57100a7adc73f2ac8fb1259dcb31d2cae8056822" translate="yes" xml:space="preserve">
          <source>There are few common ways to remove a property from an object.</source>
          <target state="translated">ä»å¯¹è±¡ä¸­åˆ é™¤å±æ€§çš„å¸¸è§æ–¹æ³•ä¸å¤šã€‚</target>
        </trans-unit>
        <trans-unit id="8604def9bd3e30573031d5be629fb2bb0c18ca39" translate="yes" xml:space="preserve">
          <source>There are many different options presented on this page, not because most of the options are wrong&amp;mdash;or because the answers are duplicates&amp;mdash;but because the appropriate technique depends on the situation you're in and the goals of the tasks you and/or you team are trying to fulfill. To answer you question unequivocally, one needs to know:</source>
          <target state="translated">æ­¤é¡µé¢ä¸Šæä¾›äº†è®¸å¤šä¸åŒçš„é€‰é¡¹ï¼Œä¸æ˜¯å› ä¸ºå¤§å¤šæ•°é€‰é¡¹æ˜¯é”™è¯¯çš„ï¼Œæˆ–è€…ä¸æ˜¯ç­”æ¡ˆæ˜¯é‡å¤çš„ï¼Œè€Œæ˜¯å› ä¸ºé€‚å½“çš„æŠ€æœ¯å–å†³äºæ‚¨æ‰€å¤„çš„æƒ…å†µä»¥åŠæ‚¨å’Œ/æˆ–æ‚¨çš„ä»»åŠ¡ç›®æ ‡å›¢é˜Ÿæ­£åœ¨åŠªåŠ›å®ç°ã€‚ è¦æ˜ç¡®å›ç­”æ‚¨çš„é—®é¢˜ï¼Œæ‚¨éœ€è¦çŸ¥é“ï¼š</target>
        </trans-unit>
        <trans-unit id="5f1efa2f9fb405d638f74fe5349dbabb89e0514a" translate="yes" xml:space="preserve">
          <source>They are slow &amp;amp; memory inefficient. When accessing a specific index, instead of just getting the global type for the array, the browser instead has to get the type on a per-index basis whereby each index stores the additional metadata of its type.</source>
          <target state="translated">å®ƒä»¬é€Ÿåº¦æ…¢ä¸”å†…å­˜æ•ˆç‡ä½ä¸‹ã€‚ å½“è®¿é—®ç‰¹å®šç´¢å¼•æ—¶ï¼Œæµè§ˆå™¨å¿…é¡»è·å–æ¯ä¸ªç´¢å¼•çš„ç±»å‹ï¼Œè€Œä¸æ˜¯ä»…è·å–æ•°ç»„çš„å…¨å±€ç±»å‹ï¼Œè€Œå¿…é¡»æŒ‰æ¯ä¸ªç´¢å¼•è·å–ç±»å‹ã€‚</target>
        </trans-unit>
        <trans-unit id="afa3b2f30890db447e4cf00d9f2dcec7b332b01b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;ES6&lt;/code&gt; operator allows us to return a brand new object, excluding any properties, without mutating the existing object. The downside is that it has the worse performance out of the above and not suggested to be used when you need to remove many properties at a time.</source>
          <target state="translated">è¯¥ &lt;code&gt;ES6&lt;/code&gt; è¿ç®—ç¬¦å…è®¸æˆ‘ä»¬è¿”å›ä¸€ä¸ªå…¨æ–°çš„å¯¹è±¡ï¼ˆä¸åŒ…æ‹¬ä»»ä½•å±æ€§ï¼‰ï¼Œè€Œæ— éœ€æ›´æ”¹ç°æœ‰å¯¹è±¡ã€‚ ä¸åˆ©çš„ä¸€é¢æ˜¯ï¼Œå®ƒçš„æ€§èƒ½æ¯”ä»¥ä¸Šæ›´å·®ï¼Œå› æ­¤å½“æ‚¨éœ€è¦ä¸€æ¬¡åˆ é™¤è®¸å¤šå±æ€§æ—¶ï¼Œå»ºè®®ä¸è¦ä½¿ç”¨å®ƒã€‚</target>
        </trans-unit>
        <trans-unit id="9e7248bc6c7cf17aeb43a8906d8cc8e3b531512b" translate="yes" xml:space="preserve">
          <source>This alternative is not the correct answer to this question! But, if you use it with care, you can dramatically speed up some algorithms. If you are using &lt;code&gt;delete&lt;/code&gt; in loops and you have problems with performance, read the verbose explanation.</source>
          <target state="translated">æ­¤æ›¿ä»£æ–¹æ³•ä¸æ˜¯æ­¤é—®é¢˜çš„æ­£ç¡®ç­”æ¡ˆï¼ ä½†æ˜¯ï¼Œå¦‚æœè°¨æ…ä½¿ç”¨å®ƒï¼Œåˆ™å¯ä»¥å¤§å¤§åŠ å¿«æŸäº›ç®—æ³•çš„é€Ÿåº¦ã€‚ å¦‚æœæ‚¨æ­£åœ¨ä½¿ç”¨ &lt;code&gt;delete&lt;/code&gt; inå¾ªç¯ï¼Œå¹¶ä¸”åœ¨æ€§èƒ½æ–¹é¢é‡åˆ°é—®é¢˜ï¼Œè¯·é˜…è¯»è¯¦ç»†è¯´æ˜ã€‚</target>
        </trans-unit>
        <trans-unit id="d2696a11c056f55fc8c70ea4ff94e4f5922248e1" translate="yes" xml:space="preserve">
          <source>This category is for operating on object literals or object instances when you want to retain/continue to use the original reference and aren't using stateless functional principles in your code. An example piece of syntax in this category:</source>
          <target state="translated">è¿™ä¸€ç±»æ˜¯ç”¨äºåœ¨å¯¹è±¡å­—é¢æˆ–å¯¹è±¡å®ä¾‹ä¸Šè¿›è¡Œæ“ä½œ,å½“ä½ æƒ³ä¿ç•™ç»§ç»­ä½¿ç”¨åŸå§‹å¼•ç”¨,å¹¶ä¸”åœ¨ä½ çš„ä»£ç ä¸­ä¸ä½¿ç”¨æ— çŠ¶æ€åŠŸèƒ½åŸç†æ—¶ã€‚è¿™ä¸ªç±»åˆ«ä¸­çš„ä¸€ä¸ªè¯­æ³•ä¾‹å­ã€‚</target>
        </trans-unit>
        <trans-unit id="1f8c0c20dd501470cb117b73c855e583ae2e0193" translate="yes" xml:space="preserve">
          <source>This category is for operating on object literals or object instances when you want to retain/continue to use the original reference while guarding against exceptions being thrown on unconfigurable properties:</source>
          <target state="translated">è¿™ä¸ªç±»åˆ«ç”¨äºåœ¨å¯¹è±¡å­—é¢ç¬¦å·æˆ–å¯¹è±¡å®ä¾‹ä¸Šè¿›è¡Œæ“ä½œ,å½“ä½ æƒ³ä¿ç•™ç»§ç»­ä½¿ç”¨åŸå§‹å¼•ç”¨,åŒæ—¶é˜²æ­¢åœ¨ä¸å¯é…ç½®çš„å±æ€§ä¸ŠæŠ›å‡ºå¼‚å¸¸ã€‚</target>
        </trans-unit>
        <trans-unit id="94bdb987c00caa2e598854f97ea3c6de4e30eedf" translate="yes" xml:space="preserve">
          <source>This category is for operating on plain object or array instances in newer ECMAScript flavors when a non-mutative approach is desired and you don't need to account for Symbol keys:</source>
          <target state="translated">è¿™ä¸ªç±»åˆ«é€‚ç”¨äºåœ¨è¾ƒæ–°çš„ECMAScripté£æ ¼ä¸­çš„çº¯å¯¹è±¡æˆ–æ•°ç»„å®ä¾‹ä¸Šè¿›è¡Œæ“ä½œ,å½“ä½ éœ€è¦ä½¿ç”¨éäº’æ¢çš„æ–¹æ³•,å¹¶ä¸”ä¸éœ€è¦è€ƒè™‘åˆ°ç¬¦å·é”®ã€‚</target>
        </trans-unit>
        <trans-unit id="aba34382b27aca74b69be04c741119ab744a49b9" translate="yes" xml:space="preserve">
          <source>This category is generally allows for greater functional flexibility, including accounting for Symbols &amp;amp; omitting more than one property in one statement:</source>
          <target state="translated">é€šå¸¸ï¼Œæ­¤ç±»åˆ«å¯æä¾›æ›´å¤§çš„åŠŸèƒ½çµæ´»æ€§ï¼ŒåŒ…æ‹¬è€ƒè™‘ç¬¦å·å¹¶åœ¨ä¸€ä¸ªè¯­å¥ä¸­çœç•¥å¤šä¸ªå±æ€§ï¼š</target>
        </trans-unit>
        <trans-unit id="17ff7f9c0c298023ffef1288d23c2efc74ebdf5c" translate="yes" xml:space="preserve">
          <source>This category is the oldest, most straightforward &amp;amp; most widely supported category of property removal. It supports &lt;code&gt;Symbol&lt;/code&gt; &amp;amp; array indexes in addition to strings and works in every version of JavaScript except for the very first release. However, it's mutative which violates some programming principles and has performance implications. It also can result in uncaught exceptions when used on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;non-configurable properties in strict mode&lt;/a&gt;.</source>
          <target state="translated">æ­¤ç±»åˆ«æ˜¯å±æ€§åˆ é™¤çš„æœ€å¤è€ï¼Œæœ€ç›´æ¥å’Œæœ€å¹¿æ³›æ”¯æŒçš„ç±»åˆ«ã€‚ é™¤å­—ç¬¦ä¸²å¤–ï¼Œå®ƒè¿˜æ”¯æŒ &lt;code&gt;Symbol&lt;/code&gt; å’Œæ•°ç»„ç´¢å¼•ï¼Œå¹¶ä¸”é™¤äº†ç¬¬ä¸€ä¸ªå‘è¡Œç‰ˆä»¥å¤–ï¼Œå®ƒéƒ½å¯ä»¥åœ¨æ‰€æœ‰JavaScriptç‰ˆæœ¬ä¸­ä½¿ç”¨ã€‚ ä½†æ˜¯ï¼Œå®ƒæ˜¯å˜å¼‚çš„ï¼Œå®ƒè¿åäº†ä¸€äº›ç¼–ç¨‹åŸåˆ™ï¼Œå¹¶ä¸”å¯¹æ€§èƒ½æœ‰å½±å“ã€‚ &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;åœ¨ä¸¥æ ¼æ¨¡å¼ä¸‹&lt;/a&gt;åœ¨ä¸å¯é…ç½®çš„å±æ€§ä¸Šä½¿ç”¨æ—¶ï¼Œä¹Ÿä¼šå¯¼è‡´æœªæ•è·çš„å¼‚å¸¸ã€‚</target>
        </trans-unit>
        <trans-unit id="4ad77472ac7767c23050851eada92d065c2bd943" translate="yes" xml:space="preserve">
          <source>This is in regard to this (now-removed) snippet:</source>
          <target state="translated">è¿™æ˜¯å…³äºè¿™ä¸ª(ç°å·²åˆ é™¤çš„)ç‰‡æ®µã€‚</target>
        </trans-unit>
        <trans-unit id="21292c660408d1ff92d4a1c2c4eafdd76c276e51" translate="yes" xml:space="preserve">
          <source>This post is very old and I find it very helpful so I decided to share the unset function I wrote in case someone else see this post and think why it's not so simple as it in PHP unset function.</source>
          <target state="translated">è¿™ä¸ªå¸–å­å¾ˆè€,æˆ‘è§‰å¾—å¾ˆæœ‰å¸®åŠ©,æ‰€ä»¥æˆ‘å†³å®šåˆ†äº«ä¸€ä¸‹æˆ‘å†™çš„ unset å‡½æ•°,ä»¥é˜²åˆ«äººçœ‹åˆ°è¿™ä¸ªå¸–å­å,è§‰å¾—ä¸ºä»€ä¹ˆåœ¨ PHP unset å‡½æ•°ä¸­æ²¡æœ‰é‚£ä¹ˆç®€å•ã€‚</target>
        </trans-unit>
        <trans-unit id="9603916ceb02f62ecad35613c65fb5ceed83b60d" translate="yes" xml:space="preserve">
          <source>This works in Firefox and Internet&amp;nbsp;Explorer, and I think it works in all others.</source>
          <target state="translated">è¿™é€‚ç”¨äºFirefoxå’ŒInternet Explorerï¼Œæˆ‘è®¤ä¸ºå®ƒé€‚ç”¨äºæ‰€æœ‰å…¶ä»–äº§å“ã€‚</target>
        </trans-unit>
        <trans-unit id="c685cc94e2b05416a2b9215116753bb12c7af729" translate="yes" xml:space="preserve">
          <source>To complete @Koen answer in this thread, in case you want to remove dynamic variable using the spread syntax, you can do it like so:</source>
          <target state="translated">ä¸ºäº†å®Œæˆ@Koenåœ¨è¿™ä¸ªçº¿ç¨‹ä¸­çš„å›ç­”,å¦‚æœä½ æƒ³ç”¨spreadè¯­æ³•åˆ é™¤åŠ¨æ€å˜é‡,ä½ å¯ä»¥è¿™æ ·åšã€‚</target>
        </trans-unit>
        <trans-unit id="a792292997434d58f8b1d7da4af78863ac5e4684" translate="yes" xml:space="preserve">
          <source>To get more info on &lt;code&gt;Object.seal&lt;/code&gt;: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal&quot;&gt;Object.seal()&lt;/a&gt;</source>
          <target state="translated">è¦è·å–æœ‰å…³ &lt;code&gt;Object.seal&lt;/code&gt; çš„æ›´å¤šä¿¡æ¯ï¼š &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal&quot;&gt;Object.sealï¼ˆï¼‰&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96589c0ac9acf3a6b58f6928336639e582088ee3" translate="yes" xml:space="preserve">
          <source>To reassign to the same variable, use a &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">è¦é‡æ–°åˆ†é…ç»™åŒä¸€å˜é‡ï¼Œè¯·ä½¿ç”¨ &lt;code&gt;let&lt;/code&gt; ï¼š</target>
        </trans-unit>
        <trans-unit id="21af806df3feb60911002a77c4380b2b484f7bbf" translate="yes" xml:space="preserve">
          <source>To remove any property, say &lt;code&gt;key1&lt;/code&gt;, use the &lt;code&gt;delete&lt;/code&gt; keyword like this:</source>
          <target state="translated">è¦åˆ é™¤ä»»ä½•å±æ€§ï¼Œä¾‹å¦‚ &lt;code&gt;key1&lt;/code&gt; ï¼Œè¯·ä½¿ç”¨ &lt;code&gt;delete&lt;/code&gt; å…³é”®å­—ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</target>
        </trans-unit>
        <trans-unit id="fa15c129befde7656ac754122a25210685ef2188" translate="yes" xml:space="preserve">
          <source>To summarize, differences are all about ways of determining the property existence, and about &lt;code&gt;for..in&lt;/code&gt; loop.</source>
          <target state="translated">æ€»è€Œè¨€ä¹‹ï¼Œå·®å¼‚éƒ½æ˜¯å…³äºç¡®å®šå±æ€§å­˜åœ¨çš„æ–¹å¼ä»¥åŠ &lt;code&gt;for..in&lt;/code&gt; å¾ªç¯çš„ã€‚</target>
        </trans-unit>
        <trans-unit id="87501fb0e92ec552bdf306c07f48852286e9c8c8" translate="yes" xml:space="preserve">
          <source>To whoever needs it...</source>
          <target state="translated">ç»™éœ€è¦å®ƒçš„äºº.....</target>
        </trans-unit>
        <trans-unit id="b7ff74710b25d787ff3d518b1667a655a5936c78" translate="yes" xml:space="preserve">
          <source>Try the following method. Assign the &lt;code&gt;Object&lt;/code&gt; property value to &lt;code&gt;undefined&lt;/code&gt;. Then &lt;code&gt;stringify&lt;/code&gt; the object and &lt;code&gt;parse&lt;/code&gt;.</source>
          <target state="translated">è¯·å°è¯•ä»¥ä¸‹æ–¹æ³•ã€‚ å°† &lt;code&gt;Object&lt;/code&gt; å±æ€§å€¼åˆ†é…ç»™ &lt;code&gt;undefined&lt;/code&gt; ã€‚ ç„¶åå°†å¯¹è±¡ &lt;code&gt;stringify&lt;/code&gt; å¹¶ &lt;code&gt;parse&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="3d82a9f15156c36519fc72f9af221c32d7422e29" translate="yes" xml:space="preserve">
          <source>Try this</source>
          <target state="translated">è¯•è¯•è¿™ä¸ª</target>
        </trans-unit>
        <trans-unit id="828f97e6c91f157ecd45fc8183a07ca7b4e95e6f" translate="yes" xml:space="preserve">
          <source>Update regarding &lt;code&gt;is_array()&lt;/code&gt;</source>
          <target state="translated">æœ‰å…³ &lt;code&gt;is_array()&lt;/code&gt; çš„æ›´æ–°</target>
        </trans-unit>
        <trans-unit id="d45aa1f9d8100f951a216d7ce715ec8d99477eb3" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://ramdajs.com/docs/#dissoc&quot;&gt;ramda#dissoc&lt;/a&gt; you will get a new object without the attribute &lt;code&gt;regex&lt;/code&gt;:</source>
          <target state="translated">ä½¿ç”¨&lt;a href=&quot;http://ramdajs.com/docs/#dissoc&quot;&gt;ramdaï¼ƒdissocï¼Œ&lt;/a&gt;æ‚¨å°†è·å¾—ä¸€ä¸ªä¸å¸¦ &lt;code&gt;regex&lt;/code&gt; å±æ€§çš„æ–°å¯¹è±¡ï¼š</target>
        </trans-unit>
        <trans-unit id="930151a2e26bf074e4b81d244de5799b750be707" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;delete&lt;/strong&gt; method is the best way to do that, as per MDN description, the delete operator removes a property from an object. So you can simply write:</source>
          <target state="translated">ä½¿ç”¨&lt;strong&gt;åˆ é™¤&lt;/strong&gt;æ–¹æ³•æ˜¯æœ€å¥½çš„æ–¹æ³•ï¼Œæ ¹æ®MDNæè¿°ï¼Œåˆ é™¤è¿ç®—ç¬¦å°†ä»å¯¹è±¡ä¸­åˆ é™¤å±æ€§ã€‚ æ‰€ä»¥ä½ å¯ä»¥ç®€å•åœ°å†™ï¼š</target>
        </trans-unit>
        <trans-unit id="855d634ee489e4e0a2c811671f665628a0a0df6f" translate="yes" xml:space="preserve">
          <source>Using ES6:</source>
          <target state="translated">ä½¿ç”¨ES6ã€‚</target>
        </trans-unit>
        <trans-unit id="9fb406e463a70799e2a3db3cb0956dde6058516c" translate="yes" xml:space="preserve">
          <source>Using this method, not all &lt;a href=&quot;https://stackoverflow.com/questions/1894792/determining-if-a-javascript-object-has-a-given-property&quot;&gt;ways of determining property existence&lt;/a&gt; will work as expected.</source>
          <target state="translated">ä½¿ç”¨æ­¤æ–¹æ³•ï¼Œå¹¶éæ‰€æœ‰&lt;a href=&quot;https://stackoverflow.com/questions/1894792/determining-if-a-javascript-object-has-a-given-property&quot;&gt;ç¡®å®šå±æ€§å­˜åœ¨çš„æ–¹æ³•&lt;/a&gt;éƒ½å¯ä»¥æŒ‰é¢„æœŸå·¥ä½œã€‚</target>
        </trans-unit>
        <trans-unit id="7d56ccd01dc2c25715aa91cc5c3b3239162d1db4" translate="yes" xml:space="preserve">
          <source>What follows is a contrived scenario that gets pretty long-winded, so you can skip to the section, &lt;strong&gt;The Solution&lt;/strong&gt;, if you want. The only reason I leave this section it is that I think some people probably think it's funny, and I don't want to be &quot;that guy&quot; who posts a &quot;funny&quot; answer and then deletes all the &quot;funny&quot; from it later on.</source>
          <target state="translated">æ¥ä¸‹æ¥æ˜¯ä¸€ä¸ªäººä¸ºscenarioç»•çš„äººä¸ºåœºæ™¯ï¼Œå› æ­¤ï¼Œå¦‚æœéœ€è¦ï¼Œæ‚¨å¯ä»¥è·³è‡³&lt;strong&gt;&amp;ldquo;è§£å†³æ–¹æ¡ˆ&lt;/strong&gt; &amp;rdquo;éƒ¨åˆ†ã€‚ æˆ‘ç¦»å¼€æœ¬èŠ‚çš„å”¯ä¸€åŸå› æ˜¯ï¼Œæˆ‘è®¤ä¸ºæœ‰äº›äººå¯èƒ½è®¤ä¸ºè¿™å¾ˆæœ‰è¶£ï¼Œå¹¶ä¸”æˆ‘ä¸æƒ³æˆä¸ºå‘å¸ƒ&amp;ldquo;æç¬‘&amp;rdquo;ç­”æ¡ˆç„¶åç¨åå°†å…¶åˆ é™¤çš„æ‰€æœ‰&amp;ldquo;æç¬‘&amp;rdquo;å®¶ä¼™ã€‚ ã€‚</target>
        </trans-unit>
        <trans-unit id="e8a0f3d5fef79ddff6c740f20faf1841e9c8a913" translate="yes" xml:space="preserve">
          <source>What is the best way to remove the property &lt;code&gt;regex&lt;/code&gt; to end up with new &lt;code&gt;myObject&lt;/code&gt; as follows?</source>
          <target state="translated">åˆ é™¤å±æ€§ &lt;code&gt;regex&lt;/code&gt; ä»¥äº§ç”Ÿæ–°çš„ &lt;code&gt;myObject&lt;/code&gt; çš„æœ€ä½³æ–¹æ³•æ˜¯ä»€ä¹ˆï¼Ÿ</target>
        </trans-unit>
        <trans-unit id="269ad8f4ba0c959d755966ae84263f7c06ef0a98" translate="yes" xml:space="preserve">
          <source>When should one use &lt;code&gt;delete&lt;/code&gt; and when set value to &lt;code&gt;undefined&lt;/code&gt; ?</source>
          <target state="translated">ä»€ä¹ˆæ—¶å€™åº”è¯¥ä½¿ç”¨ &lt;code&gt;delete&lt;/code&gt; å’Œä½•æ—¶å°†å€¼è®¾ç½®ä¸º &lt;code&gt;undefined&lt;/code&gt; ï¼Ÿ</target>
        </trans-unit>
        <trans-unit id="f73054e5169db0bc5c2ed5932270c4a709d901aa" translate="yes" xml:space="preserve">
          <source>When using a Symbol, wait, why are you using a Symbol?!?! Symbols are bad  juju for performance. Everything programmed to use Symbols can be reprogrammed to not use Symbols, resulting in a faster code without Symbols. Symbols are really just super inefficient meta-sugar.</source>
          <target state="translated">ä½¿ç”¨ç¬¦å·çš„æ—¶å€™,ç­‰ç­‰,ä½ ä¸ºä»€ä¹ˆè¦ç”¨ç¬¦å·?ç¬¦å·å¯¹æ€§èƒ½çš„å½±å“æ˜¯å¾ˆç³Ÿç³•çš„ã€‚æ‰€æœ‰è¢«ç¼–ç¨‹ä¸ºä½¿ç”¨Symbolsçš„ä¸œè¥¿éƒ½å¯ä»¥è¢«é‡æ–°ç¼–ç¨‹ä¸ºä¸ä½¿ç”¨Symbols,ç»“æœæ˜¯æ²¡æœ‰Symbolsçš„ä»£ç é€Ÿåº¦æ›´å¿«ã€‚ç¬¦å·çœŸçš„åªæ˜¯è¶…çº§ä½æ•ˆçš„å…ƒç³–ã€‚</target>
        </trans-unit>
        <trans-unit id="602ae3083b5ceb94cfa5bb3b6f0e1f19f1f16418" translate="yes" xml:space="preserve">
          <source>When using an array/variable typed to the boolean primitive, use either &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; as the empty value. While avoiding unnecessary polymorphism is good, rewriting all your code to explicitly forbid it will likely actually result in a decrease in performance. Use common judgement!</source>
          <target state="translated">å½“ä½¿ç”¨ç±»å‹ä¸ºå¸ƒå°”åŸºå…ƒçš„æ•°ç»„/å˜é‡æ—¶ï¼Œè¯·ä½¿ç”¨ &lt;code&gt;false&lt;/code&gt; æˆ– &lt;code&gt;undefined&lt;/code&gt; ä½œä¸ºç©ºå€¼ã€‚ è™½ç„¶é¿å…ä¸å¿…è¦çš„å¤šæ€æ€§æ˜¯å¥½çš„ï¼Œä½†æ˜¯é‡å†™æ‰€æœ‰ä»£ç ä»¥æ˜ç¡®ç¦æ­¢å®ƒå¯èƒ½å®é™…ä¸Šä¼šå¯¼è‡´æ€§èƒ½ä¸‹é™ã€‚ ä½¿ç”¨å…±åŒçš„åˆ¤æ–­ï¼</target>
        </trans-unit>
        <trans-unit id="97e2c329b633d1758a70203709d67ea5a41bbc86" translate="yes" xml:space="preserve">
          <source>When using an array/variable typed to the number primitive, use &lt;code&gt;0&lt;/code&gt; as the empty value. Note that internally, there are two types of numbers: fast integers (2147483647 to -2147483648 inclusive) and slow floating point doubles (anything other than that including &lt;code&gt;NaN&lt;/code&gt; and &lt;code&gt;Infinity&lt;/code&gt;). When an integer is demoted to a double, it cannot be promoted back to an integer.</source>
          <target state="translated">ä½¿ç”¨ç±»å‹ä¸ºæ•°å­—åŸºå…ƒçš„æ•°ç»„/å˜é‡æ—¶ï¼Œè¯·ä½¿ç”¨ &lt;code&gt;0&lt;/code&gt; ä½œä¸ºç©ºå€¼ã€‚ è¯·æ³¨æ„ï¼Œå†…éƒ¨æœ‰ä¸¤ç§ç±»å‹çš„æ•°å­—ï¼šå¿«é€Ÿæ•´æ•°ï¼ˆåŒ…æ‹¬2147483647è‡³-2147483648ï¼‰å’Œæ…¢é€Ÿæµ®ç‚¹åŒç²¾åº¦ï¼ˆé™¤ &lt;code&gt;NaN&lt;/code&gt; å’Œ &lt;code&gt;Infinity&lt;/code&gt; ä¹‹å¤–çš„ä»»ä½•æ•°å­—ï¼‰ã€‚ å½“æ•´æ•°é™ä¸ºåŒç²¾åº¦æ•´æ•°æ—¶ï¼Œä¸èƒ½å°†å…¶æå‡å›æ•´æ•°ã€‚</target>
        </trans-unit>
        <trans-unit id="363e06ebcbb46e5d020be755b34062c111648564" translate="yes" xml:space="preserve">
          <source>When using an array/variable typed to the string primitive, use &lt;code&gt;&quot;&quot;&lt;/code&gt; as the empty value.</source>
          <target state="translated">å½“ä½¿ç”¨ç±»å‹ä¸ºå­—ç¬¦ä¸²åŸºå…ƒçš„æ•°ç»„/å˜é‡æ—¶ï¼Œè¯·ä½¿ç”¨ &lt;code&gt;&quot;&quot;&lt;/code&gt; ä½œä¸ºç©ºå€¼ã€‚</target>
        </trans-unit>
        <trans-unit id="2daf2d7377c143fd1982ce05f553ab2ba4bd19a7" translate="yes" xml:space="preserve">
          <source>When using anything else, use &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">ä½¿ç”¨å…¶ä»–ä»»ä½•ä¸œè¥¿æ—¶ï¼Œè¯·ä½¿ç”¨ &lt;code&gt;null&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="99129be375514e4d040c762996086e2002e66f2e" translate="yes" xml:space="preserve">
          <source>Which is a terrible justification for getting rid of the &lt;code&gt;null&lt;/code&gt;s--&lt;code&gt;null&lt;/code&gt; is only dangerous if used improperly, and it has nothing to do with &quot;precision&quot;. The real reason you shouldn't &lt;code&gt;delete&lt;/code&gt; from an array is that leaving garbage-filled and messy data structures around is sloppy and bug-prone.</source>
          <target state="translated">è¿™æ˜¯æ‘†è„± &lt;code&gt;null&lt;/code&gt; çš„å¯æ€•ç†ç”±-nullä»…åœ¨ä½¿ç”¨ä¸å½“çš„æƒ…å†µä¸‹æ‰æ˜¯å±é™©çš„ï¼Œå¹¶ä¸”ä¸&amp;ldquo;ç²¾åº¦&amp;rdquo;æ— å…³ã€‚ æ‚¨ä¸åº”è¯¥ä»æ•°ç»„ä¸­ &lt;code&gt;delete&lt;/code&gt; çš„çœŸæ­£åŸå› æ˜¯ï¼Œå‘¨å›´ä¹±ä¸ƒå…«ç³Ÿçš„æ•°æ®ç»“æ„å¾ˆä¹±è€Œä¸”å®¹æ˜“å‡ºé”™ã€‚</target>
        </trans-unit>
        <trans-unit id="1f5947457b95655f5329f1cfd08d1b56c64dd6e7" translate="yes" xml:space="preserve">
          <source>Which means in this case you won't be able to remove that object because you have created the &lt;code&gt;regex&lt;/code&gt; variable via a &lt;code&gt;var&lt;/code&gt; statement, and if you do:</source>
          <target state="translated">è¿™æ„å‘³ç€åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‚¨å°†æ— æ³•åˆ é™¤è¯¥å¯¹è±¡ï¼Œå› ä¸ºå·²ç»é€šè¿‡ &lt;code&gt;var&lt;/code&gt; è¯­å¥åˆ›å»ºäº† &lt;code&gt;regex&lt;/code&gt; å˜é‡ï¼Œå¹¶ä¸”å¦‚æœè¿™æ ·åšäº†ï¼š</target>
        </trans-unit>
        <trans-unit id="4f17f120087f0ca40e417b064249125802d82ec5" translate="yes" xml:space="preserve">
          <source>While using &lt;code&gt;obj[prop] = undefined&lt;/code&gt; is faster than doing &lt;code&gt;delete obj[prop]&lt;/code&gt;, another important consideration is that &lt;code&gt;obj[prop] = undefined&lt;/code&gt; may not always be appropriate. &lt;code&gt;delete obj[prop]&lt;/code&gt; removes &lt;code&gt;prop&lt;/code&gt; from &lt;code&gt;obj&lt;/code&gt; and erases it from memory whereas &lt;code&gt;obj[prop] = undefined&lt;/code&gt; simply sets the value of &lt;code&gt;prop&lt;/code&gt; to &lt;code&gt;undefined&lt;/code&gt; which leaves &lt;code&gt;prop&lt;/code&gt; still in memory. Therefore, in circumstances where there are many keys being created and deleted, using &lt;code&gt;obj[prop] = undefined&lt;/code&gt; can force expensive memory reconciliation (causing the page to freeze up) and potentially an out-of-memory error. Examine the following code.</source>
          <target state="translated">å°½ç®¡ä½¿ç”¨ &lt;code&gt;obj[prop] = undefined&lt;/code&gt; æ¯” &lt;code&gt;delete obj[prop]&lt;/code&gt; å¿«ï¼Œä½†å¦ä¸€ä¸ªé‡è¦çš„è€ƒè™‘å› ç´ æ˜¯ &lt;code&gt;obj[prop] = undefined&lt;/code&gt; å¯èƒ½å¹¶ä¸æ€»æ˜¯åˆé€‚çš„ã€‚ &lt;code&gt;delete obj[prop]&lt;/code&gt; ä» &lt;code&gt;obj&lt;/code&gt; ä¸­åˆ é™¤ &lt;code&gt;prop&lt;/code&gt; å¹¶å°†å…¶ä»å†…å­˜ä¸­åˆ é™¤ï¼Œè€Œ &lt;code&gt;obj[prop] = undefined&lt;/code&gt; åªæ˜¯å°† &lt;code&gt;prop&lt;/code&gt; çš„å€¼è®¾ç½®ä¸º &lt;code&gt;undefined&lt;/code&gt; ï¼Œä»è€Œä½¿ &lt;code&gt;prop&lt;/code&gt; ä»ä¿ç•™åœ¨å†…å­˜ä¸­ã€‚ å› æ­¤ï¼Œåœ¨åˆ›å»ºå’Œåˆ é™¤è®¸å¤šé”®çš„æƒ…å†µä¸‹ï¼Œä½¿ç”¨ &lt;code&gt;obj[prop] = undefined&lt;/code&gt; å¯èƒ½ä¼šå¼ºåˆ¶è¿›è¡Œæ˜‚è´µçš„å†…å­˜åè°ƒï¼ˆå¯¼è‡´é¡µé¢å†»ç»“ï¼‰ï¼Œå¹¶å¯èƒ½å¯¼è‡´å†…å­˜ä¸è¶³é”™è¯¯ã€‚ æ£€æŸ¥ä»¥ä¸‹ä»£ç ã€‚</target>
        </trans-unit>
        <trans-unit id="9fc668854fffc36979144c2d4415e9f9721712c0" translate="yes" xml:space="preserve">
          <source>While you technically can use &lt;code&gt;delete&lt;/code&gt; for an array, using it would result in getting incorrect results when calling for example &lt;code&gt;Hogwarts.staff.length&lt;/code&gt; later on. In other words, &lt;code&gt;delete&lt;/code&gt; would remove the element, but it wouldn't update the value of &lt;code&gt;length&lt;/code&gt; property. Using &lt;code&gt;delete&lt;/code&gt; would also mess up your indexing.</source>
          <target state="translated">ä»æŠ€æœ¯ä¸Šè®²ï¼Œæ‚¨å¯ä»¥å¯¹æ•°ç»„ä½¿ç”¨ &lt;code&gt;delete&lt;/code&gt; ï¼Œä½†æ˜¯ç¨åä½¿ç”¨å®ƒä¼šå¯¼è‡´åœ¨è°ƒç”¨ä¾‹å¦‚ &lt;code&gt;Hogwarts.staff.length&lt;/code&gt; æ—¶å¾—åˆ°ä¸æ­£ç¡®çš„ç»“æœã€‚ æ¢å¥è¯è¯´ï¼Œ &lt;code&gt;delete&lt;/code&gt; ä¼šåˆ é™¤è¯¥å…ƒç´ ï¼Œä½†ä¸ä¼šæ›´æ–° &lt;code&gt;length&lt;/code&gt; å±æ€§çš„å€¼ã€‚ ä½¿ç”¨ &lt;code&gt;delete&lt;/code&gt; ä¹Ÿä¼šä½¿æ‚¨çš„ç´¢å¼•æ··ä¹±ã€‚</target>
        </trans-unit>
        <trans-unit id="4be2ecd11ba0e212cafbe9f3ed4567f70ea3cc57" translate="yes" xml:space="preserve">
          <source>Yeah, that's definitely not what you wanted.</source>
          <target state="translated">æ˜¯å•Š,è¿™ç»å¯¹ä¸æ˜¯ä½ æƒ³è¦çš„ã€‚</target>
        </trans-unit>
        <trans-unit id="02c5f4541ba087fe996da9eb1271ebfb81156d83" translate="yes" xml:space="preserve">
          <source>You can also use other functions to achieve the same effect - omit, pick, ...</source>
          <target state="translated">ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨å…¶ä»–åŠŸèƒ½æ¥è¾¾åˆ°åŒæ ·çš„æ•ˆæœ--çœç•¥ã€æ‘˜å–ã€.....</target>
        </trans-unit>
        <trans-unit id="95e9a3221d0ebd0cc77f374d7ddfa95d905aef6a" translate="yes" xml:space="preserve">
          <source>You can delete that specific key from your object keys like:</source>
          <target state="translated">ä½ å¯ä»¥åƒè¿™æ ·ä»ä½ çš„å¯¹è±¡é”®ä¸­åˆ é™¤é‚£ä¸ªç‰¹å®šçš„é”®ã€‚</target>
        </trans-unit>
        <trans-unit id="df5ae996f80ec18df6459baf979a058b543794dd" translate="yes" xml:space="preserve">
          <source>You can see it in action in the Babel try-out editor.</source>
          <target state="translated">ä½ å¯ä»¥åœ¨Babelè¯•ç”¨ç¼–è¾‘å™¨ä¸­çœ‹åˆ°å®ƒçš„åŠ¨ä½œã€‚</target>
        </trans-unit>
        <trans-unit id="ba4ef71e846efa414e359524a525c5bda890d6bb" translate="yes" xml:space="preserve">
          <source>You can simply delete any property of an object using the &lt;code&gt;delete&lt;/code&gt; keyword.</source>
          <target state="translated">æ‚¨å¯ä»¥ç®€å•åœ°ä½¿ç”¨ &lt;code&gt;delete&lt;/code&gt; å…³é”®å­—åˆ é™¤å¯¹è±¡çš„ä»»ä½•å±æ€§ã€‚</target>
        </trans-unit>
        <trans-unit id="6902cdb7c6341debc4ec1b8c5eaf6794e483c684" translate="yes" xml:space="preserve">
          <source>You can use ES6 destructuring with rest operator.</source>
          <target state="translated">ä½ å¯ä»¥ä½¿ç”¨ES6çš„restæ“ä½œç¬¦è¿›è¡Œè§£æ„ã€‚</target>
        </trans-unit>
        <trans-unit id="121a5978b1bee631af70ab1aaec00b53de7645b2" translate="yes" xml:space="preserve">
          <source>global scope) can be deleted with delete.</source>
          <target state="translated">å…¨å±€èŒƒå›´)å¯ä»¥ç”¨deleteåˆ é™¤ã€‚</target>
        </trans-unit>
        <trans-unit id="5be9ceecc2f03bc42e4d234aec808162f9c2f9d1" translate="yes" xml:space="preserve">
          <source>the result would be:</source>
          <target state="translated">ç»“æœä¼šæ˜¯:</target>
        </trans-unit>
        <trans-unit id="cc81a06a417041080d93a2378641c20ac0ef4865" translate="yes" xml:space="preserve">
          <source>which is equivalent to:</source>
          <target state="translated">ç›¸å½“äº:</target>
        </trans-unit>
        <trans-unit id="b9a0331930f5ae83ac7b458124a7b5021f44ea5d" translate="yes" xml:space="preserve">
          <source>will behave equivalently for both methods.</source>
          <target state="translated">å¯¹è¿™ä¸¤ç§æ–¹æ³•æ¥è¯´,éƒ½ä¼šæœ‰åŒæ ·çš„è¡¨ç°ã€‚</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
