<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/208105">
    <body>
      <group id="208105">
        <trans-unit id="d0c785d16c2347fee547f3127b424f77909312a7" translate="yes" xml:space="preserve">
          <source>(Destructuring + Spread operator)</source>
          <target state="translated">(ç ´å£Š+ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰æ¼”ç®—å­)</target>
        </trans-unit>
        <trans-unit id="63d63c34165213cae85c0283076b58a13c886dbf" translate="yes" xml:space="preserve">
          <source>(ES6)</source>
          <target state="translated">(ES6)</target>
        </trans-unit>
        <trans-unit id="7d50cf7543cd430338fe6fd7172b5d7ec7565f89" translate="yes" xml:space="preserve">
          <source>* &lt;em&gt;&lt;code&gt;foo&lt;/code&gt; will be a new variable with the value of &lt;code&gt;a&lt;/code&gt; (which is 1).&lt;/em&gt;</source>
          <target state="translated">* &lt;em&gt; &lt;code&gt;foo&lt;/code&gt; ã¯aã®å€¤ï¼ˆ1ï¼‰ã‚’æŒã¤æ–°ã—ã„å¤‰æ•°ã«ãªã‚Šã¾ã™ã€‚&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8aa44c32c47930ef0f4bc07bf1b584a5b6b0e2f" translate="yes" xml:space="preserve">
          <source>...It's stupid, I know.</source>
          <target state="translated">...é¦¬é¹¿ã’ã¦ã„ã‚‹ã€‚</target>
        </trans-unit>
        <trans-unit id="ff34d7bfb44f74504dbcecb1c791e02877f620e3" translate="yes" xml:space="preserve">
          <source>1.With explicit prop key:</source>
          <target state="translated">1.æ˜ç¤ºçš„ãªãƒ—ãƒ­ãƒƒãƒ—ã‚­ãƒ¼ã‚’æŒã¤ã€‚</target>
        </trans-unit>
        <trans-unit id="145f4a070da96e31a48d8d444babf929a09a782a" translate="yes" xml:space="preserve">
          <source>2.With variable prop key:</source>
          <target state="translated">2.å¯å¤‰ãƒ—ãƒ­ãƒƒãƒ—ã‚­ãƒ¼ä»˜ãã€‚</target>
        </trans-unit>
        <trans-unit id="75c350f4599bd395c8e57950299bcd4efdaca57e" translate="yes" xml:space="preserve">
          <source>3.Cool arrow function ğŸ˜:</source>
          <target state="translated">3.ã‚¯ãƒ¼ãƒ«ã‚¢ãƒ­ãƒ¼æ©Ÿèƒ½ ğŸ˜ã€‚</target>
        </trans-unit>
        <trans-unit id="b31d7d6cbd9fc3e49f4feaeef410e7cee592b5fa" translate="yes" xml:space="preserve">
          <source>4. For multiple properties</source>
          <target state="translated">4.è¤‡æ•°ã®ç‰©ä»¶ã®å ´åˆ</target>
        </trans-unit>
        <trans-unit id="cecf2bde461c486918fed98467ea58414d0dd173" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;Object.freeze()&lt;/a&gt; makes all properties of object not configurable (besides other things). &lt;code&gt;deleteProperty&lt;/code&gt; function (as well as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;delete operator&lt;/a&gt;) returns &lt;code&gt;false&lt;/code&gt; when tries to delete any of it's properties. If property is configurable it returns &lt;code&gt;true&lt;/code&gt;, even if property does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;Object.freezeï¼ˆï¼‰&lt;/a&gt;ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä»–ã®ã™ã¹ã¦ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æ§‹æˆä¸å¯èƒ½ã«ã—ã¾ã™ã€‚ &lt;code&gt;deleteProperty&lt;/code&gt; é–¢æ•°ï¼ˆãŠã‚ˆã³&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;delete operator&lt;/a&gt; ï¼‰ã¯ã€ãã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®ã„ãšã‚Œã‹ã‚’å‰Šé™¤ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ &lt;code&gt;false&lt;/code&gt; ã‚’è¿”ã—ã¾ã™ã€‚ ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒè¨­å®šå¯èƒ½ãªå ´åˆã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒå­˜åœ¨ã—ãªãã¦ã‚‚ &lt;code&gt;true&lt;/code&gt; ã‚’è¿”ã—ã¾ã™ ã€‚</target>
        </trans-unit>
        <trans-unit id="d2f5341f96365af83c99b7c7d47dba6c4b1a96cb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;Spread Syntax&lt;/a&gt; (ES6)</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰æ§‹æ–‡&lt;/a&gt; ï¼ˆES6ï¼‰</target>
        </trans-unit>
        <trans-unit id="e4d9e924d09e0b750a05547c2f0bf5fa2c195878" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.slice()&lt;/code&gt; is non-destructive and returns a new array containing the indicated indices from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;end&lt;/code&gt;. If &lt;code&gt;end&lt;/code&gt; is left unspecified, the behavior is the same as &lt;code&gt;.splice()&lt;/code&gt; (&lt;code&gt;end = array.length&lt;/code&gt;). The behavior is a bit tricky since, for some reason, &lt;code&gt;end&lt;/code&gt; indexes from 1 instead of 0. I don't know why it does this, but that's how it is. Also, if &lt;code&gt;end &amp;lt;= start&lt;/code&gt;, the result is an empty array.</source>
          <target state="translated">&lt;code&gt;.slice()&lt;/code&gt; ã¯éç ´å£Šçš„ã§ã€æŒ‡å®šã•ã‚ŒãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ &lt;code&gt;start&lt;/code&gt; ã‹ã‚‰ &lt;code&gt;end&lt;/code&gt; ã¾ã§å«ã‚€æ–°ã—ã„é…åˆ—ã‚’è¿”ã—ã¾ã™ã€‚ &lt;code&gt;end&lt;/code&gt; ã‚’æŒ‡å®šã—ãªã„å ´åˆã€å‹•ä½œã¯ &lt;code&gt;.splice()&lt;/code&gt; ï¼ˆ &lt;code&gt;end = array.length&lt;/code&gt; ï¼‰ã¨åŒã˜ã§ã™ã€‚ ä½•ã‚‰ã‹ã®ç†ç”±ã§ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’0ã§ã¯ãªã1ã‹ã‚‰ &lt;code&gt;end&lt;/code&gt; ã™ã‚‹ãŸã‚ã€å‹•ä½œã¯å°‘ã—ãƒˆãƒªãƒƒã‚­ãƒ¼ã§ã™ã€‚ãªãœã“ã‚ŒãŒè¡Œã‚ã‚Œã‚‹ã®ã‹ã¯ã‚ã‹ã‚Šã¾ã›ã‚“ãŒã€ãã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚ ã¾ãŸã€ &lt;code&gt;end &amp;lt;= start&lt;/code&gt; å ´åˆã€çµæœã¯ç©ºã®é…åˆ—ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="da2a0c1e98a822064cc6b913222774a91ac62044" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.splice()&lt;/code&gt; mutates the array, and returns the removed indices. The array is sliced starting from the index, &lt;code&gt;start&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; elements are sliced out. If n is unspecified, the entire array after &lt;code&gt;start&lt;/code&gt; is sliced out (&lt;code&gt;n = array.length - start&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;.splice()&lt;/code&gt; ã¯é…åˆ—ã‚’å¤‰æ›´ã—ã€å‰Šé™¤ã•ã‚ŒãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ é…åˆ—ã¯ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ &lt;code&gt;start&lt;/code&gt; ã‹ã‚‰ã‚¹ãƒ©ã‚¤ã‚¹ã•ã‚Œã€ &lt;code&gt;n&lt;/code&gt; å€‹ã®è¦ç´ ãŒã‚¹ãƒ©ã‚¤ã‚¹ã•ã‚Œã¾ã™ã€‚ nãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã€ &lt;code&gt;start&lt;/code&gt; å¾Œã®é…åˆ—å…¨ä½“ãŒ &lt;code&gt;n = array.length - start&lt;/code&gt; ã‚Œã¾ã™ï¼ˆ n = array.length-start ï¼‰ã€‚</target>
        </trans-unit>
        <trans-unit id="578e0d997316ced94b2f7c292e4269507a0730b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Delete Operator&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;æ¼”ç®—å­ã‚’å‰Šé™¤&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="10a7b7e3a95023fb9f5d4f97bbeb1e856756bc60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;EXTENDED ANSWER&lt;/em&gt;&lt;/strong&gt; ğŸ˜‡</source>
          <target state="translated">å»¶é•·å›ç­”ğŸ˜‡</target>
        </trans-unit>
        <trans-unit id="3393b3743a22fd0193ab2fa39735ae2f646b06ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Or&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Or&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="710a4e957cc23ae95eb9aa6e13030731ab1c9d56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Reassignment&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Reassignment&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e590196d99e29b0fb26cc981e8c241732f76e4ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Spread Operator&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="64d050dff57dceee4d758cc0912b8d402b405b10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Usage&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Usage&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b02479449faf2e3a74dc8a9ef6000bfbe7ea1f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In other words, a JavaScript object gets killed as soon as there is no reference left in your code pointed to that object.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;è¨€ã„æ›ãˆã‚‹ã¨ã€JavaScriptã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡ã™å‚ç…§ãŒã‚³ãƒ¼ãƒ‰ã«æ®‹ã£ã¦ã„ãªã„å ´åˆã«ã™ãã«å¼·åˆ¶çµ‚äº†ã•ã‚Œã¾ã™ã€‚&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ecc8000feff4d7f65f5786df06cc101796ac4edd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To clone object without property:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãªã—ã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¤‡è£½ã™ã‚‹ã«ã¯ï¼š&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ca5c58827bf40e3a97a098228081f1f64d66b7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update 2018-07-21:&lt;/strong&gt; For a long time, I have felt embarrassed about this answer, so I think it's time that I touch it up a little bit. Just a little commentary, clarification, and formatting to help expedite the reading of the needlessly long and convoluted parts of this answer.</source>
          <target state="translated">&lt;strong&gt;2018-07-21ã®æ›´æ–°ï¼š&lt;/strong&gt;é•·ã„é–“ã€ã“ã®ç­”ãˆã«æˆ¸æƒ‘ã„ã‚’æ„Ÿã˜ã¦ã„ãŸã®ã§ã€å°‘ã—&lt;strong&gt;ä¿®æ­£ã™ã‚‹ã¨ããŒã&lt;/strong&gt;ãŸã¨æ€ã„ã¾ã™ã€‚ ã“ã®å›ç­”ã®ä¸å¿…è¦ã«é•·ãè¤‡é›‘ãªéƒ¨åˆ†ã®èª­ã¿å–ã‚Šã‚’ä¿ƒé€²ã™ã‚‹ãŸã‚ã®ã»ã‚“ã®å°‘ã—ã®è§£èª¬ã€èª¬æ˜ã€ãŠã‚ˆã³ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã€‚</target>
        </trans-unit>
        <trans-unit id="c099f37767111dc60103bd8696ed4fcf3e7a64d4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;
Thanks to @AgentME:</source>
          <target state="translated">&lt;strong&gt;æ›´æ–°ï¼š&lt;/strong&gt; @AgentMEã«æ„Ÿè¬ï¼š</target>
        </trans-unit>
        <trans-unit id="cd7c415e1d4039a5febeafd32c836a75f6b919e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;delete&lt;/code&gt;,&lt;/strong&gt; when you are passing the result object to the code on which you don't have control (or when you are not sure about your team or yourself).</source>
          <target state="translated">åˆ¶å¾¡ã§ããªã„ã‚³ãƒ¼ãƒ‰ã«çµæœã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¸¡ã™å ´åˆï¼ˆã¾ãŸã¯ãƒãƒ¼ãƒ ã¾ãŸã¯è‡ªåˆ†è‡ªèº«ãŒä¸æ˜ãªå ´åˆï¼‰ã¯&lt;strong&gt;ã€ &lt;code&gt;delete&lt;/code&gt; ã‚’ä½¿ç”¨ã—&lt;/strong&gt;ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0af0c0606dbb967654f58c35fa2988459afb9a19" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use setting to &lt;code&gt;undefined&lt;/code&gt;,&lt;/strong&gt; when you care about performance. It can give a serious boost to your code.</source>
          <target state="translated">ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹&lt;strong&gt;ã‚’ &lt;code&gt;undefined&lt;/code&gt; ã™ã‚‹&lt;/strong&gt;å ´åˆã¯&lt;strong&gt;ã€è¨­å®šã‚’undefinedã«&lt;/strong&gt;ã—ã¦ãã ã•ã„ã€‚ ãã‚Œã¯ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã«æ·±åˆ»ãªå¾ŒæŠ¼ã—ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9dfe20a67d61ae6b75beddf80cff0434cb3f7a9f" translate="yes" xml:space="preserve">
          <source>A live example to show:</source>
          <target state="translated">ç¤ºã™ãŸã‚ã®ç”ŸããŸãŠæ‰‹æœ¬ã€‚</target>
        </trans-unit>
        <trans-unit id="aabd2b7839024463c3c18626551d6893b70879bd" translate="yes" xml:space="preserve">
          <source>About now, you're at your wit's end. This guy has been complaining non-stop about your app, and you want to tell him to shut up and go get a better computer.</source>
          <target state="translated">ä»Šé ƒã€ã‚ãªãŸã¯é€”æ–¹ã«æš®ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®ç”·ã¯ã‚ãªãŸã®ã‚¢ãƒ—ãƒªã« ä¸æº€ã‚’è¨€ã£ã¦ããŸ ã‚ãªãŸã¯å½¼ã«é»™ã£ã¦ è‰¯ã„ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã‚’æ‰‹ã«å…¥ã‚Œã«è¡Œãã‚ˆã†ã« è¨€ã„ãŸã„ã®ã­</target>
        </trans-unit>
        <trans-unit id="692f82b2a7574a467099a421e634c28a19087f50" translate="yes" xml:space="preserve">
          <source>Alternatively, you could also do this:</source>
          <target state="translated">ã‚ã‚‹ã„ã¯ã€ã“ã®ã‚ˆã†ãªæ–¹æ³•ã‚‚ã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="8dd6b6a5cb398077b2e61b33860df5233162a369" translate="yes" xml:space="preserve">
          <source>An object may be seen as a set of key-value pairs. What I call a 'value' is a primitive or a reference to other object, connected to that 'key'.</source>
          <target state="translated">ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ã‚­ãƒ¼ã¨å€¤ã®ãƒšã‚¢ã®é›†åˆã¨ã—ã¦è¦‹ã‚‰ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ç§ãŒã€Œå€¤ã€ã¨å‘¼ã¶ã‚‚ã®ã¯ã€ãã®ã€Œã‚­ãƒ¼ã€ã«æ¥ç¶šã•ã‚ŒãŸãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¾ãŸã¯ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="97f362e729192c077ada3f5241fec0dea0e6f9ad" translate="yes" xml:space="preserve">
          <source>And just like that, you've pleased Mr. PDP-11. Hooray! &lt;sub&gt;(I'd still tell him off, though...)&lt;/sub&gt;</source>
          <target state="translated">ãã‚Œã¨åŒã˜ã‚ˆã†ã«ã€PDP-11æ°ã‚’å–œã°ã›ã¾ã—ãŸã€‚ ã‚„ã£ãŸãƒ¼ï¼ &lt;sub&gt;ï¼ˆç§ã¯ã¾ã å½¼ã‚’å‘Šã’ã‚‹ã ã‚ã†...ï¼‰&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="38fedc2f5a59cd30ac658c92ac34226c9870e485" translate="yes" xml:space="preserve">
          <source>And we need to delete 'a'.</source>
          <target state="translated">ãã—ã¦ã€'a'ã‚’å‰Šé™¤ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="15728408349a51726fa4d7a495f586b8e25e36f1" translate="yes" xml:space="preserve">
          <source>Another alternative is to use the &lt;a href=&quot;https://underscorejs.org&quot;&gt;Underscore.js&lt;/a&gt; library.</source>
          <target state="translated">åˆ¥ã®æ–¹æ³•ã¯ã€ &lt;a href=&quot;https://underscorejs.org&quot;&gt;Underscore.js&lt;/a&gt;ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="130c3bce337f7ed92461a0af093bf0dd8b4d970c" translate="yes" xml:space="preserve">
          <source>Another solution, using &lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;&lt;code&gt;Array#reduce&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt; &lt;code&gt;Array#reduce&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;ã‚’ä½¿ç”¨ã—ãŸåˆ¥ã®ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã€‚</target>
        </trans-unit>
        <trans-unit id="75aa366398b31b18c07d678c84ff7223a1b76dbe" translate="yes" xml:space="preserve">
          <source>Any property declared with let or const cannot be deleted from the scope  within which they were defined. Non-configurable properties cannot be removed. This includes properties of built-in objects like Math, Array, Object and properties that are created as non-configurable with methods like Object.defineProperty().</source>
          <target state="translated">let ã¾ãŸã¯ const ã§å®£è¨€ã•ã‚ŒãŸãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯ã€ãã‚Œã‚‰ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚¹ã‚³ãƒ¼ãƒ—ã‹ã‚‰å‰Šé™¤ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚éæ§‹æˆå¯èƒ½ãªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ã“ã‚Œã«ã¯ã€Mathã€Arrayã€Object ãªã©ã®çµ„ã¿è¾¼ã¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚„ã€Object.defineProperty()ã®ã‚ˆã†ãªãƒ¡ã‚½ãƒƒãƒ‰ã§éæ§‹æˆå¯èƒ½ã¨ã—ã¦ä½œæˆã•ã‚ŒãŸãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒå«ã¾ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b2ecb35283325b0622c879acc81ba757d7accad0" translate="yes" xml:space="preserve">
          <source>Any property declared with var cannot be deleted from the global scope
  or from a function's scope.</source>
          <target state="translated">var ã§å®£è¨€ã•ã‚ŒãŸãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã‚„é–¢æ•°ã®ã‚¹ã‚³ãƒ¼ãƒ—ã‹ã‚‰å‰Šé™¤ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="6c333dd9449a548b822691fcab373abce8f8f850" translate="yes" xml:space="preserve">
          <source>Are you looking to achieve this in pure JavaScript or are you willing &amp;amp; able to use a 3rd-party library?</source>
          <target state="translated">ç´”ç²‹ãªJavaScriptã§ã“ã‚Œã‚’å®Ÿç¾ã™ã‚‹ã“ã¨ã‚’æœ›ã‚“ã§ã„ã¾ã™ã‹ã€ãã‚Œã¨ã‚‚ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨ã—ãŸã„ã¨æ€ã„ã¾ã™ã‹ï¼Ÿ</target>
        </trans-unit>
        <trans-unit id="1fea0155471c15e540c5b31c3594a45754e6cc6c" translate="yes" xml:space="preserve">
          <source>Array equivalent</source>
          <target state="translated">é…åˆ—ç›¸å½“</target>
        </trans-unit>
        <trans-unit id="10f82eff0fb408011ffeabc374c6234764312dea" translate="yes" xml:space="preserve">
          <source>Array.prototype.slice(start, end)</source>
          <target state="translated">Array.prototype.slice(start,end)</target>
        </trans-unit>
        <trans-unit id="dfe829210c0c25d8779de7fe65fb3158cefd4290" translate="yes" xml:space="preserve">
          <source>Array.prototype.splice vs Array.prototype.slice</source>
          <target state="translated">Array.prototype.splice vs Array.prototype.slice</target>
        </trans-unit>
        <trans-unit id="99ba4898ce91c3e3945c33ecd292283940427b38" translate="yes" xml:space="preserve">
          <source>Array.prototype.splice(start, n)</source>
          <target state="translated">Array.prototype.splice(start,n)</target>
        </trans-unit>
        <trans-unit id="bc85e8ead32cd6185d2f6ca2b34c7fbc94aadd58" translate="yes" xml:space="preserve">
          <source>As others have said, you can use &lt;code&gt;delete&lt;/code&gt;.</source>
          <target state="translated">ä»–ã®äººãŒè¨€ã£ãŸã‚ˆã†ã«ã€ã‚ãªãŸã¯ &lt;code&gt;delete&lt;/code&gt; ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="fc6de88f57fe2bcbd39aa2ddf8ca667c26f222a3" translate="yes" xml:space="preserve">
          <source>As seen in the above code snippet, there are some rare appropriate use cases for the &lt;code&gt;delete&lt;/code&gt; operator. However, do not worry about this problem too much. This will only become a problem with long-lifespan objects that get new keys constantly added to them. In any other case (which is almost every case in real-world programming), it is most appropriate to use &lt;code&gt;obj[prop] = undefined&lt;/code&gt;. The main purpose of this section is just to bring this to your attention so that in the rare chance that this does become a problem in your code, then you can more easily understand the problem and thus not have to waste hours dissecting your code to locate and understand this problem.</source>
          <target state="translated">ä¸Šè¨˜ã®ã‚³ãƒ¼ãƒ‰ã‚¹ãƒ‹ãƒšãƒƒãƒˆã«è¦‹ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã€ &lt;code&gt;delete&lt;/code&gt; æ¼”ç®—å­ã®é©åˆ‡ãªãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã¯ã¾ã‚Œã§ã™ã€‚ ãŸã ã—ã€ã“ã®å•é¡Œã‚’ã‚ã¾ã‚Šæ°—ã«ã—ãªã„ã§ãã ã•ã„ã€‚ ã“ã‚Œã¯ã€æ–°ã—ã„ã‚­ãƒ¼ãŒå¸¸ã«è¿½åŠ ã•ã‚Œã‚‹é•·å¯¿å‘½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã®ã¿å•é¡Œã«ãªã‚Šã¾ã™ã€‚ ãã‚Œä»¥å¤–ã®å ´åˆï¼ˆã“ã‚Œã¯å®Ÿéš›ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã§ã¯ã»ã¨ã‚“ã©ã™ã¹ã¦ã®ã‚±ãƒ¼ã‚¹ã§ã™ï¼‰ã€ &lt;code&gt;obj[prop] = undefined&lt;/code&gt; ã‚’ä½¿ç”¨ã™ã‚‹ã®ãŒæœ€ã‚‚é©åˆ‡ã§ã™ã€‚ ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ä¸»ãªç›®çš„ã¯ã€ã“ã‚Œã‚’æ³¨æ„ã™ã‚‹ã“ã¨ã§ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ã¾ã‚Œã«ã“ã‚ŒãŒã‚³ãƒ¼ãƒ‰ã§å•é¡Œã«ãªã‚‹å ´åˆã«ã€å•é¡Œã‚’ã‚ˆã‚Šç°¡å˜ã«ç†è§£ã§ãã‚‹ãŸã‚ã€ã‚³ãƒ¼ãƒ‰ã‚’åˆ†æã™ã‚‹ãŸã‚ã«æ™‚é–“ã‚’ç„¡é§„ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®å•é¡Œã‚’ç†è§£ã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="0a1a7281b5e3e0adcbcee6c0378231475ce1d077" translate="yes" xml:space="preserve">
          <source>As such, delete cannot delete any functions in the global scope (whether this is part from a function definition or a function  (expression).</source>
          <target state="translated">ãã®ãŸã‚ã€deleteã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—å†…ã®é–¢æ•°ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“(ã“ã‚ŒãŒé–¢æ•°å®šç¾©ã®ä¸€éƒ¨ã§ã‚ã‚‹ã‹ã€é–¢æ•°(å¼)ã®ä¸€éƒ¨ã§ã‚ã‚‹ã‹ã¯å•ã„ã¾ã›ã‚“)ã€‚</target>
        </trans-unit>
        <trans-unit id="19292906404cfee69ce728ffea847a3cb5d23580" translate="yes" xml:space="preserve">
          <source>As you can see, &lt;code&gt;delete&lt;/code&gt; doesn't always work as one might expect. The value is overwritten, but the memory is not reallocated. That is to say, &lt;code&gt;array[4]&lt;/code&gt; isn't relocated to &lt;code&gt;array[3]&lt;/code&gt;. Which is in contrast to &lt;code&gt;Array.prototype.unshift&lt;/code&gt;, which inserts an element at the beginning of the array and shifts everything up (&lt;code&gt;array[0]&lt;/code&gt; becomes &lt;code&gt;array[1]&lt;/code&gt;, etc.)</source>
          <target state="translated">ã”è¦§ã®ã¨ãŠã‚Šã€ &lt;code&gt;delete&lt;/code&gt; ã¯å¿…ãšã—ã‚‚æœŸå¾…ã©ãŠã‚Šã«æ©Ÿèƒ½ã™ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚ å€¤ã¯ä¸Šæ›¸ãã•ã‚Œã¾ã™ãŒã€ãƒ¡ãƒ¢ãƒªã¯å†å‰²ã‚Šå½“ã¦ã•ã‚Œã¾ã›ã‚“ã€‚ ã¤ã¾ã‚Šã€ &lt;code&gt;array[4]&lt;/code&gt; ã¯ &lt;code&gt;array[3]&lt;/code&gt; å†é…ç½®ã•ã‚Œã¾ã›ã‚“ã€‚ ã“ã‚Œã¯ã€é…åˆ—ã®å…ˆé ­ã«è¦ç´ ã‚’æŒ¿å…¥ã—ã¦ã™ã¹ã¦ã‚’ä¸Šã«ã‚·ãƒ•ãƒˆã™ã‚‹ &lt;code&gt;Array.prototype.unshift&lt;/code&gt; ã¨ã¯å¯¾ç…§çš„ã§ã™ï¼ˆ &lt;code&gt;array[0]&lt;/code&gt; ãŒ &lt;code&gt;array[1]&lt;/code&gt; ã«ãªã‚‹ãªã©ï¼‰ã€‚</target>
        </trans-unit>
        <trans-unit id="2c856c5e5c5be4265462b9644119ace1784d98d0" translate="yes" xml:space="preserve">
          <source>Beware Of Memory Leaks!</source>
          <target state="translated">ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã«ã”ç”¨å¿ƒ</target>
        </trans-unit>
        <trans-unit id="76829795257d4b98172b51f389192e4a9f633cf6" translate="yes" xml:space="preserve">
          <source>But if the property of the object is not configurable it cannot be deleted neither with deleteProperty function nor delete operator:</source>
          <target state="translated">ã—ã‹ã—ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒè¨­å®šã§ããªã„å ´åˆã¯ã€deletePropertyé–¢æ•°ã§ã‚‚deleteæ¼”ç®—å­ã§ã‚‚å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="5d2ae2c0c3d231052d20df4bc0d378c5068295e8" translate="yes" xml:space="preserve">
          <source>But the point is if you care about memory and you want to whole the object gets removed from the memory, it is recommended to set it to null before you delete the key:</source>
          <target state="translated">ã—ã‹ã—ã€ãƒ¡ãƒ¢ãƒªã‚’æ°—ã«ã—ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¸¸ã”ã¨ãƒ¡ãƒ¢ãƒªã‹ã‚‰å‰Šé™¤ã—ãŸã„å ´åˆã¯ã€ã‚­ãƒ¼ã‚’å‰Šé™¤ã™ã‚‹å‰ã«NULLã«ã—ã¦ãŠãã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="083882684bcd539a61f754c832b4192934d833e3" translate="yes" xml:space="preserve">
          <source>But, how does a drug trip analogy relate to the &lt;code&gt;delete&lt;/code&gt; operation? The answer inheres the last line of code in the snippet above. Thus let it be reexamined, this time with a twist.</source>
          <target state="translated">ã—ã‹ã—ã€ãƒ‰ãƒ©ãƒƒã‚°ãƒˆãƒªãƒƒãƒ—ã®ã‚¢ãƒŠãƒ­ã‚¸ãƒ¼ã¯ &lt;code&gt;delete&lt;/code&gt; æ“ä½œã¨ã©ã®ã‚ˆã†ã«é–¢é€£ã—ã¦ã„ã¾ã™ã‹ï¼Ÿ ç­”ãˆã¯ã€ä¸Šè¨˜ã®ã‚¹ãƒ‹ãƒšãƒƒãƒˆã®æœ€å¾Œã®ã‚³ãƒ¼ãƒ‰è¡Œã§ã™ã€‚ ã—ãŸãŒã£ã¦ã€ä»Šåº¦ã¯ã²ã­ã‚Šã‚’åŠ ãˆã¦å†æ¤œè¨ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚</target>
        </trans-unit>
        <trans-unit id="0eb16d4b50dbacc8475f57ed2dfb88409bd56da6" translate="yes" xml:space="preserve">
          <source>Consider creating a new object without the &lt;code&gt;&quot;regex&quot;&lt;/code&gt; property because the original object could always be referenced by other parts of your program. Thus you should avoid manipulating it.</source>
          <target state="translated">å…ƒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ä»–ã®éƒ¨åˆ†ã‹ã‚‰å¸¸ã«å‚ç…§ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€ &lt;code&gt;&quot;regex&quot;&lt;/code&gt; ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãªã—ã§æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ã“ã¨ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚ ã—ãŸãŒã£ã¦ã€ãã‚Œã‚’æ“ä½œã™ã‚‹ã“ã¨ã¯é¿ã‘ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="1b8bae88ce3f716fc88f086ba5df71aa742b0ee5" translate="yes" xml:space="preserve">
          <source>Dan's assertion that 'delete' is very slow and the benchmark he posted were doubted. So I carried out the test myself in Chrome 59. It does seem that 'delete' is about 30 times slower:</source>
          <target state="translated">å‰Šé™¤ã€ãŒéå¸¸ã«é…ã„ã¨ã„ã†ãƒ€ãƒ³ã®ä¸»å¼µã¨ã€å½¼ãŒæŠ•ç¨¿ã—ãŸãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã‚’ç–‘ã£ãŸã€‚ã¨ã„ã†ã“ã¨ã§ã€è‡ªåˆ†ã§Chrome 59ã§ãƒ†ã‚¹ãƒˆã—ã¦ã¿ã¾ã—ãŸã€‚ç¢ºã‹ã«'delete'ã¯30å€ãã‚‰ã„é…ã„ã‚ˆã†ã ã€‚</target>
        </trans-unit>
        <trans-unit id="d8b13a816456ec85d6f3ace2de0c50288edaa6ea" translate="yes" xml:space="preserve">
          <source>Delete is the only true way to remove object's properties without any leftovers, but it works &lt;strong&gt;~ 100 times slower&lt;/strong&gt;, 
compared to its &quot;alternative&quot;, setting &lt;code&gt;object[key] = undefined&lt;/code&gt;.</source>
          <target state="translated">Deleteã¯ã€æ®‹ã‚Šç‰©ã‚’æ®‹ã•ãšã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å‰Šé™¤ã™ã‚‹ãŸã‚ã®å”¯ä¸€ã®çœŸã®æ–¹æ³•ã§ã™ãŒã€ã€Œä»£æ›¿ã€ã¨æ¯”è¼ƒã—ã¦ã€ &lt;code&gt;object[key] = undefined&lt;/code&gt; è¨­å®šã™ã‚‹å ´åˆã¨æ¯”ã¹ã¦ã€å‹•ä½œãŒ&lt;strong&gt;100å€é…ããªã‚Š&lt;/strong&gt; ã¾ã™ ã€‚</target>
        </trans-unit>
        <trans-unit id="45dc7ea9ea6f9f47fa401db4115a5eee26a4be14" translate="yes" xml:space="preserve">
          <source>Deleting an array index</source>
          <target state="translated">é…åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®å‰Šé™¤</target>
        </trans-unit>
        <trans-unit id="42034d05fb5ec8b92965ea89f328c840dc4a3ac4" translate="yes" xml:space="preserve">
          <source>Deleting an object property</source>
          <target state="translated">ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å‰Šé™¤ã™ã‚‹</target>
        </trans-unit>
        <trans-unit id="e52c854d5631eec7468ba4727b4c77eb745f2965" translate="yes" xml:space="preserve">
          <source>Demo</source>
          <target state="translated">Demo</target>
        </trans-unit>
        <trans-unit id="0298196b206bc7b4a96725653dbc77fafc2e7815" translate="yes" xml:space="preserve">
          <source>Do Not Always Set To &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">å¸¸ã« &lt;code&gt;undefined&lt;/code&gt; è¨­å®šã—ãªã„ã§ãã ã•ã„</target>
        </trans-unit>
        <trans-unit id="e813a63a91f53696f818ac595a5fddc09cb30338" translate="yes" xml:space="preserve">
          <source>Don't &lt;code&gt;delete&lt;/code&gt; from an array. Use &lt;code&gt;Array.prototype.splice&lt;/code&gt; instead.</source>
          <target state="translated">é…åˆ—ã‹ã‚‰ &lt;code&gt;delete&lt;/code&gt; ã—ãªã„ã§ãã ã•ã„ ã€‚ ä»£ã‚ã‚Šã« &lt;code&gt;Array.prototype.splice&lt;/code&gt; ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="9cff8f35d333fc23fef816a20f879c35c001ee7e" translate="yes" xml:space="preserve">
          <source>Due to the dynamic nature of JavaScript there are often cases where you simply don't know if the property exists or not. Checking if obj exists before the &amp;amp;&amp;amp; also makes sure you don't throw an error due to calling the hasOwnProperty() function on an undefined object.</source>
          <target state="translated">JavaScriptã®å‹•çš„ãªæ€§è³ªã«ã‚ˆã‚Šã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒå­˜åœ¨ã™ã‚‹ã‹ã©ã†ã‹ãŒã‚ã‹ã‚‰ãªã„å ´åˆãŒã‚ˆãã‚ã‚Šã¾ã™ã€‚ &amp;amp;&amp;amp;ã®å‰ã«objãŒå­˜åœ¨ã™ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹ã¨ã€æœªå®šç¾©ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§hasOwnPropertyï¼ˆï¼‰é–¢æ•°ã‚’å‘¼ã³å‡ºã—ãŸãŸã‚ã«ã‚¨ãƒ©ãƒ¼ãŒã‚¹ãƒ­ãƒ¼ã•ã‚Œãªã„ã“ã¨ã‚‚ç¢ºèªã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f30ca853155d96f4ff4a7523ad41da4989438529" translate="yes" xml:space="preserve">
          <source>E.g</source>
          <target state="translated">E.g</target>
        </trans-unit>
        <trans-unit id="48886c6e98adf5c4a9c9282a2441dfe3015faacb" translate="yes" xml:space="preserve">
          <source>ECMAScript 2015 (or ES6) came with built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect&quot;&gt;Reflect&lt;/a&gt; object. It is possible to delete object property by calling &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty&quot;&gt;Reflect.deleteProperty()&lt;/a&gt; function with target object and property key as parameters:</source>
          <target state="translated">ECMAScript 2015ï¼ˆã¾ãŸã¯ES6ï¼‰ã«ã¯ã€çµ„ã¿è¾¼ã¿ã®&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect&quot;&gt;Reflect&lt;/a&gt;ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä»˜å±ã—ã¦ã„ã¾ã™ã€‚ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ã—ã¦ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚­ãƒ¼ã‚’æŒ‡å®šã—ã¦&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty&quot;&gt;Reflect.deletePropertyï¼ˆï¼‰&lt;/a&gt;é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã“ã¨ã«ã‚ˆã‚Šã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å‰Šé™¤ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4c2dbb36a3a214bec101207bfb72cd18b86e453e" translate="yes" xml:space="preserve">
          <source>Each one has it's own pros and cons (&lt;a href=&quot;https://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;check this performance comparison&lt;/a&gt;):</source>
          <target state="translated">ãã‚Œãã‚Œã«é•·æ‰€ã¨çŸ­æ‰€ãŒã‚ã‚Šã¾ã™ï¼ˆ &lt;a href=&quot;https://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;ã“ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒã‚’ç¢ºèªã—ã¦ãã ã•ã„&lt;/a&gt; ï¼‰ã€‚</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">ã‚¹ãƒ‹ãƒšãƒƒãƒˆã‚’å±•é–‹</target>
        </trans-unit>
        <trans-unit id="5cb7b7c35055238b90a33971ff368cff01dd0bbb" translate="yes" xml:space="preserve">
          <source>For anyone interested in reading more about it, Stack Overflow user &lt;a href=&quot;https://stackoverflow.com/users/130652/kangax&quot;&gt;kangax&lt;/a&gt; has written an incredibly in-depth blog post about the &lt;code&gt;delete&lt;/code&gt; statement on their blog, &lt;em&gt;&lt;a href=&quot;http://perfectionkills.com/understanding-delete/&quot;&gt;Understanding delete&lt;/a&gt;&lt;/em&gt;. It is highly recommended.</source>
          <target state="translated">Stack Overflowã®ãƒ¦ãƒ¼ã‚¶ãƒ¼&lt;a href=&quot;https://stackoverflow.com/users/130652/kangax&quot;&gt;kangax&lt;/a&gt;ã¯ã€ãã‚Œã«ã¤ã„ã¦è©³ã—ãèª­ã‚€ã“ã¨ã«é–¢å¿ƒã®ã‚ã‚‹äººã®ãŸã‚ã«ã€è‡ªåˆ†ã®ãƒ–ãƒ­ã‚°ã® &lt;code&gt;delete&lt;/code&gt; ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã«ã¤ã„ã¦ã€ä¿¡ã˜ã‚‰ã‚Œãªã„ã»ã©è©³ç´°ãªãƒ–ãƒ­ã‚°æŠ•ç¨¿ã‚’æŠ•ç¨¿ã—ã¦ã„ã¾ã™ã€‚ å¼·ããŠå‹§ã‚ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="7de0c8678ad3582ef48a786c2a12849c95f613d2" translate="yes" xml:space="preserve">
          <source>For arrays, &lt;code&gt;_.filter()&lt;/code&gt; and &lt;code&gt;_.reject()&lt;/code&gt; can be used in a similar manner.</source>
          <target state="translated">é…åˆ—ã®å ´åˆã€ &lt;code&gt;_.filter()&lt;/code&gt; ãŠã‚ˆã³ &lt;code&gt;_.reject()&lt;/code&gt; ã‚’åŒæ§˜ã®æ–¹æ³•ã§ä½¿ç”¨ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ae20664549d9e3ccd77991be79f76a86f10d159f" translate="yes" xml:space="preserve">
          <source>For example, say you are creating a webapp that uses JSON-serialization to store an array used for 'tabs' in a string (in this case, &lt;code&gt;localStorage&lt;/code&gt;). Let's also say that the code uses the numerical indices of the array's members to &quot;title&quot; them when drawing to the screen. Why are you doing this rather than just storing the &quot;title&quot; as well? Because... &lt;em&gt;reasons&lt;/em&gt;.</source>
          <target state="translated">ãŸã¨ãˆã°ã€JSONã‚·ãƒªã‚¢ãƒ«åŒ–ã‚’ä½¿ç”¨ã—ã¦ã€Œã‚¿ãƒ–ã€ã«ä½¿ç”¨ã•ã‚Œã‚‹é…åˆ—ã‚’æ–‡å­—åˆ—ï¼ˆã“ã®å ´åˆã¯ &lt;code&gt;localStorage&lt;/code&gt; ï¼‰ã«æ ¼ç´ã™ã‚‹Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œæˆã™ã‚‹ã¨ã—ã¾ã™ã€‚ ã¾ãŸã€ç”»é¢ã«æç”»ã™ã‚‹ã¨ãã«ã€ã‚³ãƒ¼ãƒ‰ãŒé…åˆ—ã®ãƒ¡ãƒ³ãƒãƒ¼ã®æ•°å€¤ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ç”¨ã—ã¦ãã‚Œã‚‰ã«ã€Œã‚¿ã‚¤ãƒˆãƒ«ã‚’ä»˜ã‘ã‚‹ã€ã¨ã—ã¾ã—ã‚‡ã†ã€‚ ã€Œã‚¿ã‚¤ãƒˆãƒ«ã€ã ã‘ã‚’ä¿å­˜ã™ã‚‹ã®ã§ã¯ãªãã€ãªãœã“ã‚Œã‚’è¡Œã†ã®ã§ã™ã‹ï¼Ÿ ãªãœãªã‚‰... &lt;em&gt;ç†ç”±&lt;/em&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">ä¾‹ãˆã°</target>
        </trans-unit>
        <trans-unit id="cdad74d0486512dc3bc4f850907cd467e5fc5e3c" translate="yes" xml:space="preserve">
          <source>For more info about and seeing more example, visit the link below:</source>
          <target state="translated">ã‚ˆã‚Šå¤šãã®ä¾‹ã«ã¤ã„ã¦ã¯ã€ä»¥ä¸‹ã®ãƒªãƒ³ã‚¯ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="3053a4eaab6ecc9daa630f23887af0a663b64dcc" translate="yes" xml:space="preserve">
          <source>Functions which are part of an object (apart from the</source>
          <target state="translated">ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸€éƒ¨ã§ã‚ã‚‹é–¢æ•°(</target>
        </trans-unit>
        <trans-unit id="a355b0b1f78d396cf69cf859538e8172e1e8345c" translate="yes" xml:space="preserve">
          <source>Hello You Can try this simple an sort</source>
          <target state="translated">ã“ã‚“ã«ã¡ã¯ã€ã‚ãªãŸã¯ã“ã®å˜ç´”ãªã‚½ãƒ¼ãƒˆã‚’è©¦ã™ã“ã¨ãŒã§ãã¾ã™</target>
        </trans-unit>
        <trans-unit id="ca27c0a83d24961b91d263af64d922d82a55909c" translate="yes" xml:space="preserve">
          <source>Honestly, aside from setting to &lt;code&gt;null&lt;/code&gt; rather than &lt;code&gt;undefined&lt;/code&gt;--which is legitimately weird--this behavior &lt;em&gt;shouldn't&lt;/em&gt; be surprising, since &lt;code&gt;delete&lt;/code&gt; is a unary operator, like &lt;code&gt;typeof&lt;/code&gt;, that is hard-boiled into the language and is not supposed to care about the &lt;em&gt;type&lt;/em&gt; of object it's being used on, whereas &lt;code&gt;Array&lt;/code&gt; is a subclass of &lt;code&gt;Object&lt;/code&gt; with methods &lt;em&gt;specifically designed for&lt;/em&gt; working with arrays. So there's no good reason for &lt;code&gt;delete&lt;/code&gt; to have a special case cooked in for re-shifting the array, as that would just slow things down with unnecessary work. In retrospect, my expectations were unrealistic.</source>
          <target state="translated">æ­£ç›´ã«è¨€ã†ã¨ã€ &lt;code&gt;undefined&lt;/code&gt; ã¯ãªã &lt;code&gt;null&lt;/code&gt; ã«è¨­å®šã™ã‚‹ã“ã¨ã‚’é™¤ã„ã¦ï¼ˆã“ã‚Œã¯åˆæ³•çš„ã«å¥‡å¦™ã§ã™ï¼‰ã€ &lt;code&gt;delete&lt;/code&gt; ã¯ &lt;code&gt;typeof&lt;/code&gt; ã®ã‚ˆã†ãªå˜é …æ¼”ç®—å­ã§ã‚ã‚Šã€è¨€èªã«ãƒãƒ¼ãƒ‰ãƒœã‚¤ãƒ«ã•ã‚Œã¦ãŠã‚Šã€ æ°—ã«ã™ã‚‹ &lt;em&gt;å¿…è¦ãŒãªã„&lt;/em&gt;ãŸã‚ã€é©šãã¹ãã“ã¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“ &lt;code&gt;Array&lt;/code&gt; ã¯ã€ãã‚ŒãŒä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®&lt;em&gt;ã‚¿ã‚¤ãƒ—&lt;/em&gt;ã«ã¤ã„ã¦ã§ã™ã€‚ä¸€æ–¹ã€ Arrayã¯ã€ é…åˆ—ã‚’æ“ä½œã™ã‚‹&lt;em&gt;ãŸã‚ã«ç‰¹åˆ¥ã«è¨­è¨ˆã•ã‚ŒãŸ&lt;/em&gt;ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ &lt;code&gt;Object&lt;/code&gt; ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã™ã€‚ ã—ãŸãŒã£ã¦ã€é…åˆ—ã‚’å†ã‚·ãƒ•ãƒˆã™ã‚‹ãŸã‚ã«ç‰¹åˆ¥ãªã‚±ãƒ¼ã‚¹ã‚’ &lt;code&gt;delete&lt;/code&gt; ã™ã‚‹ã‚ˆã†ã«å‰Šé™¤ã™ã‚‹ç†ç”±ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä¸è¦ãªä½œæ¥­ã§é€Ÿåº¦ãŒä½ä¸‹ã™ã‚‹ã ã‘ã ã‹ã‚‰ã§ã™ã€‚ æŒ¯ã‚Šè¿”ã£ã¦ã¿ã‚‹ã¨ã€ç§ã®æœŸå¾…ã¯éç¾å®Ÿçš„ã§ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="dc3989e98834042a9457a0de8b90b5c9f3024f13" translate="yes" xml:space="preserve">
          <source>How do I remove a property from a JavaScript object</source>
          <target state="translated">JavaScriptã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å‰Šé™¤ã™ã‚‹æ–¹æ³•</target>
        </trans-unit>
        <trans-unit id="b47475af69db5ae110b477abd31ec35a3c7d497a" translate="yes" xml:space="preserve">
          <source>However, be mindful! Do not suddenly start doing this with all your preexisting code now as it would likely break such preexisting code and/or introduce strange bugs. Rather, such an efficient practice needs to be implemented from the start, and when converting preexisting code, it is recommended that you double, triple, quadruple check all the lines relating to that as trying to upgrade old code to this new practice can be as risky as it is rewarding.</source>
          <target state="translated">ã—ã‹ã—ã€æ³¨æ„ãŒå¿…è¦ã§ã™ã€‚æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ã‚’å£Šã—ãŸã‚Šã€å¥‡å¦™ãªãƒã‚°ã‚’å°å…¥ã—ãŸã‚Šã™ã‚‹å¯èƒ½æ€§ãŒé«˜ã„ã®ã§ã€ã„ããªã‚Šä»Šã‹ã‚‰æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ã£ã¦ã“ã®ã‚ˆã†ãªã“ã¨ã‚’å§‹ã‚ãªã„ã§ãã ã•ã„ã€‚ã‚€ã—ã‚ã€ã“ã®ã‚ˆã†ãªåŠ¹ç‡çš„ãªç·´ç¿’ã¯æœ€åˆã‹ã‚‰å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã€æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ã‚’å¤‰æ›ã™ã‚‹ã¨ãã«ã€å¤ã„ã‚³ãƒ¼ãƒ‰ã‚’ã“ã®æ–°ã—ã„ç·´ç¿’ã«ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã€ã‚„ã‚ŠãŒã„ãŒã‚ã‚‹ã®ã¨åŒã˜ãã‚‰ã„å±é™ºãªã“ã¨ãŒã‚ã‚Šã¾ã™ã®ã§ã€ãã‚Œã«é–¢é€£ã™ã‚‹ã™ã¹ã¦ã®è¡Œã‚’äºŒé‡ã€ä¸‰é‡ã€å››é‡ã«ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="491f0bae14ec381e286ea282ba5b10bae8f240b9" translate="yes" xml:space="preserve">
          <source>However, it will &lt;strong&gt;mutate&lt;/strong&gt; the original object. If you want to create a new object &lt;strong&gt;without&lt;/strong&gt; the specified key, just assign the reduce function to a new variable, e.g.:</source>
          <target state="translated">ãŸã ã—ã€å…ƒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å¤‰æ›´ã•ã‚Œã¾ã™ã€‚ ã‚­ãƒ¼ã‚’æŒ‡å®š&lt;strong&gt;ã›ãšã«&lt;/strong&gt;æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹å ´åˆã¯ã€reduceé–¢æ•°ã‚’æ–°ã—ã„å¤‰æ•°ã«å‰²ã‚Šå½“ã¦ã¾ã™ã€‚ä¾‹ï¼š</target>
        </trans-unit>
        <trans-unit id="b18c3a88c501a6c91766f406a1e129e6aaa98cea" translate="yes" xml:space="preserve">
          <source>However, there are two major unfixable problems with polymorphic arrays:</source>
          <target state="translated">ã—ã‹ã—,ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ãƒƒã‚¯é…åˆ—ã«ã¯,ä¿®æ­£ä¸å¯èƒ½ãª2ã¤ã®å¤§ããªå•é¡ŒãŒã‚ã‚Šã¾ã™.</target>
        </trans-unit>
        <trans-unit id="3486394d0c7c983de3c5268328e537d9b15cb8f7" translate="yes" xml:space="preserve">
          <source>However, this code:</source>
          <target state="translated">ã—ã‹ã—ã€ã“ã®ã‚³ãƒ¼ãƒ‰ã€‚</target>
        </trans-unit>
        <trans-unit id="4a71f7845929b0f0df07acdfaf7d379b182e9259" translate="yes" xml:space="preserve">
          <source>I feel it's important to point out the difference between these two similarly-named functions, as they are both very useful.</source>
          <target state="translated">ã“ã®2ã¤ã®ä¼¼ãŸã‚ˆã†ãªåå‰ã®é–¢æ•°ã¯ã€ã©ã¡ã‚‰ã‚‚éå¸¸ã«ä¾¿åˆ©ãªã®ã§ã€ãã®é•ã„ã‚’æŒ‡æ‘˜ã™ã‚‹ã“ã¨ã¯é‡è¦ã ã¨æ„Ÿã˜ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="459a68f17b246b077cb24b6614e54636e1f0783c" translate="yes" xml:space="preserve">
          <source>I personally use &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; or &lt;a href=&quot;https://lodash.com&quot;&gt;Lodash&lt;/a&gt; for object and array manipulation:</source>
          <target state="translated">ç§ã¯å€‹äººçš„ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨é…åˆ—ã®æ“ä½œã«&lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt;ã¾ãŸã¯&lt;a href=&quot;https://lodash.com&quot;&gt;Lodash&lt;/a&gt;ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a8613a5b1880d971e632b3352e4bfe554f971c46" translate="yes" xml:space="preserve">
          <source>If a property with the same name exists on the object's prototype
  chain, then, after deletion, the object will use the property from the
  prototype chain (in other words, delete only has an effect on own
  properties).</source>
          <target state="translated">ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ãƒ»ãƒã‚§ãƒ¼ãƒ³ã«åŒåã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒå­˜åœ¨ã™ã‚‹å ´åˆã€å‰Šé™¤å¾Œã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ãƒ»ãƒã‚§ãƒ¼ãƒ³ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ä½¿ç”¨ã—ã¾ã™(è¨€ã„æ›ãˆã‚Œã°ã€å‰Šé™¤ã¯è‡ªåˆ†ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«ã®ã¿åŠ¹æœãŒã‚ã‚Šã¾ã™)ã€‚</target>
        </trans-unit>
        <trans-unit id="1e20c9e61654d816a6093dde8b64312b7bd4779b" translate="yes" xml:space="preserve">
          <source>If the property which you are trying to delete does not exist, delete
  will not have any effect and will return true</source>
          <target state="translated">å‰Šé™¤ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒå­˜åœ¨ã—ãªã„å ´åˆã€deleteã¯ä½•ã®åŠ¹æœã‚‚ãªãtrueã‚’è¿”ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="28ec183a3184d93a675028a4e725a85c94f1f649" translate="yes" xml:space="preserve">
          <source>If you do not know the index, you'll also have to do an index search:</source>
          <target state="translated">ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒã‚ã‹ã‚‰ãªã„å ´åˆã¯ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æ¤œç´¢ã‚‚å¿…è¦ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3204a3a58282102b99263134aa04e4bbd9031c97" translate="yes" xml:space="preserve">
          <source>If you do:</source>
          <target state="translated">ã‚‚ã—ãã†ãªã‚‰</target>
        </trans-unit>
        <trans-unit id="3204f4d5aa25757c4ed3063f2b869d5fde0626d5" translate="yes" xml:space="preserve">
          <source>If you know the index of your staff member, you could simply do this:</source>
          <target state="translated">æ‹…å½“è€…ã®æŒ‡æ¨™ã‚’çŸ¥ã£ã¦ã„ã‚Œã°ã€å˜ç´”ã«ã“ã†ã™ã‚Œã°ã„ã„ã®ã§ã¯ãªã„ã§ã—ã‚‡ã†ã‹ã€‚</target>
        </trans-unit>
        <trans-unit id="9b546f76f9301b299e7ed78305baf0ef1addfe1c" translate="yes" xml:space="preserve">
          <source>If you want to delete a property deeply nested in the object then you can use the following recursive function with path to the property as the second argument:</source>
          <target state="translated">ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«æ·±ãå…¥ã‚Œå­ã«ãªã£ã¦ã„ã‚‹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å‰Šé™¤ã—ãŸã„å ´åˆã¯ã€ãã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¸ã®ãƒ‘ã‚¹ã‚’ç¬¬2å¼•æ•°ã¨ã—ã¦ã€ä»¥ä¸‹ã®å†å¸°é–¢æ•°ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="506bf20b873a7a4cd476c438c371ecd4bcca65fc" translate="yes" xml:space="preserve">
          <source>If you want to experiment with this, you can use &lt;a href=&quot;http://jsfiddle.net/cb57dusv/46/&quot;&gt;&lt;strong&gt;this Fiddle&lt;/strong&gt;&lt;/a&gt; as a starting point.</source>
          <target state="translated">ã“ã‚Œã‚’è©¦ã—ã¦ã¿ãŸã„å ´åˆã¯ã€ &lt;a href=&quot;http://jsfiddle.net/cb57dusv/46/&quot;&gt;&lt;strong&gt;ã“ã®ãƒ•ã‚£ãƒ‰ãƒ«&lt;/strong&gt;&lt;/a&gt;ã‚’å‡ºç™ºç‚¹ã¨ã—ã¦ä½¿ç”¨ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a4e72696da1b895cd7644dbb4f08034ae76c1836" translate="yes" xml:space="preserve">
          <source>If you want to use the entire &lt;code&gt;staff&lt;/code&gt; array, the proper way to do this, would be to do this:</source>
          <target state="translated">&lt;code&gt;staff&lt;/code&gt; é…åˆ—å…¨ä½“ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€ã“ã‚Œã‚’è¡Œã†é©åˆ‡ãªæ–¹æ³•ã¯ã€æ¬¡ã®ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="43cf8d099321d601790e8b3431ad74fdf17809c0" translate="yes" xml:space="preserve">
          <source>Ignoring the dangers and problems inherent in &lt;code&gt;null&lt;/code&gt;, and the space wasted, this can be problematic if the array needs to be precise.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; ã«å›ºæœ‰ã®å±é™ºæ€§ã¨å•é¡Œã€ãŠã‚ˆã³ç„¡é§„ãªã‚¹ãƒšãƒ¼ã‚¹ã‚’ç„¡è¦–ã™ã‚‹ã¨ã€é…åˆ—ã‚’æ­£ç¢ºã«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã€ã“ã‚Œã¯å•é¡Œã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c138b726889b4f8045cc8db17ba22f8faa709ac8" translate="yes" xml:space="preserve">
          <source>In addition, while mutating objects in-place isn't stateless, you can use the functional nature of &lt;code&gt;Reflect.deleteProperty&lt;/code&gt; to do partial application and other functional techniques that aren't possible with &lt;code&gt;delete&lt;/code&gt; statements.</source>
          <target state="translated">ã•ã‚‰ã«ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ¼ã‚¹ã§å¤‰æ›´ã™ã‚‹ã“ã¨ã¯ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€ &lt;code&gt;Reflect.deleteProperty&lt;/code&gt; ã®æ©Ÿèƒ½çš„ãªæ€§è³ªã‚’ä½¿ç”¨ã—ã¦ã€éƒ¨åˆ†çš„ã«é©ç”¨ã—ãŸã‚Šã€ &lt;code&gt;delete&lt;/code&gt; ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã§ã¯ä¸å¯èƒ½ãªãã®ä»–ã®æ©Ÿèƒ½çš„ãªãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã‚’å®Ÿè¡Œã—ãŸã‚Šã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5b114aff6680bfc75db078ff75477b94c1c576aa" translate="yes" xml:space="preserve">
          <source>In arrays, unlike plain old objects, using &lt;code&gt;delete&lt;/code&gt; leaves behind garbage in the form of &lt;code&gt;null&lt;/code&gt;, creating a &quot;hole&quot; in the array.</source>
          <target state="translated">é…åˆ—ã§ã¯ã€å˜ç´”ãªå¤ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã¯ç•°ãªã‚Šã€ &lt;code&gt;delete&lt;/code&gt; ã‚’ä½¿ç”¨ã™ã‚‹ã¨ &lt;code&gt;null&lt;/code&gt; ã®å½¢å¼ã§ã‚¬ãƒ™ãƒ¼ã‚¸ãŒæ®‹ã‚Š ã€é…åˆ—ã«ã€Œç©´ã€ãŒä½œæˆã•ã‚Œã¾ã™ ã€‚</target>
        </trans-unit>
        <trans-unit id="acf20d554a4832d04b9fb4c2dfc6cc9d34eda721" translate="yes" xml:space="preserve">
          <source>In the code above, simply doing &lt;code&gt;nodeRecords[i][lastTime] = undefined;&lt;/code&gt; will cause a massive memory leak because each animation frame. Each frame, all 65536 DOM elements will take up another 65536 individual slots, but the previous 65536 slots will only be set to undefined which leaves them hanging in the memory. Go ahead, try to run the above code in the console and see for yourself. After forcing an out-of-memory error, attempt to run it again except with the following version of the code that uses the &lt;code&gt;delete&lt;/code&gt; operator instead.</source>
          <target state="translated">ä¸Šè¨˜ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€å˜ç´”ã« &lt;code&gt;nodeRecords[i][lastTime] = undefined;&lt;/code&gt; ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã«å¤§é‡ã®ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãŒç™ºç”Ÿã—ã¾ã™ã€‚ ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã«ã€ã™ã¹ã¦ã®65536 DOMè¦ç´ ãŒåˆ¥ã®65536ã®å€‹åˆ¥ã‚¹ãƒ­ãƒƒãƒˆã‚’å æœ‰ã—ã¾ã™ãŒã€ä»¥å‰ã®65536ã‚¹ãƒ­ãƒƒãƒˆã¯æœªå®šç¾©ã«è¨­å®šã•ã‚Œã‚‹ã ã‘ã§ã€ãƒ¡ãƒ¢ãƒªå†…ã§ãƒãƒ³ã‚°ã—ã¾ã™ã€‚ ã•ã‚ã€ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã§ä¸Šè¨˜ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã—ã¦ã¿ã¦ãã ã•ã„ã€‚ ãƒ¡ãƒ¢ãƒªãƒ¼ä¸è¶³ã‚¨ãƒ©ãƒ¼ã‚’å¼·åˆ¶ã—ãŸå¾Œã€ä»£ã‚ã‚Šã« &lt;code&gt;delete&lt;/code&gt; æ¼”ç®—å­ã‚’ä½¿ç”¨ã™ã‚‹æ¬¡ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ã‚³ãƒ¼ãƒ‰ã‚’é™¤ã„ã¦ã€ã‚‚ã†ä¸€åº¦å®Ÿè¡Œã—ã¦ã¿ã¦ãã ã•ã„ ã€‚</target>
        </trans-unit>
        <trans-unit id="271f117734d63131f8d6a45f399a766357be7419" translate="yes" xml:space="preserve">
          <source>Increasingly stupid edge-case scenario aside, using &lt;code&gt;delete&lt;/code&gt; on said array will result in &lt;code&gt;null&lt;/code&gt; polluting the array, and probably causing bugs in the app later on. And if you check for &lt;code&gt;null&lt;/code&gt;, it would straight up skip the numbers resulting in the tabs being rendered like &lt;code&gt;[1] [2] [4] [5] ...&lt;/code&gt;.</source>
          <target state="translated">ã¾ã™ã¾ã™æ„šã‹ãªã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ã‚·ãƒŠãƒªã‚ªã¯ã•ã¦ãŠãã€ä¸Šè¨˜ã®é…åˆ—ã§ &lt;code&gt;delete&lt;/code&gt; ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€é…åˆ—ãŒ &lt;code&gt;null&lt;/code&gt; ã§æ±šæŸ“ã•ã‚Œã€å¾Œã§ã‚¢ãƒ—ãƒªã«ãƒã‚°ãŒç™ºç”Ÿã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ ã¾ãŸã€ &lt;code&gt;null&lt;/code&gt; ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã¨ã€æ•°å­—ãŒãã®ã¾ã¾ã‚¹ã‚­ãƒƒãƒ—ã•ã‚Œã€ã‚¿ãƒ–ãŒ &lt;code&gt;[1] [2] [4] [5] ...&lt;/code&gt; ã‚ˆã†ã«ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã•ã‚Œã¾ã™ ã€‚</target>
        </trans-unit>
        <trans-unit id="67a2e0451ade99e58384dc55f1327e29e5977c70" translate="yes" xml:space="preserve">
          <source>It &lt;strong&gt;deletes the key from the hashmap&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;ãƒãƒƒã‚·ãƒ¥ãƒãƒƒãƒ—ã‹ã‚‰ã‚­ãƒ¼ã‚’å‰Šé™¤ã—ã¾ã™&lt;/strong&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="593fba807066e533a5fe4a2443019f46d7ca31da" translate="yes" xml:space="preserve">
          <source>JavaScript is an OOP Language, so everything is an object, including &lt;em&gt;arrays&lt;/em&gt;. Thus, I feel it necessary to point out a particular caveat.</source>
          <target state="translated">JavaScriptã¯OOPè¨€èªã§ã‚ã‚‹ãŸã‚ã€ &lt;em&gt;é…åˆ—&lt;/em&gt;ã‚’å«ã‚€ã™ã¹ã¦ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚ ã—ãŸãŒã£ã¦ã€ç§ã¯ç‰¹å®šã®è­¦å‘Šã‚’æŒ‡æ‘˜ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã¨æ„Ÿã˜ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b86b332c3f3aa1433f370f7189813a6381eb2178" translate="yes" xml:space="preserve">
          <source>Library-based property omission</source>
          <target state="translated">ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ãƒ™ãƒ¼ã‚¹ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®çœç•¥</target>
        </trans-unit>
        <trans-unit id="59b86486aed4edafd59a372a9da15c32460385f0" translate="yes" xml:space="preserve">
          <source>Like this:</source>
          <target state="translated">ã“ã‚“ãªæ„Ÿã˜ã§ã€‚</target>
        </trans-unit>
        <trans-unit id="23ee237b458378f4f66052abb7c903c28cbb18e4" translate="yes" xml:space="preserve">
          <source>Look at the &lt;strong&gt;&lt;a href=&quot;http://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;benchmark&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã‚’&lt;/a&gt;&lt;/strong&gt;è¦‹ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="d0447456284f7feabbe03be15bd344b6f319890b" translate="yes" xml:space="preserve">
          <source>Luckily, arrays &lt;em&gt;do&lt;/em&gt; have a specialized method for deleting indices and reallocating memory: &lt;code&gt;Array.prototype.splice()&lt;/code&gt;. You could write something like this:</source>
          <target state="translated">å¹¸ã„ãªã“ã¨ã«ã€é…åˆ—ã«&lt;em&gt;ã¯&lt;/em&gt; ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å‰Šé™¤ã—ã¦ãƒ¡ãƒ¢ãƒªã‚’å†å‰²ã‚Šå½“ã¦ã™ã‚‹ãŸã‚ã®ç‰¹åˆ¥ãªãƒ¡ã‚½ãƒƒãƒ‰ &lt;code&gt;Array.prototype.splice()&lt;/code&gt; ãŒã‚ã‚Šã¾ã™ã€‚ ã‚ãªãŸã¯ã“ã®ã‚ˆã†ãªã‚‚ã®ã‚’æ›¸ãã“ã¨ãŒã§ãã¾ã™ï¼š</target>
        </trans-unit>
        <trans-unit id="098d9f24825c866c84675902efcb46bcadb54327" translate="yes" xml:space="preserve">
          <source>More than 2X faster than &lt;code&gt;delete&lt;/code&gt;, however the property is &lt;strong&gt;not&lt;/strong&gt; deleted and can be iterated.</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; ã‚ˆã‚Šã‚‚2å€ä»¥ä¸Šé«˜é€Ÿã§ã™ãŒã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯å‰Šé™¤ã•ã‚Œ&lt;strong&gt;ãš&lt;/strong&gt; ã€åå¾©ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ccc762c5d3373bf8a3cde8b635c9825605d01c63" translate="yes" xml:space="preserve">
          <source>Mutative object property deletion, safe</source>
          <target state="translated">å¤‰ç•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å‰Šé™¤ã€å®‰å…¨</target>
        </trans-unit>
        <trans-unit id="9ce68ac5a3111b339ada2a12dd8cc6eea0e45ffa" translate="yes" xml:space="preserve">
          <source>Mutative object property deletion, unsafe</source>
          <target state="translated">å¤‰ç•°çš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å‰Šé™¤ã€å®‰å…¨ã§ã¯ãªã„</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="089de7283699cfb1ed6d519cb14e7b0cf6326b5b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;_.pick()&lt;/code&gt; and &lt;code&gt;_.omit()&lt;/code&gt; both return a copy of the object and don't directly modify the original object. Assigning the result to the original object should do the trick (not shown).</source>
          <target state="translated">&lt;code&gt;_.pick()&lt;/code&gt; ã¨ &lt;code&gt;_.omit()&lt;/code&gt; ã¯ã©ã¡ã‚‰ã‚‚ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã€å…ƒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç›´æ¥å¤‰æ›´ã—ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ çµæœã‚’å…ƒã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å‰²ã‚Šå½“ã¦ã‚‹ã¨ã€ã†ã¾ãã„ãã¯ãšã§ã™ï¼ˆå›³ã«ã¯ç¤ºã•ã‚Œã¦ã„ã¾ã›ã‚“ï¼‰ã€‚</target>
        </trans-unit>
        <trans-unit id="74d18dd16f1da3ac16685fb7e2b20e82dd3d4708" translate="yes" xml:space="preserve">
          <source>Note that I purposedly carried out more than one 'delete' operations in one loop cycle to minimize the effect caused by the other operations.</source>
          <target state="translated">ãªãŠã€ç§ã¯ã€ä»–ã®æ“ä½œã«ã‚ˆã‚‹å½±éŸ¿ã‚’æœ€å°é™ã«æŠ‘ãˆã‚‹ãŸã‚ã«ã€1ã¤ã®ãƒ«ãƒ¼ãƒ—ã‚µã‚¤ã‚¯ãƒ«ã§è¤‡æ•°ã®ã€Œå‰Šé™¤ã€æ“ä½œã‚’ã‚ã–ã¨è¡Œã£ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="cbc78d0538f8d0b1ea57d6e615c0173c54cc2f85" translate="yes" xml:space="preserve">
          <source>Note that the wrapper function is designed to be very strict about types, and will return &lt;code&gt;null&lt;/code&gt; if anything is off. That includes putting in a string like &lt;code&gt;&quot;3&quot;&lt;/code&gt;. It is left up to the programmer to be diligent about his types. This is to encourage good programming practice.</source>
          <target state="translated">ãƒ©ãƒƒãƒ‘ãƒ¼é–¢æ•°ã¯å‹ã«ã¤ã„ã¦éå¸¸ã«å³å¯†ã«ãªã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ãŠã‚Šã€ã‚ªãƒ•ã«ãªã£ã¦ã„ã‚‹ã‚‚ã®ãŒã‚ã‚Œã° &lt;code&gt;null&lt;/code&gt; ã‚’è¿”ã—ã¾ã™ ã€‚ ã“ã‚Œã«ã¯ &lt;code&gt;&quot;3&quot;&lt;/code&gt; ã®ã‚ˆã†ãªæ–‡å­—åˆ—ã‚’å…¥ã‚Œã‚‹ã“ã¨ãŒå«ã¾ã‚Œã¾ã™ã€‚ å½¼ã®ã‚¿ã‚¤ãƒ—ã«ã¤ã„ã¦å‹¤å‹‰ã§ã‚ã‚‹ã‹ã©ã†ã‹ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒã«ä»»ã•ã‚Œã¦ã„ã¾ã™ã€‚ ã“ã‚Œã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®å®Ÿè·µã‚’ä¿ƒã™ãŸã‚ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0cd1e1c286ff1b960d2aa87f0e85fe9bd6a35fdd" translate="yes" xml:space="preserve">
          <source>Now, if you want to remove a single staff member or student, the procedure is a bit different, because both properties are arrays themselves.</source>
          <target state="translated">ã•ã¦ã€ä¸€äººã®ã‚¹ã‚¿ãƒƒãƒ•ã‚„å­¦ç”Ÿã‚’å‰Šé™¤ã—ãŸã„å ´åˆã¯ã€ä¸¡æ–¹ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒé…åˆ—ã§ã‚ã‚‹ãŸã‚ã€æ‰‹é †ãŒå°‘ã—ç•°ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="e14273e8bb73415bec8db17e1b9d548211a7aed0" translate="yes" xml:space="preserve">
          <source>Now, you &lt;em&gt;could&lt;/em&gt; keep a second iterator, like &lt;code&gt;j&lt;/code&gt;, to increment only when valid values are read from the array. But that wouldn't exactly solve the &lt;code&gt;null&lt;/code&gt; issue, and you still have to please that &lt;s&gt;troll&lt;/s&gt; PDP-11 user. Alas, his computer just &lt;em&gt;doesn't&lt;/em&gt; have enough memory to hold that last integer &lt;sub&gt;(don't ask how he manages to handle a variable-width array...)&lt;/sub&gt;.</source>
          <target state="translated">ã“ã‚Œã§ã€ &lt;code&gt;j&lt;/code&gt; ãªã©ã®2ç•ªç›®ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’ä¿æŒã—ã¦ã€é…åˆ—ã‹ã‚‰æœ‰åŠ¹ãªå€¤ãŒèª­ã¿å–ã‚‰ã‚ŒãŸã¨ãã«ã®ã¿å¢—åˆ†ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ ã—ã‹ã—ã€ãã‚Œã¯ &lt;code&gt;null&lt;/code&gt; ã®å•é¡Œã‚’æ­£ç¢ºã«è§£æ±ºã™ã‚‹ã‚ã‘ã§ã¯ãªãã€ãã®&lt;s&gt;ãƒˆãƒ­ãƒ¼ãƒ«&lt;/s&gt; PDP-11ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æº€è¶³ã•ã›ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ æ‚²ã—ã„ã‹ãªã€å½¼ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ã«&lt;em&gt;ã¯&lt;/em&gt; ã€ãã®æœ€å¾Œã®æ•´æ•°ã‚’ä¿æŒã™ã‚‹ã®ã«ååˆ†ãªãƒ¡ãƒ¢ãƒªãŒ&lt;sub&gt;ã‚ã‚Šã¾ã›ã‚“ï¼ˆå¯å¤‰å¹…ã®é…åˆ—ã‚’ã©ã®ã‚ˆã†ã«å‡¦ç†ã™ã‚‹ã‹ã«ã¤ã„ã¦ã¯è³ªå•ã—ãªã„ã§ãã ã•ã„...ï¼‰&lt;/sub&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="e28b55f542be9cce84f1cc3f1bdb29e2a2eb72e0" translate="yes" xml:space="preserve">
          <source>Object.assign() &amp;amp; Object.keys() &amp;amp; Array.map()</source>
          <target state="translated">Object.assignï¼ˆï¼‰ï¼†Object.keysï¼ˆï¼‰ï¼†Array.mapï¼ˆï¼‰</target>
        </trans-unit>
        <trans-unit id="c643fe374f1dfb8aa281ee046c5ea254b1b7b942" translate="yes" xml:space="preserve">
          <source>Observe. &lt;code&gt;bar[1] = &quot;&quot;&lt;/code&gt; does not coerce polymorphism whereas &lt;code&gt;bar[1] = undefined&lt;/code&gt; does. Therefore, one should always, whenever possible use the corresponding type for their objects so as to not accidentally cause polymorphism. One such person may use the following list as a general reference to get them going. However, please do not explicitly use the below ideas. Instead, use whatever works well for your code.</source>
          <target state="translated">è¦³å¯Ÿã™ã‚‹ã€‚ &lt;code&gt;bar[1] = &quot;&quot;&lt;/code&gt; ã¯ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ã‚’å¼·åˆ¶ã—ã¾ã›ã‚“ãŒã€ &lt;code&gt;bar[1] = undefined&lt;/code&gt; ã¯å¼·åˆ¶ã—ã¾ã™ã€‚ ã—ãŸãŒã£ã¦ã€ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ã‚’èª¤ã£ã¦å¼•ãèµ·ã“ã•ãªã„ã‚ˆã†ã«ã€å¯èƒ½ãªå ´åˆã¯å¸¸ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å¯¾å¿œã™ã‚‹ã‚¿ã‚¤ãƒ—ã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ ãã®ã‚ˆã†ãªäººã®1äººã¯ã€æ¬¡ã®ãƒªã‚¹ãƒˆã‚’ä¸€èˆ¬çš„ãªå‚ç…§ã¨ã—ã¦ä½¿ç”¨ã—ã¦ã€ãã‚Œã‚‰ã‚’å®Ÿè¡Œã§ãã¾ã™ã€‚ ãŸã ã—ã€ä»¥ä¸‹ã®ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’æ˜ç¤ºçš„ã«ä½¿ç”¨ã—ãªã„ã§ãã ã•ã„ã€‚ ä»£ã‚ã‚Šã«ã€ã‚³ãƒ¼ãƒ‰ã«é©ã—ãŸã‚‚ã®ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="e583eed26b5bb4eb2fe3ea98e3d4481f60fbfae9" translate="yes" xml:space="preserve">
          <source>Of course, it &lt;em&gt;did&lt;/em&gt; surprise me. Because I wrote this to justify my crusade against &quot;null garbage&quot;:</source>
          <target state="translated">ã‚‚ã¡ã‚ã‚“ã€é©šãã¾ã—ãŸã€‚ ç§ãŒã“ã‚Œã‚’æ›¸ã„ãŸã®ã¯ã€ã€ŒãƒŒãƒ«ã‚´ãƒŸã€ã«å¯¾ã™ã‚‹ç§ã®åå­—è»ã‚’æ­£å½“åŒ–ã™ã‚‹ãŸã‚ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9d008b07517f4d9dbae6df29270e3dfc66dcea5d" translate="yes" xml:space="preserve">
          <source>Okay, let's just say that you're trying to save memory at the request of this &lt;em&gt;one&lt;/em&gt; user who runs a PDP-11 minicomputer from the 1960's running UNIX and wrote his own Elinks-based, JavaScript-compliant, line-printer-friendly browser because X11 is &lt;em&gt;out of the question&lt;/em&gt;.</source>
          <target state="translated">ã•ã¦ã€1960å¹´ä»£ã«å®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹UNIXã‹ã‚‰PDP-11ãƒŸãƒ‹ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ã‚’å®Ÿè¡Œã—ã€ç‹¬è‡ªã®Elinksãƒ™ãƒ¼ã‚¹ã®JavaScriptæº–æ‹ ã®ãƒ©ã‚¤ãƒ³ãƒ—ãƒªãƒ³ã‚¿ãƒ¼å¯¾å¿œãƒ–ãƒ©ã‚¦ã‚¶ãƒ¼ã‚’ä½œæˆã—ãŸã“ã®&lt;em&gt;1äººã®&lt;/em&gt;ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è¦æ±‚ã§ã€ãƒ¡ãƒ¢ãƒªã‚’ç¯€ç´„ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã¨ã—ã¾ã—ã‚‡ã†ã€‚ X11ã¯&lt;em&gt;å•é¡Œå¤–ãª&lt;/em&gt;ã®ã§ã€‚</target>
        </trans-unit>
        <trans-unit id="0746b7ec72e10adab007597141d3dddd2450c60e" translate="yes" xml:space="preserve">
          <source>Old question, modern answer. Using object destructuring, an &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015&quot;&gt;ECMAScript&amp;nbsp;6&lt;/a&gt; feature, it's as simple as:</source>
          <target state="translated">å¤ã„è³ªå•ã€ç¾ä»£ã®ç­”ãˆã€‚ &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015&quot;&gt;ECMAScript 6ã®&lt;/a&gt;æ©Ÿèƒ½ã§ã‚ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åˆ†è§£ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€æ¬¡ã®ã‚ˆã†ã«ç°¡å˜ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="88891f47a253aa57bb1cb91937b9715b281db53b" translate="yes" xml:space="preserve">
          <source>Once polymorphic, always polymorphic. When an array is made polymorphic, the polymorphism cannot be undone in Webkit browsers. So, even if you restore a polymorphic array to being non-polymorphic, it will still be stored by the browser as a polymorphic array.</source>
          <target state="translated">ä¸€åº¦ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ãƒƒã‚¯ã«ã™ã‚‹ã¨ã€å¸¸ã«ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ãƒƒã‚¯ã«ãªã‚Šã¾ã™ã€‚é…åˆ—ã‚’ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ãƒƒã‚¯ã«ã™ã‚‹ã¨ã€Webkit ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ãƒƒã‚¯ã‚’å…ƒã«æˆ»ã™ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ãã®ãŸã‚ã€ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ãƒƒã‚¯é…åˆ—ã‚’éãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ãƒƒã‚¯é…åˆ—ã«å¾©å…ƒã—ã¦ã‚‚ã€ãƒ–ãƒ©ã‚¦ã‚¶ã«ã‚ˆã£ã¦ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ãƒƒã‚¯é…åˆ—ã¨ã—ã¦ä¿å­˜ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b248f1b8652c2d4ab474434fceed81458cb94383" translate="yes" xml:space="preserve">
          <source>Once those four queries have been answered, there are essentially four categories of &quot;property removal&quot; in JavaScript to chose from in order to meet your goals. They are:</source>
          <target state="translated">ã“ã‚Œã‚‰ã®4ã¤ã®ã‚¯ã‚¨ãƒªã«ç­”ãˆãŒå‡ºãŸã‚‰ã€ç›®çš„ã‚’é”æˆã™ã‚‹ãŸã‚ã«ã€JavaScriptã®ã€Œãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å‰Šé™¤ã€ã«ã¯ã€åŸºæœ¬çš„ã«4ã¤ã®ã‚«ãƒ†ã‚´ãƒªãƒ¼ãŒã‚ã‚Šã¾ã™ã€‚ãã‚Œã‚‰ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="547c95266578e4dba22f41101c7fbe880f75e156" translate="yes" xml:space="preserve">
          <source>One aspect of Javascript that is important to consider is polymorphism. Polymorphism is when assigning the same variable/slot-in-an-object different types as seen below.</source>
          <target state="translated">è€ƒæ…®ã™ã¹ã Javascript ã®é‡è¦ãªå´é¢ã®ä¸€ã¤ã«ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ãŒã‚ã‚Šã¾ã™ã€‚ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ã¨ã¯ã€ä»¥ä¸‹ã«ç¤ºã™ã‚ˆã†ã«ã€åŒã˜å¤‰æ•°lot-in-an-objectã«ç•°ãªã‚‹å‹ã‚’å‰²ã‚Šå½“ã¦ã‚‹å ´åˆã®ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d59804a9108998189135354633d8b85aa6ac9872" translate="yes" xml:space="preserve">
          <source>One may liken polymorphism to a drug addiction. At first glance, it seems awesomely lucrative: nice pretty fluffy code. Then, the coder introduces their array to the drug of polymorphism. Instantly, the polymorphic array becomes less efficient, and it can never become as efficient as it was before since it is drugged. To correlate such circumstance to real life, someone on cocaine might not even be capable of operating a simple door handle, much less be able to calculate digits of PI. Likewise, an array on the drug of polymorphism cannot ever be as efficient as a monomorphic array.</source>
          <target state="translated">ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ã‚’éº»è–¬ä¸­æ¯’ã«ä¾‹ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä¸€è¦‹ã™ã‚‹ã¨ã€ã¨ã¦ã‚‚å„²ã‹ã‚‹ã‚ˆã†ã«è¦‹ãˆã¾ã™ã€‚ãã—ã¦ã€ã‚³ãƒ¼ãƒ€ãƒ¼ã¯ã€å¤šç›¸æ€§ã®è–¬ç‰©ã«é…åˆ—ã‚’å°å…¥ã—ã¾ã™ã€‚ç¬é–“çš„ã«ã€å¤šç›¸æ€§ã®ã‚ã‚‹é…åˆ—ã¯åŠ¹ç‡ãŒæ‚ªããªã‚Šã€è–¬æ¼¬ã‘ã«ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€ä»¥å‰ã®ã‚ˆã†ã«åŠ¹ç‡çš„ã«ãªã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®ã‚ˆã†ãªçŠ¶æ³ã‚’å®Ÿç”Ÿæ´»ã«ç›¸é–¢ã•ã›ã‚‹ãŸã‚ã«ã€ã‚³ã‚«ã‚¤ãƒ³ã®èª°ã‹ãŒã€å˜ç´”ãªãƒ‰ã‚¢ãƒãƒ³ãƒ‰ãƒ«ã‚’æ“ä½œã™ã‚‹ã“ã¨ãŒã§ããªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€ã¾ã—ã¦ã‚„PIã®æ¡ã‚’è¨ˆç®—ã™ã‚‹ã“ã¨ãŒã§ããªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚åŒæ§˜ã«ã€å¤šå½¢æ€§ã®è–¬ç‰©ã®é…åˆ—ã¯ã€å˜å½¢æ€§ã®é…åˆ—ã¨åŒã˜ãã‚‰ã„åŠ¹ç‡çš„ã§ã‚ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="81ec1a879d1bcac8eaeb3bcd6cca8f51d459b6e9" translate="yes" xml:space="preserve">
          <source>Operator &lt;code&gt;delete&lt;/code&gt; is unexpectedly slow!</source>
          <target state="translated">ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã® &lt;code&gt;delete&lt;/code&gt; ãŒäºˆæœŸã›ãšé…ã„ï¼</target>
        </trans-unit>
        <trans-unit id="b0213d049275e53829195e4fb176386bc570f98e" translate="yes" xml:space="preserve">
          <source>Or add it as a new pointer to another object like:</source>
          <target state="translated">ã‚ã‚‹ã„ã¯ã€åˆ¥ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®æ–°ã—ã„ãƒã‚¤ãƒ³ã‚¿ã¨ã—ã¦è¿½åŠ ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b02fc9813af3fdbb140c9b950f4bb96861bf726a" translate="yes" xml:space="preserve">
          <source>Or with the questions sample:</source>
          <target state="translated">ã¾ãŸã¯è³ªå•ã‚µãƒ³ãƒ—ãƒ«ã¨ä¸€ç·’ã«ã€‚</target>
        </trans-unit>
        <trans-unit id="e9b0d0e32654faf6fc06ca2ce8663172c501d507" translate="yes" xml:space="preserve">
          <source>Or you can also use array-like notation:</source>
          <target state="translated">ã‚ã‚‹ã„ã¯ã€é…åˆ—ã®ã‚ˆã†ãªè¡¨è¨˜ã‚’ä½¿ã†ã“ã¨ã‚‚ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="040435ad5191a6323d4b61a949b35014d90fb332" translate="yes" xml:space="preserve">
          <source>Or you can dynamically exclude properties like this,</source>
          <target state="translated">ã‚ã‚‹ã„ã¯ã€ã“ã®ã‚ˆã†ã«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å‹•çš„ã«é™¤å¤–ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a7ca816fcb165b225c5a6969cca6cd3afa101c70" translate="yes" xml:space="preserve">
          <source>Properties can be removed using &lt;strong&gt;destructuring&lt;/strong&gt; in combination with the &lt;strong&gt;rest operator&lt;/strong&gt;. In your example regex is destructured out (ignored) and the rest of the properties are returned as rest.</source>
          <target state="translated">ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯ã€ &lt;strong&gt;æ®‹ã‚Šã®æ¼”ç®—å­&lt;/strong&gt;ã¨çµ„ã¿åˆã‚ã›ã¦&lt;strong&gt;ç ´å£Š&lt;/strong&gt;ã‚’ä½¿ç”¨ã—ã¦å‰Šé™¤ã§ãã¾ã™ã€‚ ã‚ãªãŸã®ä¾‹ã§ã¯ã€æ­£è¦è¡¨ç¾ãŒåˆ†è§£ã•ã‚Œï¼ˆç„¡è¦–ã•ã‚Œï¼‰ã€æ®‹ã‚Šã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒæ®‹ã‚Šã¨ã—ã¦è¿”ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="257bb222f1c06e8c1d8edf559d64e06deb75f2f0" translate="yes" xml:space="preserve">
          <source>Property Removal in JavaScript</source>
          <target state="translated">JavaScriptã§ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å‰Šé™¤</target>
        </trans-unit>
        <trans-unit id="83a4727bcff27e1d95598a97b2a871336f59a8c8" translate="yes" xml:space="preserve">
          <source>Readable and short, however, it might not be the best choice if you are operating on a large number of objects as its performance is not optimized.</source>
          <target state="translated">èª­ã¿ã‚„ã™ãçŸ­ã„ã§ã™ãŒã€æ€§èƒ½ãŒæœ€é©åŒ–ã•ã‚Œã¦ã„ãªã„ãŸã‚ã€å¤šæ•°ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ“ä½œã™ã‚‹å ´åˆã«ã¯æœ€é©ãªé¸æŠã¨ã¯è¨€ãˆãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="ce7827682ca4a098e50c7905bb13aa7c7e60006c" translate="yes" xml:space="preserve">
          <source>Ref: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;MDN&lt;/a&gt;.</source>
          <target state="translated">å‚ç…§ï¼š &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;MDN&lt;/a&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="f02218cedd8e4fd7e585302dc05d8d0a5833d5f0" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://underscorejs.org/#omit&quot;&gt;link&lt;/a&gt;&lt;strong&gt;_.omit(object, *keys)&lt;/strong&gt;</source>
          <target state="translated">å‚ç…§ï¼š &lt;a href=&quot;http://underscorejs.org/#omit&quot;&gt;link&lt;/a&gt; &lt;strong&gt;_.omitï¼ˆobjectã€* keysï¼‰&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a3c1aeff97f5a6d2ba0a975a623e96c949b36be" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://underscorejs.org/#pick&quot;&gt;link&lt;/a&gt;&lt;strong&gt;_.pick(object, *keys)&lt;/strong&gt;</source>
          <target state="translated">ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ï¼š &lt;a href=&quot;http://underscorejs.org/#pick&quot;&gt;link&lt;/a&gt; &lt;strong&gt;_.pickï¼ˆobjectã€* keysï¼‰&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5817e749619edf322d60f85b86cab9c7f83094af" translate="yes" xml:space="preserve">
          <source>Rest-based string property omission</source>
          <target state="translated">ãƒ¬ã‚¹ãƒˆãƒ™ãƒ¼ã‚¹ã®æ–‡å­—åˆ—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®çœç•¥</target>
        </trans-unit>
        <trans-unit id="ab303515578a450fdf614933afe415b6528c01d1" translate="yes" xml:space="preserve">
          <source>Return a copy of the object, filtered to omit the 
blacklisted keys (or array of keys).</source>
          <target state="translated">ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã€ãƒ–ãƒ©ãƒƒã‚¯ãƒªã‚¹ãƒˆã«ç™»éŒ²ã•ã‚ŒãŸã‚­ãƒ¼ (ã¾ãŸã¯ã‚­ãƒ¼ã®é…åˆ—)ã‚’çœç•¥ã™ã‚‹ã‚ˆã†ã«ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="011a1cad4539d30348ba24adcd37dceade1f93c1" translate="yes" xml:space="preserve">
          <source>Return a copy of the object, filtered to only have values for the 
whitelisted keys (or array of valid keys).</source>
          <target state="translated">ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆã•ã‚ŒãŸã‚­ãƒ¼ (ã‚ã‚‹ã„ã¯æœ‰åŠ¹ãªã‚­ãƒ¼ã®é…åˆ—)ã®å€¤ã®ã¿ã‚’æŒã¤ã‚ˆã†ã«ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚³ãƒ”ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="650045349baef87a1fa74815eb1e6653f73e4e45" translate="yes" xml:space="preserve">
          <source>Say I create an object as follows:</source>
          <target state="translated">ä»¥ä¸‹ã®ã‚ˆã†ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ãŸã¨ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f5d2829fcf8f71f8331358342fe9021d00422606" translate="yes" xml:space="preserve">
          <source>Setting a property to null before deleting it doesn't accomplish
  anything (unless the object has been sealed by Object.seal and the
  delete fails. That's not usually the case unless you specifically
  try).</source>
          <target state="translated">å‰Šé™¤ã™ã‚‹å‰ã«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’nullã«è¨­å®šã—ã¦ã‚‚ä½•ã®åŠ¹æœã‚‚ã‚ã‚Šã¾ã›ã‚“(Object.sealã«ã‚ˆã£ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚·ãƒ¼ãƒ«ã•ã‚Œã¦ã„ã¦å‰Šé™¤ã«å¤±æ•—ã—ãŸå ´åˆã‚’é™¤ã)ã€‚é€šå¸¸ã¯ã€ç‰¹åˆ¥ãªè©¦ã¿ã‚’ã—ãªã„é™ã‚Šã€ã“ã®ã‚ˆã†ãªã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“)ã€‚)</target>
        </trans-unit>
        <trans-unit id="a1aeff6040cbaf4a052232c94541c2b536b4a1f3" translate="yes" xml:space="preserve">
          <source>Similarly, removing the entire students array would be done by calling &lt;code&gt;delete Hogwarts.students;&lt;/code&gt; or &lt;code&gt;delete Hogwarts['students'];&lt;/code&gt;.</source>
          <target state="translated">åŒæ§˜ã«ã€studentsé…åˆ—å…¨ä½“ã‚’ &lt;code&gt;delete Hogwarts.students;&lt;/code&gt; å‘¼ã³å‡ºã—ã¾ã™ã€‚ ã¾ãŸã¯ &lt;code&gt;delete Hogwarts['students'];&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="fd410e78d809f27ec1e3bdad4ee5576324a4212e" translate="yes" xml:space="preserve">
          <source>So as it turns out, there actually IS a built-in way to tell if an array is truly an array, and that is &lt;code&gt;Array.isArray()&lt;/code&gt;, introduced in ECMAScript 5 (December 2009). I found this while looking to see if there was a question asking about telling arrays from objects, to see if there was either a better solution than mine, or to add mine if there were none. So, if you're using a version of JavaScript that is earlier than ECMA 5, there's your polyfill. However, I strongly recommend against using my &lt;code&gt;is_array()&lt;/code&gt; function, as continuing to support old versions of JavaScript means continuing to support the old browsers that implement them, which means encouraging the use of insecure software and putting users at risk for malware. So please, use &lt;code&gt;Array.isArray()&lt;/code&gt;. Use &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. Use the new features that get added to the language. &lt;em&gt;Don't&lt;/em&gt; use vendor prefixes. &lt;em&gt;Delete&lt;/em&gt; that IE polyfill crap from your website. Delete that XHTML &lt;code&gt;&amp;lt;!CDATA[[...&lt;/code&gt; crap, too--we moved to HTML5 back in 2014. The sooner everybody withdraws support for those old/esoteric browsers, the sooner the browser vendors will actually follow the web standard and embrace the new technology, and the sooner we can move on to a more secure web.</source>
          <target state="translated">&lt;code&gt;Array.isArray()&lt;/code&gt; ã€å®Ÿéš›ã«ã¯ã€é…åˆ—ãŒæœ¬å½“ã«é…åˆ—ã§ã‚ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹çµ„ã¿è¾¼ã¿ã®æ–¹æ³•ãŒã‚ã‚Šã€ãã‚Œã¯ECMAScript 5ï¼ˆ2009å¹´12æœˆï¼‰ã§å°å…¥ã•ã‚ŒãŸArray.isArrayï¼ˆ ï¼‰ã§ã™ã€‚ é…åˆ—ã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰åŒºåˆ¥ã™ã‚‹ã“ã¨ã«ã¤ã„ã¦è³ªå•ãŒã‚ã‚‹ã‹ã©ã†ã‹ã€è‡ªåˆ†ã‚ˆã‚Šã‚‚å„ªã‚ŒãŸè§£æ±ºç­–ãŒã‚ã‚‹ã‹ã©ã†ã‹ã€ã¾ãŸã¯ãªã„å ´åˆã¯è¿½åŠ ã™ã‚‹ã‹ã©ã†ã‹ã‚’èª¿ã¹ã¦ã„ã‚‹ã¨ãã«ã€ã“ã‚Œã‚’è¦‹ã¤ã‘ã¾ã—ãŸã€‚ ã—ãŸãŒã£ã¦ã€ECMA 5ã‚ˆã‚Šå‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®JavaScriptã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹å ´åˆã¯ã€ãƒãƒªãƒ•ã‚£ãƒ«ãŒã‚ã‚Šã¾ã™ã€‚ ãŸã ã—ã€å¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®JavaScriptã‚’å¼•ãç¶šãã‚µãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã¯ã€ãã‚Œã‚‰ã‚’å®Ÿè£…ã™ã‚‹å¤ã„ãƒ–ãƒ©ã‚¦ã‚¶ãƒ¼ã‚’å¼•ãç¶šãã‚µãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã‚’æ„å‘³ã™ã‚‹ãŸã‚ã€ç§ã® &lt;code&gt;is_array()&lt;/code&gt; é–¢æ•°ã‚’ä½¿ç”¨ã—ãªã„ã“ã¨ã‚’å¼·ããŠå‹§ã‚ã—ã¾ã™ã€‚ã¤ã¾ã‚Šã€å®‰å…¨ã§ãªã„ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã®ä½¿ç”¨ã‚’å¥¨åŠ±ã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ãƒãƒ«ã‚¦ã‚§ã‚¢ã®ãƒªã‚¹ã‚¯ã«ã•ã‚‰ã—ã¾ã™ã€‚ ã—ãŸãŒã£ã¦ã€ &lt;code&gt;Array.isArray()&lt;/code&gt; ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚ &lt;code&gt;let&lt;/code&gt; ãŠã‚ˆã³ &lt;code&gt;const&lt;/code&gt; ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ è¨€èªã«è¿½åŠ ã•ã‚ŒãŸæ–°æ©Ÿèƒ½ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ ãƒ™ãƒ³ãƒ€ãƒ¼ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚’ä½¿ç”¨&lt;em&gt;ã—ãªã„ã§ãã ã•ã„&lt;/em&gt; ã€‚ ãã®IEãƒãƒªãƒ•ã‚£ãƒ«ã®ãŒã‚‰ããŸã‚’Webã‚µã‚¤ãƒˆã‹ã‚‰&lt;em&gt;å‰Šé™¤&lt;/em&gt;ã—ã¾ã™ã€‚ ãã®XHTML &lt;code&gt;&amp;lt;!CDATA[[...&lt;/code&gt; ãŒã‚‰ããŸã‚‚å‰Šé™¤ã—ã¾ã™-2014å¹´ã«HTML5ã«ç§»è¡Œã—ã¾ã—ãŸã€‚å¤ã„/é›£è§£ãªãƒ–ãƒ©ã‚¦ã‚¶ãƒ¼ã®ã‚µãƒãƒ¼ãƒˆã‚’èª°ã‚‚ãŒæ’¤å›ã™ã‚‹ã®ãŒæ—©ã‘ã‚Œã°æ—©ã„ã»ã©ã€ãƒ–ãƒ©ã‚¦ã‚¶ãƒ¼ãƒ™ãƒ³ãƒ€ãƒ¼ãŒå®Ÿéš›ã«Webæ¨™æº–ã«æº–æ‹ ã—ã€æ–°ã—ã„ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼ã€ãã—ã¦ã‚ˆã‚Šæ—©ãå®‰å…¨ãªã‚¦ã‚§ãƒ–ã«ç§»è¡Œã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c1074a68b7264ece395e8476f70ae784fc36b406" translate="yes" xml:space="preserve">
          <source>So, he sends you an email in anger:</source>
          <target state="translated">ãã“ã§ã€å½¼ã¯æ€’ã‚Šã®ãƒ¡ãƒ¼ãƒ«ã‚’é€ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1c63c8fdc7a32a45814f6f70f31838cecabdb16b" translate="yes" xml:space="preserve">
          <source>So, when deleting values from an object, always first consider whether you're dealing with object properties or whether you're dealing with array values, and choose the appropriate strategy based on that.</source>
          <target state="translated">ã§ã™ã‹ã‚‰ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰å€¤ã‚’å‰Šé™¤ã™ã‚‹ã¨ãã«ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æ‰±ã£ã¦ã„ã‚‹ã®ã‹ã€é…åˆ—ã®å€¤ã‚’æ‰±ã£ã¦ã„ã‚‹ã®ã‹ã‚’å¸¸ã«æœ€åˆã«è€ƒãˆã¦ã€ãã‚Œã«åŸºã¥ã„ã¦é©åˆ‡ãªæˆ¦ç•¥ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="da5db28dd16264310f46eacb87a0cb2b9ceef675" translate="yes" xml:space="preserve">
          <source>Sorry if this didn't add to your specific use case but I believe this to be a good design to adapt when managing objects and their properties.</source>
          <target state="translated">ç‰¹å®šã®ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã«å½“ã¦ã¯ã¾ã‚‰ãªã‹ã£ãŸã‚‰ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ãŒã€ã“ã‚Œã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ãã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ç®¡ç†ã™ã‚‹éš›ã«é©å¿œã™ã‚‹ãŸã‚ã®è‰¯ã„ãƒ‡ã‚¶ã‚¤ãƒ³ã ã¨æ€ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ace92799b8ad9dc2af653b95d2a4f16910423d4b" translate="yes" xml:space="preserve">
          <source>Suppose you have an object that looks like this:</source>
          <target state="translated">ã“ã®ã‚ˆã†ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚ã‚‹ã¨ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c5229642bf5961f2b277471727e88e647035ac9e" translate="yes" xml:space="preserve">
          <source>Syntax-based string property omission</source>
          <target state="translated">æ§‹æ–‡ãƒ™ãƒ¼ã‚¹ã®æ–‡å­—åˆ—ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®çœç•¥</target>
        </trans-unit>
        <trans-unit id="07c468c127104c88b077c6e07b9d9ec7d4fdbf7d" translate="yes" xml:space="preserve">
          <source>THE LONG VERSION</source>
          <target state="translated">é•·ç·¨</target>
        </trans-unit>
        <trans-unit id="11405ca028271229b8731c4ce6c20d04dc54cc92" translate="yes" xml:space="preserve">
          <source>THE SHORT VERSION</source>
          <target state="translated">çŸ­ç·¨</target>
        </trans-unit>
        <trans-unit id="39fdec1194d94212b871a28b2aa04a73cd40fce1" translate="yes" xml:space="preserve">
          <source>Tests</source>
          <target state="translated">Tests</target>
        </trans-unit>
        <trans-unit id="748beb2ad7204d2997b5d2a12f2e0bc89bcc8e5e" translate="yes" xml:space="preserve">
          <source>That actually isn't what's happening, but it's easier to think of that way. According to MDN, here's what's actually happening:</source>
          <target state="translated">å®Ÿéš›ã«èµ·ãã¦ã„ã‚‹ã®ã¯ãã†ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€ãã®æ–¹ãŒè€ƒãˆã‚„ã™ã„ã§ã—ã‚‡ã†ã€‚MDNã«ã‚ˆã‚‹ã¨ã€å®Ÿéš›ã«èµ·ãã¦ã„ã‚‹ã“ã¨ã¯ã“ã‚“ãªæ„Ÿã˜ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="cf85fec62dde51f1637af10a625442c3baea4c48" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;delete operator&lt;/a&gt; is the best way to do so.</source>
          <target state="translated">ã“ã‚Œã‚’è¡Œã†ã«ã¯ã€ &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;å‰Šé™¤æ¼”ç®—å­&lt;/a&gt;ãŒæœ€é©ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="881ea24ac20b3a2b7bbbd8208c871ee412db982f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;key remains on its place in the hashmap&lt;/strong&gt;, only the value is replaced with &lt;code&gt;undefined&lt;/code&gt;. Understand, that &lt;code&gt;for..in&lt;/code&gt; loop will still iterate over that key.</source>
          <target state="translated">&lt;strong&gt;ã‚­ãƒ¼ã¯ãƒãƒƒã‚·ãƒ¥ãƒãƒƒãƒ—ã®ãã®å ´æ‰€ã«æ®‹ã‚Š&lt;/strong&gt; ã€å€¤ã ã‘ãŒ &lt;code&gt;undefined&lt;/code&gt; ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚ ãã® &lt;code&gt;for..in&lt;/code&gt; ãƒ«ãƒ¼ãƒ—ã¯ã€ãã®ã‚­ãƒ¼ã‚’ç¹°ã‚Šè¿”ã—å‡¦ç†ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="edc38116420d64a21ebfee30ed9c7476267110df" translate="yes" xml:space="preserve">
          <source>The Solution: &lt;code&gt;Array.prototype.splice&lt;/code&gt;</source>
          <target state="translated">ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ï¼š &lt;code&gt;Array.prototype.splice&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="071cbdf7a24a78eb243d7c493b80aadba4657908" translate="yes" xml:space="preserve">
          <source>The actual answer to the question</source>
          <target state="translated">å®Ÿéš›ã®ç­”ãˆã¯</target>
        </trans-unit>
        <trans-unit id="c0ec14910cf4674ceea7f9ad991e964445d6c9ac" translate="yes" xml:space="preserve">
          <source>The answer would be to &lt;strong&gt;delete all the references you have in your code, pointed to that very object&lt;/strong&gt; and also &lt;strong&gt;not use &lt;code&gt;var&lt;/code&gt; statements to create new references to that object&lt;/strong&gt;. This last point regarding &lt;code&gt;var&lt;/code&gt; statements, is one of the most crucial issues that we are usually faced with, because using &lt;code&gt;var&lt;/code&gt; statements would prevent the created object from getting removed.</source>
          <target state="translated">ç­”ãˆã¯&lt;strong&gt;ã€ã‚³ãƒ¼ãƒ‰å†…ã«ã‚ã‚‹ã™ã¹ã¦ã®å‚ç…§&lt;/strong&gt;ã‚’&lt;strong&gt;å‰Šé™¤ã—ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªä½“ã‚’æŒ‡ã—ç¤ºã—ã€&lt;/strong&gt; &lt;strong&gt; &lt;code&gt;var&lt;/code&gt; ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã‚’ä½¿ç”¨ã—ã¦ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®æ–°ã—ã„å‚ç…§ã‚’ä½œæˆã—ãªã„ã“ã¨&lt;/strong&gt;ã§ã™ã€‚ &lt;code&gt;var&lt;/code&gt; ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã«é–¢ã™ã‚‹ã“ã®æœ€å¾Œã®ãƒã‚¤ãƒ³ãƒˆã¯ã€ varã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ä½œæˆã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‰Šé™¤ã•ã‚Œãªããªã‚‹ãŸã‚ã€é€šå¸¸ç›´é¢ã™ã‚‹æœ€ã‚‚é‡è¦ãªå•é¡Œã®1ã¤ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c25007fa1063a6b669074a068e8e0d9c200dbaad" translate="yes" xml:space="preserve">
          <source>The contrived and long-winded PDP-11 scenario</source>
          <target state="translated">æé€ ã•ã‚ŒãŸé•·æ–‡ã®PDP-11ã®ã‚·ãƒŠãƒªã‚ª</target>
        </trans-unit>
        <trans-unit id="f621835acbbff87822c037f614ae8feebd84f7e5" translate="yes" xml:space="preserve">
          <source>The delete operator removes a given property from an object. On
  successful deletion, it will return true, else false will be returned.
  However, it is important to consider the following scenarios:</source>
          <target state="translated">delete æ¼”ç®—å­ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰æŒ‡å®šã•ã‚ŒãŸãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å‰Šé™¤ã—ã¾ã™ã€‚å‰Šé™¤ã«æˆåŠŸã—ãŸå ´åˆã¯trueã‚’è¿”ã—ã€ãã†ã§ãªã„å ´åˆã¯falseã‚’è¿”ã—ã¾ã™ã€‚ã—ã‹ã—ã€ä»¥ä¸‹ã®ã‚·ãƒŠãƒªã‚ªã‚’è€ƒæ…®ã™ã‚‹ã“ã¨ãŒé‡è¦ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="88d438bbfeb05c4266f6e27b90dcb851c6f60ce6" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;deleteProperty&lt;/code&gt; is when using strict mode:</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; ã¨ &lt;code&gt;deleteProperty&lt;/code&gt; ã®é•ã„ã¯ã€strictãƒ¢ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="efccd6cd704a79d07bccddefc3adbae94e968c39" translate="yes" xml:space="preserve">
          <source>The following snippet gives another simple example:</source>
          <target state="translated">ä»¥ä¸‹ã®ã‚¹ãƒ‹ãƒšãƒƒãƒˆã¯ã€åˆ¥ã®ç°¡å˜ãªä¾‹ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="bf8a2a946389853c6d0799bf61400c9d604dd48d" translate="yes" xml:space="preserve">
          <source>The index specified by &lt;code&gt;end&lt;/code&gt; is simply excluded from the slice. The parenthesized indices indicate what gets sliced. Either way, the behavior is not intuitive and it's bound to cause its fair share of off-by-one errors, so you might find it useful to make a wrapper function to more closely emulate the behavior of &lt;code&gt;.splice()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;end&lt;/code&gt; ã§æŒ‡å®šã•ã‚ŒãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯ã€å˜ã«ã‚¹ãƒ©ã‚¤ã‚¹ã‹ã‚‰é™¤å¤–ã•ã‚Œã¾ã™ã€‚ æ‹¬å¼§ã§å›²ã¾ã‚ŒãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯ã€ä½•ãŒã‚¹ãƒ©ã‚¤ã‚¹ã•ã‚Œã‚‹ã‹ã‚’ç¤ºã—ã¾ã™ã€‚ ã©ã¡ã‚‰ã®æ–¹æ³•ã§ã‚‚ã€å‹•ä½œã¯ç›´æ„Ÿçš„ã§ã¯ãªãã€ã‚ªãƒ• &lt;code&gt;.splice()&lt;/code&gt; ã‚¨ãƒ©ãƒ¼ã®å…¬å¹³ãªå…±æœ‰ã‚’å¼•ãèµ·ã“ã™ãŸã‚ã€ãƒ©ãƒƒãƒ‘ãƒ¼é–¢æ•°ã‚’ä½œæˆã—ã¦.spliceï¼ˆï¼‰ã®å‹•ä½œã‚’ã‚ˆã‚Šå³å¯†ã«ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹ã¨ä¾¿åˆ©ãªå ´åˆãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="367c08658a0eaac4d7f551272d9531077bdd6a38" translate="yes" xml:space="preserve">
          <source>The other important point here is to be careful about your other references to the same object. For instance, if you create a variable like:</source>
          <target state="translated">ã“ã“ã§ã®ã‚‚ã†ä¸€ã¤ã®é‡è¦ãªãƒã‚¤ãƒ³ãƒˆã¯ã€åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ä»–ã®å‚ç…§ã«æ³¨æ„ã™ã‚‹ã“ã¨ã§ã™ã€‚ä¾‹ãˆã°ã€å¤‰æ•°ã‚’ä½œæˆã—ãŸå ´åˆã€‚</target>
        </trans-unit>
        <trans-unit id="556ff37bb94e5cbb3dd116d5ddf709d4c4f7ed56" translate="yes" xml:space="preserve">
          <source>The programming ethos/patterns you and your team use. Do you favor functional approaches and mutation is verboten on your team, or do you employ wild west mutative object-oriented techniques?</source>
          <target state="translated">ã‚ãªãŸã¨ã‚ãªãŸã®ãƒãƒ¼ãƒ ãŒä½¿ç”¨ã—ã¦ã„ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®å€«ç†ãƒ‘ã‚¿ãƒ¼ãƒ³ã€‚ã‚ãªãŸã®ãƒãƒ¼ãƒ ã§ã¯æ©Ÿèƒ½çš„ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒãŒå¥½ã¾ã‚Œã€çªç„¶å¤‰ç•°ã¯ç¦æ­¢ã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6357292b24fba94284af6389041f255b8a00f04f" translate="yes" xml:space="preserve">
          <source>The range of object types you want to remove properties on and the type of property names you need to be able to omit (Strings only? Symbols? Weak references mapped from arbitrary objects? These have all been types of property pointers in JavaScript for years now)</source>
          <target state="translated">ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å‰Šé™¤ã—ãŸã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—ã®ç¯„å›²ã¨ã€çœç•¥ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£åã®ã‚¿ã‚¤ãƒ—(æ–‡å­—åˆ—ã®ã¿?è¨˜å·ã®ã¿?ä»»æ„ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ãƒãƒƒãƒ—ã•ã‚ŒãŸå¼±ã„å‚ç…§?ã“ã‚Œã‚‰ã¯ã™ã¹ã¦JavaScriptã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ»ãƒã‚¤ãƒ³ã‚¿ã®å‹ã¨ã—ã¦ä½•å¹´ã‚‚å‰ã‹ã‚‰å­˜åœ¨ã—ã¦ã„ã¾ã™)</target>
        </trans-unit>
        <trans-unit id="3fea2fb86e2276224dff32e33243b1e22287ed2d" translate="yes" xml:space="preserve">
          <source>The reason for writing this new &lt;code&gt;unset&lt;/code&gt; function, is to keep the index of all other variables in this hash_map. Look at the following example, and see how the index of &quot;test2&quot; did not change after removing a value from the hash_map.</source>
          <target state="translated">ã“ã®æ–°ã—ã„ &lt;code&gt;unset&lt;/code&gt; é–¢æ•°ã‚’ä½œæˆã™ã‚‹ç†ç”±ã¯ã€ã“ã®hash_mapå†…ã®ä»–ã®ã™ã¹ã¦ã®å¤‰æ•°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä¿æŒã™ã‚‹ãŸã‚ã§ã™ã€‚ æ¬¡ã®ä¾‹ã‚’è¦‹ã¦ã€hash_mapã‹ã‚‰å€¤ã‚’å‰Šé™¤ã—ãŸå¾Œã€ã€Œtest2ã€ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒã©ã®ã‚ˆã†ã«å¤‰åŒ–ã—ãªã‹ã£ãŸã‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="e16825f749b4e5fb7d1fecf43d4e6b653061e2e8" translate="yes" xml:space="preserve">
          <source>The result would be &lt;code&gt;false&lt;/code&gt;, which means that your delete statement haven't been executed as you expected. But if you had not created that variable before, and you only had &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; as your last existing reference, you could have done this just by removing it like:</source>
          <target state="translated">çµæœã¯ &lt;code&gt;false&lt;/code&gt; ã«ãªã‚Šã¾ã™ ã€‚ã“ã‚Œã¯ã€deleteã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆãŒæœŸå¾…ã©ãŠã‚Šã«å®Ÿè¡Œã•ã‚Œãªã‹ã£ãŸã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ ã—ã‹ã—ã€ãã®å¤‰æ•°ã‚’ä»¥å‰ã«ä½œæˆã—ãŸã“ã¨ãŒãªãã€ &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; ã®ã¿ãŒæœ€å¾Œã®æ—¢å­˜ã®å‚ç…§ã§ã‚ã‚‹å ´åˆã¯ã€æ¬¡ã®ã‚ˆã†ã«å‰Šé™¤ã™ã‚‹ã ã‘ã§ã“ã‚Œã‚’å®Ÿè¡Œã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f6481accf44872d4ef8745c055193c2829ccd3cb" translate="yes" xml:space="preserve">
          <source>The term you have used in your question title &lt;code&gt;Remove a property from a JavaScript object&lt;/code&gt;, can be interpreted in some different ways. The one is to remove it for whole the memory and the list of object keys or the other is just to remove it from your object. As it has been mentioned in some other answers, the &lt;code&gt;delete&lt;/code&gt; keyword is the main part. Let's say you have your object like:</source>
          <target state="translated">è³ªå•ã®ã‚¿ã‚¤ãƒˆãƒ«ã§ä½¿ç”¨ã—ãŸç”¨èª &lt;code&gt;Remove a property from a JavaScript object&lt;/code&gt; ã¯ã€ã„ãã¤ã‹ã®ç•°ãªã‚‹æ–¹æ³•ã§è§£é‡ˆã§ãã¾ã™ã€‚ 1ã¤ã¯ãƒ¡ãƒ¢ãƒªå…¨ä½“ã¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚­ãƒ¼ã®ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤ã™ã‚‹æ–¹æ³•ã€ã‚‚ã†1ã¤ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰å‰Šé™¤ã™ã‚‹æ–¹æ³•ã§ã™ã€‚ ä»–ã®ã„ãã¤ã‹ã®å›ç­”ã§è¨€åŠã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ã«ã€ &lt;code&gt;delete&lt;/code&gt; ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒä¸»è¦ãªéƒ¨åˆ†ã§ã™ã€‚ æ¬¡ã®ã‚ˆã†ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚ã‚‹ã¨ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d7c42d645c208dfd4e3c38a50db94ab5a07bdf03" translate="yes" xml:space="preserve">
          <source>The version of ECMAScript you're targeting</source>
          <target state="translated">å¯¾è±¡ã¨ã™ã‚‹ ECMAScript ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³</target>
        </trans-unit>
        <trans-unit id="2d17e745883099706ab5b904d19b87cebce1764f" translate="yes" xml:space="preserve">
          <source>Then even if you remove it from your object &lt;code&gt;myJSONObject&lt;/code&gt;, that specific object won't get deleted from the memory, since the &lt;code&gt;regex&lt;/code&gt; variable and &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; still have their values. Then how could we remove the object from the memory for sure?</source>
          <target state="translated">æ¬¡ã«ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ &lt;code&gt;myJSONObject&lt;/code&gt; ã‹ã‚‰å‰Šé™¤ã—ã¦ã‚‚ã€ &lt;code&gt;regex&lt;/code&gt; å¤‰æ•°ã¨ &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; ã¾ã å€¤ãŒã‚ã‚‹ãŸã‚ã€ãã®ç‰¹å®šã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ¡ãƒ¢ãƒªã‹ã‚‰å‰Šé™¤ã•ã‚Œã¾ã›ã‚“ã€‚ ã§ã¯ã€ã©ã†ã™ã‚Œã°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ¡ãƒ¢ãƒªã‹ã‚‰ç¢ºå®Ÿã«å‰Šé™¤ã§ãã‚‹ã§ã—ã‚‡ã†ã‹ã€‚</target>
        </trans-unit>
        <trans-unit id="9f315ff9ba259ec4af4aad477da9caf99c783595" translate="yes" xml:space="preserve">
          <source>Then your objects key using &lt;code&gt;Object.keys(myJSONObject)&lt;/code&gt; would be:</source>
          <target state="translated">æ¬¡ã«ã€ &lt;code&gt;Object.keys(myJSONObject)&lt;/code&gt; ã‚’ä½¿ç”¨ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚­ãƒ¼ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="950ba1d1f6aad6e3258d15bc7f08a5e034f6a816" translate="yes" xml:space="preserve">
          <source>There are a lot of good answers here but I just want to chime in that when using delete to remove a property in JavaScript, it is often wise to first check if that property exists to prevent errors.</source>
          <target state="translated">ã“ã“ã«ã¯å¤šãã®è‰¯ã„ç­”ãˆãŒã‚ã‚Šã¾ã™ãŒã€JavaScriptã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å‰Šé™¤ã™ã‚‹ãŸã‚ã«deleteã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€ã‚¨ãƒ©ãƒ¼ã‚’é˜²ããŸã‚ã«ãã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒå­˜åœ¨ã™ã‚‹ã‹ã©ã†ã‹ã‚’æœ€åˆã«ç¢ºèªã™ã‚‹ã®ãŒè³¢æ˜ã§ã‚ã‚‹ã“ã¨ãŒå¤šã„ã¨ã„ã†ã“ã¨ã‚’è¿°ã¹ã¦ãŠããŸã„ã¨æ€ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="57100a7adc73f2ac8fb1259dcb31d2cae8056822" translate="yes" xml:space="preserve">
          <source>There are few common ways to remove a property from an object.</source>
          <target state="translated">ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å‰Šé™¤ã™ã‚‹ä¸€èˆ¬çš„ãªæ–¹æ³•ã¯ã»ã¨ã‚“ã©ã‚ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="8604def9bd3e30573031d5be629fb2bb0c18ca39" translate="yes" xml:space="preserve">
          <source>There are many different options presented on this page, not because most of the options are wrong&amp;mdash;or because the answers are duplicates&amp;mdash;but because the appropriate technique depends on the situation you're in and the goals of the tasks you and/or you team are trying to fulfill. To answer you question unequivocally, one needs to know:</source>
          <target state="translated">ã“ã®ãƒšãƒ¼ã‚¸ã«ã¯ã•ã¾ã–ã¾ãªã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ãŒã€ã»ã¨ã‚“ã©ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒé–“é•ã£ã¦ã„ã‚‹ãŸã‚ã€ã¾ãŸã¯å›ç­”ãŒé‡è¤‡ã—ã¦ã„ã‚‹ãŸã‚ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€é©åˆ‡ãªæ‰‹æ³•ã¯ã€ç¾åœ¨ã®çŠ¶æ³ã¨ã€ã‚ãªãŸã‚„ã‚ãªãŸè‡ªèº«ã®ã‚¿ã‚¹ã‚¯ã®ç›®æ¨™ã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™ã€‚ãƒãƒ¼ãƒ ã¯å®Ÿç¾ã—ã‚ˆã†ã¨ã—ã¦ã„ã¾ã™ã€‚ æ˜ç¢ºã«è³ªå•ã«ç­”ãˆã‚‹ã«ã¯ã€æ¬¡ã®ã“ã¨ã‚’çŸ¥ã£ã¦ãŠãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5f1efa2f9fb405d638f74fe5349dbabb89e0514a" translate="yes" xml:space="preserve">
          <source>They are slow &amp;amp; memory inefficient. When accessing a specific index, instead of just getting the global type for the array, the browser instead has to get the type on a per-index basis whereby each index stores the additional metadata of its type.</source>
          <target state="translated">ãã‚Œã‚‰ã¯é…ãã€ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ãŒæ‚ªã„ã€‚ ç‰¹å®šã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹å ´åˆã€ãƒ–ãƒ©ã‚¦ã‚¶ã¯é…åˆ—ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¿ã‚¤ãƒ—ã‚’å–å¾—ã™ã‚‹ã ã‘ã§ãªãã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã”ã¨ã«ã‚¿ã‚¤ãƒ—ã‚’å–å¾—ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€å„ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯ãã®ã‚¿ã‚¤ãƒ—ã®è¿½åŠ ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æ ¼ç´ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="afa3b2f30890db447e4cf00d9f2dcec7b332b01b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;ES6&lt;/code&gt; operator allows us to return a brand new object, excluding any properties, without mutating the existing object. The downside is that it has the worse performance out of the above and not suggested to be used when you need to remove many properties at a time.</source>
          <target state="translated">ã“ã® &lt;code&gt;ES6&lt;/code&gt; æ¼”ç®—å­ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€æ—¢å­˜ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å¤‰æ›´ã›ãšã«ã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’é™¤å¤–ã—ãŸæ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ã“ã¨ãŒã§ãã¾ã™ã€‚ æ¬ ç‚¹ã¯ã€ä¸Šè¨˜ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒä½ä¸‹ã™ã‚‹ã“ã¨ã§ã‚ã‚Šã€ä¸€åº¦ã«å¤šãã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å‰Šé™¤ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã«ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯æ¨å¥¨ã•ã‚Œã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="9e7248bc6c7cf17aeb43a8906d8cc8e3b531512b" translate="yes" xml:space="preserve">
          <source>This alternative is not the correct answer to this question! But, if you use it with care, you can dramatically speed up some algorithms. If you are using &lt;code&gt;delete&lt;/code&gt; in loops and you have problems with performance, read the verbose explanation.</source>
          <target state="translated">ã“ã®é¸æŠè‚¢ã¯ã€ã“ã®è³ªå•ã«å¯¾ã™ã‚‹æ­£ã—ã„ç­”ãˆã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼ ãŸã ã—ã€æ³¨æ„ã—ã¦ä½¿ç”¨ã™ã‚‹ã¨ã€ä¸€éƒ¨ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å¤§å¹…ã«é«˜é€ŸåŒ–ã§ãã¾ã™ã€‚ ãƒ«ãƒ¼ãƒ—å†…ã§ &lt;code&gt;delete&lt;/code&gt; ã‚’ä½¿ç”¨ã—ã¦ã„ã¦ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã«å•é¡ŒãŒã‚ã‚‹å ´åˆã¯ã€è©³ç´°ãªèª¬æ˜ã‚’èª­ã‚“ã§ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="d2696a11c056f55fc8c70ea4ff94e4f5922248e1" translate="yes" xml:space="preserve">
          <source>This category is for operating on object literals or object instances when you want to retain/continue to use the original reference and aren't using stateless functional principles in your code. An example piece of syntax in this category:</source>
          <target state="translated">ã“ã®ã‚«ãƒ†ã‚´ãƒªã¯ã€å…ƒã®å‚ç…§ã‚’ç¶™ç¶šã—ã¦ä½¿ç”¨ã—ã€ã‚³ãƒ¼ãƒ‰ã§ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹ãªæ©Ÿèƒ½åŸç†ã‚’ä½¿ç”¨ã—ã¦ã„ãªã„å ´åˆã«ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ãƒªãƒ†ãƒ©ãƒ«ã¾ãŸã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ“ä½œã™ã‚‹ãŸã‚ã®ã‚«ãƒ†ã‚´ãƒªã§ã™ã€‚ã“ã®ã‚«ãƒ†ã‚´ãƒªã®æ§‹æ–‡ã®ä¾‹ã€‚</target>
        </trans-unit>
        <trans-unit id="1f8c0c20dd501470cb117b73c855e583ae2e0193" translate="yes" xml:space="preserve">
          <source>This category is for operating on object literals or object instances when you want to retain/continue to use the original reference while guarding against exceptions being thrown on unconfigurable properties:</source>
          <target state="translated">ã“ã®ã‚«ãƒ†ã‚´ãƒªã¯ã€æ§‹æˆä¸å¯èƒ½ãªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«å¯¾ã—ã¦ä¾‹å¤–ãŒã‚¹ãƒ­ãƒ¼ã•ã‚Œã‚‹ã“ã¨ã‚’é˜²ããªãŒã‚‰ã€å…ƒã®å‚ç…§ã‚’ç¶™ç¶šã—ã¦ä½¿ç”¨ã—ãŸã„å ´åˆã«ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ»ãƒªãƒ†ãƒ©ãƒ«ã‚„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ»ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ“ä½œã™ã‚‹ãŸã‚ã®ã‚«ãƒ†ã‚´ãƒªã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="94bdb987c00caa2e598854f97ea3c6de4e30eedf" translate="yes" xml:space="preserve">
          <source>This category is for operating on plain object or array instances in newer ECMAScript flavors when a non-mutative approach is desired and you don't need to account for Symbol keys:</source>
          <target state="translated">ã“ã®ã‚«ãƒ†ã‚´ãƒªã¯ã€æ–°ã—ã„ECMAScriptã®ãƒ•ãƒ¬ãƒ¼ãƒãƒ¼ã®ãƒ—ãƒ¬ãƒ¼ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚„é…åˆ—ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ“ä½œã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã€éäº’å¤‰çš„ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒãŒå¿…è¦ãªå ´åˆã‚„ã€Symbolã‚­ãƒ¼ã‚’è€ƒæ…®ã™ã‚‹å¿…è¦ãŒãªã„å ´åˆã«ä½¿ç”¨ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="aba34382b27aca74b69be04c741119ab744a49b9" translate="yes" xml:space="preserve">
          <source>This category is generally allows for greater functional flexibility, including accounting for Symbols &amp;amp; omitting more than one property in one statement:</source>
          <target state="translated">ã“ã®ã‚«ãƒ†ã‚´ãƒªã§ã¯é€šå¸¸ã€è¨˜å·ã®è€ƒæ…®ã‚„1ã¤ã®ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã§ã®è¤‡æ•°ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®çœç•¥ãªã©ã€æ©Ÿèƒ½ã®æŸ”è»Ÿæ€§ãŒå‘ä¸Šã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="17ff7f9c0c298023ffef1288d23c2efc74ebdf5c" translate="yes" xml:space="preserve">
          <source>This category is the oldest, most straightforward &amp;amp; most widely supported category of property removal. It supports &lt;code&gt;Symbol&lt;/code&gt; &amp;amp; array indexes in addition to strings and works in every version of JavaScript except for the very first release. However, it's mutative which violates some programming principles and has performance implications. It also can result in uncaught exceptions when used on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;non-configurable properties in strict mode&lt;/a&gt;.</source>
          <target state="translated">ã“ã®ã‚«ãƒ†ã‚´ãƒªã¯ã€æœ€ã‚‚å¤ãã€æœ€ã‚‚ã‚ã‹ã‚Šã‚„ã™ãã€æœ€ã‚‚åºƒãã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å‰Šé™¤ã®ã‚«ãƒ†ã‚´ãƒªã§ã™ã€‚ æ–‡å­—åˆ—ã«åŠ ãˆã¦ &lt;code&gt;Symbol&lt;/code&gt; ã¨é…åˆ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ã‚µãƒãƒ¼ãƒˆã—ã€æœ€åˆã®ãƒªãƒªãƒ¼ã‚¹ã‚’é™¤ãã™ã¹ã¦ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®JavaScriptã§æ©Ÿèƒ½ã—ã¾ã™ã€‚ ãŸã ã—ã€ä¸€éƒ¨ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°åŸå‰‡ã«é•åã—ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã«å½±éŸ¿ã‚’ä¸ãˆã‚‹å¤‰ç•°ã§ã™ã€‚ &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;strictãƒ¢ãƒ¼ãƒ‰ã®è¨­å®šä¸å¯èƒ½ãªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã§&lt;/a&gt;ä½¿ç”¨ã™ã‚‹ã¨ã€ã‚­ãƒ£ãƒƒãƒã•ã‚Œãªã„ä¾‹å¤–ãŒç™ºç”Ÿã™ã‚‹å¯èƒ½æ€§ã‚‚ã‚ã‚Šã¾ã™ ã€‚</target>
        </trans-unit>
        <trans-unit id="4ad77472ac7767c23050851eada92d065c2bd943" translate="yes" xml:space="preserve">
          <source>This is in regard to this (now-removed) snippet:</source>
          <target state="translated">ã“ã‚Œã¯ã€ã“ã®(ç¾åœ¨ã¯å‰Šé™¤ã•ã‚ŒãŸ)ã‚¹ãƒ‹ãƒšãƒƒãƒˆã«é–¢ã™ã‚‹ã‚‚ã®ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="21292c660408d1ff92d4a1c2c4eafdd76c276e51" translate="yes" xml:space="preserve">
          <source>This post is very old and I find it very helpful so I decided to share the unset function I wrote in case someone else see this post and think why it's not so simple as it in PHP unset function.</source>
          <target state="translated">ã“ã®è¨˜äº‹ã¯éå¸¸ã«å¤ãã€ç§ã¯ãã‚ŒãŒéå¸¸ã«æœ‰ç”¨ã§ã‚ã‚‹ã“ã¨ã‚’è¦‹ã¤ã‘ã‚‹ã®ã§ã€ç§ã¯ä»–ã®èª°ã‹ãŒã“ã®è¨˜äº‹ã‚’è¦‹ã¦ã€ãªãœãã‚Œã¯PHPã®ã‚¢ãƒ³ã‚»ãƒƒãƒˆé–¢æ•°ã§ãã‚Œã®ã‚ˆã†ã«å˜ç´”ã§ã¯ãªã„ã¨æ€ã†å ´åˆã«ã¯ã€ç§ãŒæ›¸ã„ãŸã‚¢ãƒ³ã‚»ãƒƒãƒˆé–¢æ•°ã‚’å…±æœ‰ã™ã‚‹ã“ã¨ã«ã—ã¾ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="9603916ceb02f62ecad35613c65fb5ceed83b60d" translate="yes" xml:space="preserve">
          <source>This works in Firefox and Internet&amp;nbsp;Explorer, and I think it works in all others.</source>
          <target state="translated">ã“ã‚Œã¯Firefoxã¨Internet Explorerã§æ©Ÿèƒ½ã—ã€ä»–ã®ã™ã¹ã¦ã®æ©Ÿèƒ½ã§æ©Ÿèƒ½ã™ã‚‹ã¨æ€ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c685cc94e2b05416a2b9215116753bb12c7af729" translate="yes" xml:space="preserve">
          <source>To complete @Koen answer in this thread, in case you want to remove dynamic variable using the spread syntax, you can do it like so:</source>
          <target state="translated">ã“ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã§ã®@Koenã•ã‚“ã®å›ç­”ã‚’å®Œçµã•ã›ã‚‹ãŸã‚ã«ã€ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰æ§‹æ–‡ã‚’ä½¿ã£ã¦å‹•çš„å¤‰æ•°ã‚’å‰Šé™¤ã—ãŸã„å ´åˆã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a792292997434d58f8b1d7da4af78863ac5e4684" translate="yes" xml:space="preserve">
          <source>To get more info on &lt;code&gt;Object.seal&lt;/code&gt;: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal&quot;&gt;Object.seal()&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;Object.seal&lt;/code&gt; ã®è©³ç´°æƒ…å ±ã‚’å–å¾—ã™ã‚‹ã«ã¯ï¼š &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal&quot;&gt;Object.sealï¼ˆï¼‰&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96589c0ac9acf3a6b58f6928336639e582088ee3" translate="yes" xml:space="preserve">
          <source>To reassign to the same variable, use a &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">åŒã˜å¤‰æ•°ã«å†åº¦å‰²ã‚Šå½“ã¦ã‚‹ã«ã¯ã€ &lt;code&gt;let&lt;/code&gt; ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="21af806df3feb60911002a77c4380b2b484f7bbf" translate="yes" xml:space="preserve">
          <source>To remove any property, say &lt;code&gt;key1&lt;/code&gt;, use the &lt;code&gt;delete&lt;/code&gt; keyword like this:</source>
          <target state="translated">&lt;code&gt;key1&lt;/code&gt; ãªã©ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å‰Šé™¤ã™ã‚‹ã«ã¯ã€æ¬¡ã®ã‚ˆã†ã« &lt;code&gt;delete&lt;/code&gt; ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="fa15c129befde7656ac754122a25210685ef2188" translate="yes" xml:space="preserve">
          <source>To summarize, differences are all about ways of determining the property existence, and about &lt;code&gt;for..in&lt;/code&gt; loop.</source>
          <target state="translated">è¦ç´„ã™ã‚‹ã¨ã€é•ã„ã¯ã™ã¹ã¦ã€ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å­˜åœ¨ã‚’åˆ¤æ–­ã™ã‚‹æ–¹æ³•ã¨ã€ &lt;code&gt;for..in&lt;/code&gt; ãƒ«ãƒ¼ãƒ—ã«ã¤ã„ã¦ã§ã™ ã€‚</target>
        </trans-unit>
        <trans-unit id="87501fb0e92ec552bdf306c07f48852286e9c8c8" translate="yes" xml:space="preserve">
          <source>To whoever needs it...</source>
          <target state="translated">å¿…è¦ãªäººã«...</target>
        </trans-unit>
        <trans-unit id="b7ff74710b25d787ff3d518b1667a655a5936c78" translate="yes" xml:space="preserve">
          <source>Try the following method. Assign the &lt;code&gt;Object&lt;/code&gt; property value to &lt;code&gt;undefined&lt;/code&gt;. Then &lt;code&gt;stringify&lt;/code&gt; the object and &lt;code&gt;parse&lt;/code&gt;.</source>
          <target state="translated">æ¬¡ã®æ–¹æ³•ã‚’è©¦ã—ã¦ãã ã•ã„ã€‚ &lt;code&gt;Object&lt;/code&gt; ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å€¤ã‚’ &lt;code&gt;undefined&lt;/code&gt; ã«å‰²ã‚Šå½“ã¦ã¾ã™ã€‚ æ¬¡ã«ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ &lt;code&gt;stringify&lt;/code&gt; ã¦ &lt;code&gt;parse&lt;/code&gt; ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3d82a9f15156c36519fc72f9af221c32d7422e29" translate="yes" xml:space="preserve">
          <source>Try this</source>
          <target state="translated">ã“ã‚Œã‚’è©¦ã—ã¦ã¿ã¦ãã ã•ã„</target>
        </trans-unit>
        <trans-unit id="828f97e6c91f157ecd45fc8183a07ca7b4e95e6f" translate="yes" xml:space="preserve">
          <source>Update regarding &lt;code&gt;is_array()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;is_array()&lt;/code&gt; ã«é–¢ã™ã‚‹æ›´æ–°</target>
        </trans-unit>
        <trans-unit id="d45aa1f9d8100f951a216d7ce715ec8d99477eb3" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://ramdajs.com/docs/#dissoc&quot;&gt;ramda#dissoc&lt;/a&gt; you will get a new object without the attribute &lt;code&gt;regex&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://ramdajs.com/docs/#dissoc&quot;&gt;ramdaï¼ƒdissoc&lt;/a&gt;ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€å±æ€§ &lt;code&gt;regex&lt;/code&gt; ãªã—ã§æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¾—ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="930151a2e26bf074e4b81d244de5799b750be707" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;delete&lt;/strong&gt; method is the best way to do that, as per MDN description, the delete operator removes a property from an object. So you can simply write:</source>
          <target state="translated">ã“ã‚Œã‚’è¡Œã†ã«ã¯ã€MDNã®èª¬æ˜ã«å¾“ã£ã¦ã€ &lt;strong&gt;delete&lt;/strong&gt;ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨&lt;strong&gt;ã™ã‚‹ã®&lt;/strong&gt;ãŒæœ€è‰¯ã®æ–¹æ³•ã§ã™ã€‚deleteæ¼”ç®—å­ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å‰Šé™¤ã—ã¾ã™ã€‚ ã ã‹ã‚‰ã‚ãªãŸã¯å˜ã«æ›¸ãã“ã¨ãŒã§ãã¾ã™ï¼š</target>
        </trans-unit>
        <trans-unit id="855d634ee489e4e0a2c811671f665628a0a0df6f" translate="yes" xml:space="preserve">
          <source>Using ES6:</source>
          <target state="translated">ES6ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9fb406e463a70799e2a3db3cb0956dde6058516c" translate="yes" xml:space="preserve">
          <source>Using this method, not all &lt;a href=&quot;https://stackoverflow.com/questions/1894792/determining-if-a-javascript-object-has-a-given-property&quot;&gt;ways of determining property existence&lt;/a&gt; will work as expected.</source>
          <target state="translated">ã“ã®æ–¹æ³•ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ &lt;a href=&quot;https://stackoverflow.com/questions/1894792/determining-if-a-javascript-object-has-a-given-property&quot;&gt;ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å­˜åœ¨ã‚’åˆ¤åˆ¥ã™ã‚‹&lt;/a&gt;ã™ã¹ã¦ã®æ–¹æ³•ãŒæœŸå¾…ã©ãŠã‚Šã«æ©Ÿèƒ½ã™ã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="7d56ccd01dc2c25715aa91cc5c3b3239162d1db4" translate="yes" xml:space="preserve">
          <source>What follows is a contrived scenario that gets pretty long-winded, so you can skip to the section, &lt;strong&gt;The Solution&lt;/strong&gt;, if you want. The only reason I leave this section it is that I think some people probably think it's funny, and I don't want to be &quot;that guy&quot; who posts a &quot;funny&quot; answer and then deletes all the &quot;funny&quot; from it later on.</source>
          <target state="translated">ä»¥ä¸‹ã®ã‚·ãƒŠãƒªã‚ªã¯ã‹ãªã‚Šé•·ãã‹ã‹ã‚‹ä¸è‡ªç„¶ãªã‚·ãƒŠãƒªã‚ªãªã®ã§ã€å¿…è¦ã«å¿œã˜ã¦ã€ &lt;strong&gt;ã€Œã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³&lt;/strong&gt; ã€ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ã‚¹ã‚­ãƒƒãƒ—ã§ãã¾ã™ã€‚ ç§ãŒã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’é›¢ã‚Œã‚‹å”¯ä¸€ã®ç†ç”±ã¯ã€ãŠãã‚‰ãé¢ç™½ã„ã¨æ€ã†äººã‚‚ã„ã‚‹ã ã‚ã†ã¨æ€ã†ã—ã€ã€Œé¢ç™½ã„ã€å›ç­”ã‚’æŠ•ç¨¿ã—ã€å¾Œã§ã€Œé¢ç™½ã„ã€ã‚’ã™ã¹ã¦å‰Šé™¤ã™ã‚‹ã€Œã‚ã®ç”·ã€ã«ãªã‚ŠãŸããªã„ã‹ã‚‰ã§ã™ã€‚ ã€‚</target>
        </trans-unit>
        <trans-unit id="e8a0f3d5fef79ddff6c740f20faf1841e9c8a913" translate="yes" xml:space="preserve">
          <source>What is the best way to remove the property &lt;code&gt;regex&lt;/code&gt; to end up with new &lt;code&gt;myObject&lt;/code&gt; as follows?</source>
          <target state="translated">ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã® &lt;code&gt;regex&lt;/code&gt; ã‚’å‰Šé™¤ã—ã¦ã€æ–°ã—ã„ &lt;code&gt;myObject&lt;/code&gt; ã‚’æ¬¡ã®ã‚ˆã†ã«å‰Šé™¤ã™ã‚‹æœ€è‰¯ã®æ–¹æ³•ã¯ä½•ã§ã™ã‹ï¼Ÿ</target>
        </trans-unit>
        <trans-unit id="269ad8f4ba0c959d755966ae84263f7c06ef0a98" translate="yes" xml:space="preserve">
          <source>When should one use &lt;code&gt;delete&lt;/code&gt; and when set value to &lt;code&gt;undefined&lt;/code&gt; ?</source>
          <target state="translated">ã„ã¤ &lt;code&gt;delete&lt;/code&gt; ã‚’ä½¿ç”¨ã—ã€å€¤ã‚’ &lt;code&gt;undefined&lt;/code&gt; ã«è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã‹ï¼Ÿ</target>
        </trans-unit>
        <trans-unit id="f73054e5169db0bc5c2ed5932270c4a709d901aa" translate="yes" xml:space="preserve">
          <source>When using a Symbol, wait, why are you using a Symbol?!?! Symbols are bad  juju for performance. Everything programmed to use Symbols can be reprogrammed to not use Symbols, resulting in a faster code without Symbols. Symbols are really just super inefficient meta-sugar.</source>
          <target state="translated">ã‚·ãƒ³ãƒœãƒ«ã‚’ä½¿ã†ã¨ãã¯ã€å¾…ã£ã¦ã€ãªãœã‚·ãƒ³ãƒœãƒ«ã‚’ä½¿ã†ã®ã‹!?ã‚·ãƒ³ãƒœãƒ«ã¯ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã«æ‚ªå½±éŸ¿ã‚’ä¸ãˆã¾ã™ã€‚ã‚·ãƒ³ãƒœãƒ«ã‚’ä½¿ã†ã‚ˆã†ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã•ã‚ŒãŸã‚‚ã®ã¯ã™ã¹ã¦ã‚·ãƒ³ãƒœãƒ«ã‚’ä½¿ã‚ãªã„ã‚ˆã†ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã—ç›´ã™ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚·ãƒ³ãƒœãƒ«ã¯æœ¬å½“ã«éåŠ¹ç‡çš„ãªãƒ¡ã‚¿ç³–ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="602ae3083b5ceb94cfa5bb3b6f0e1f19f1f16418" translate="yes" xml:space="preserve">
          <source>When using an array/variable typed to the boolean primitive, use either &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; as the empty value. While avoiding unnecessary polymorphism is good, rewriting all your code to explicitly forbid it will likely actually result in a decrease in performance. Use common judgement!</source>
          <target state="translated">ãƒ–ãƒ¼ãƒ«ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã«å‹æŒ‡å®šã•ã‚ŒãŸé…åˆ—/å¤‰æ•°ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã¯ã€ç©ºã®å€¤ã¨ã—ã¦ &lt;code&gt;false&lt;/code&gt; ã¾ãŸã¯ &lt;code&gt;undefined&lt;/code&gt; ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ ä¸è¦ãªãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ã‚’å›é¿ã™ã‚‹ã“ã¨ã¯è‰¯ã„ã“ã¨ã§ã™ãŒã€æ˜ç¤ºçš„ã«ç¦æ­¢ã™ã‚‹ã‚ˆã†ã«ã™ã¹ã¦ã®ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãç›´ã™ã¨ã€å®Ÿéš›ã«ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒä½ä¸‹ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ ä¸€èˆ¬çš„ãªåˆ¤æ–­ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ï¼</target>
        </trans-unit>
        <trans-unit id="97e2c329b633d1758a70203709d67ea5a41bbc86" translate="yes" xml:space="preserve">
          <source>When using an array/variable typed to the number primitive, use &lt;code&gt;0&lt;/code&gt; as the empty value. Note that internally, there are two types of numbers: fast integers (2147483647 to -2147483648 inclusive) and slow floating point doubles (anything other than that including &lt;code&gt;NaN&lt;/code&gt; and &lt;code&gt;Infinity&lt;/code&gt;). When an integer is demoted to a double, it cannot be promoted back to an integer.</source>
          <target state="translated">æ•°å€¤ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã«å‹æŒ‡å®šã•ã‚ŒãŸé…åˆ—/å¤‰æ•°ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã¯ã€ç©ºã®å€¤ã¨ã—ã¦ &lt;code&gt;0&lt;/code&gt; ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ å†…éƒ¨çš„ã«ã¯ã€2ã¤ã®ã‚¿ã‚¤ãƒ—ã®æ•°å€¤ãŒã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ï¼šé«˜é€Ÿæ•´æ•°ï¼ˆ2147483647ã‹ã‚‰-2147483648ã¾ã§ï¼‰ãŠã‚ˆã³ä½é€Ÿæµ®å‹•å°æ•°ç‚¹ã®å€ç²¾åº¦æµ®å‹•å°æ•°ç‚¹æ•°ï¼ˆ &lt;code&gt;NaN&lt;/code&gt; ãŠã‚ˆã³ &lt;code&gt;Infinity&lt;/code&gt; ã‚’å«ã‚€ãã‚Œä»¥å¤–ã®ã‚‚ã®ï¼‰ã€‚ æ•´æ•°ãŒdoubleã«é™æ ¼ã•ã‚Œã‚‹ã¨ã€æ˜‡æ ¼ã—ã¦æ•´æ•°ã«æˆ»ã™ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="363e06ebcbb46e5d020be755b34062c111648564" translate="yes" xml:space="preserve">
          <source>When using an array/variable typed to the string primitive, use &lt;code&gt;&quot;&quot;&lt;/code&gt; as the empty value.</source>
          <target state="translated">æ–‡å­—åˆ—ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã«å‹æŒ‡å®šã•ã‚ŒãŸé…åˆ—/å¤‰æ•°ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã¯ã€ç©ºã®å€¤ã¨ã—ã¦ &lt;code&gt;&quot;&quot;&lt;/code&gt; ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="2daf2d7377c143fd1982ce05f553ab2ba4bd19a7" translate="yes" xml:space="preserve">
          <source>When using anything else, use &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">ãã‚Œä»¥å¤–ã®ã‚‚ã®ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã¯ã€ &lt;code&gt;null&lt;/code&gt; ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="99129be375514e4d040c762996086e2002e66f2e" translate="yes" xml:space="preserve">
          <source>Which is a terrible justification for getting rid of the &lt;code&gt;null&lt;/code&gt;s--&lt;code&gt;null&lt;/code&gt; is only dangerous if used improperly, and it has nothing to do with &quot;precision&quot;. The real reason you shouldn't &lt;code&gt;delete&lt;/code&gt; from an array is that leaving garbage-filled and messy data structures around is sloppy and bug-prone.</source>
          <target state="translated">ã“ã‚Œã¯ã€ &lt;code&gt;null&lt;/code&gt; sã‚’å–ã‚Šé™¤ããŸã‚ã®æã‚ã—ã„æ­£å½“åŒ–ã§ã™ã€‚ &lt;code&gt;null&lt;/code&gt; ã¯ã€ä¸é©åˆ‡ã«ä½¿ç”¨ã•ã‚ŒãŸå ´åˆã«ã®ã¿å±é™ºã§ã‚ã‚Šã€ã€Œç²¾åº¦ã€ã¨ã¯ä½•ã®é–¢ä¿‚ã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚ é…åˆ—ã‹ã‚‰ &lt;code&gt;delete&lt;/code&gt; ã™ã¹ãã§ã¯ãªã„æœ¬å½“ã®ç†ç”±ã¯ã€ã‚¬ãƒ™ãƒ¼ã‚¸ã§ä¹±é›‘ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’æ®‹ã—ã¦ãŠãã¨ã€ãšã•ã‚“ã§ãƒã‚°ãŒç™ºç”Ÿã—ã‚„ã™ããªã‚‹ãŸã‚ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1f5947457b95655f5329f1cfd08d1b56c64dd6e7" translate="yes" xml:space="preserve">
          <source>Which means in this case you won't be able to remove that object because you have created the &lt;code&gt;regex&lt;/code&gt; variable via a &lt;code&gt;var&lt;/code&gt; statement, and if you do:</source>
          <target state="translated">ã¤ã¾ã‚Šã€ã“ã®å ´åˆã€ &lt;code&gt;var&lt;/code&gt; ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã‚’ä½¿ç”¨ã—ã¦ &lt;code&gt;regex&lt;/code&gt; å¤‰æ•°ã‚’ä½œæˆã—ãŸãŸã‚ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="4f17f120087f0ca40e417b064249125802d82ec5" translate="yes" xml:space="preserve">
          <source>While using &lt;code&gt;obj[prop] = undefined&lt;/code&gt; is faster than doing &lt;code&gt;delete obj[prop]&lt;/code&gt;, another important consideration is that &lt;code&gt;obj[prop] = undefined&lt;/code&gt; may not always be appropriate. &lt;code&gt;delete obj[prop]&lt;/code&gt; removes &lt;code&gt;prop&lt;/code&gt; from &lt;code&gt;obj&lt;/code&gt; and erases it from memory whereas &lt;code&gt;obj[prop] = undefined&lt;/code&gt; simply sets the value of &lt;code&gt;prop&lt;/code&gt; to &lt;code&gt;undefined&lt;/code&gt; which leaves &lt;code&gt;prop&lt;/code&gt; still in memory. Therefore, in circumstances where there are many keys being created and deleted, using &lt;code&gt;obj[prop] = undefined&lt;/code&gt; can force expensive memory reconciliation (causing the page to freeze up) and potentially an out-of-memory error. Examine the following code.</source>
          <target state="translated">&lt;code&gt;obj[prop] = undefined&lt;/code&gt; ã‚’ &lt;code&gt;delete obj[prop]&lt;/code&gt; æ–¹ãŒdelete obj [prop]ã‚’å®Ÿè¡Œã™ã‚‹ã‚ˆã‚Šé«˜é€Ÿã§ã™ãŒã€ã‚‚ã†1ã¤ã®é‡è¦ãªè€ƒæ…®äº‹é …ã¯ã€ &lt;code&gt;obj[prop] = undefined&lt;/code&gt; ãŒå¸¸ã«é©åˆ‡ã§ã‚ã‚‹ã¨ã¯é™ã‚‰ãªã„ã“ã¨ã§ã™ã€‚ &lt;code&gt;delete obj[prop]&lt;/code&gt; ã¯ã€ &lt;code&gt;prop&lt;/code&gt; ã‚’ &lt;code&gt;obj&lt;/code&gt; ã‹ã‚‰å‰Šé™¤ã—ã¦ãƒ¡ãƒ¢ãƒªã‹ã‚‰æ¶ˆå»ã—ã¾ã™ãŒã€ &lt;code&gt;obj[prop] = undefined&lt;/code&gt; ã¯ã€ &lt;code&gt;prop&lt;/code&gt; ã®å€¤ã‚’undefinedã«è¨­å®šã™ã‚‹ã ã‘ã§ã€ propã‚’ãƒ¡ãƒ¢ãƒªã«æ®‹ã—ã¾ã™ã€‚ ã—ãŸãŒã£ã¦ã€å¤šãã®ã‚­ãƒ¼ãŒä½œæˆãŠã‚ˆã³å‰Šé™¤ã•ã‚Œã‚‹çŠ¶æ³ã§ã€ &lt;code&gt;obj[prop] = undefined&lt;/code&gt; ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ è² è·ã®é«˜ã„ãƒ¡ãƒ¢ãƒªèª¿æ•´ï¼ˆãƒšãƒ¼ã‚¸ãŒãƒ•ãƒªãƒ¼ã‚ºã™ã‚‹åŸå› ï¼‰ãŒç™ºç”Ÿã—ã€ãƒ¡ãƒ¢ãƒªä¸è¶³ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã‚’èª¿ã¹ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9fc668854fffc36979144c2d4415e9f9721712c0" translate="yes" xml:space="preserve">
          <source>While you technically can use &lt;code&gt;delete&lt;/code&gt; for an array, using it would result in getting incorrect results when calling for example &lt;code&gt;Hogwarts.staff.length&lt;/code&gt; later on. In other words, &lt;code&gt;delete&lt;/code&gt; would remove the element, but it wouldn't update the value of &lt;code&gt;length&lt;/code&gt; property. Using &lt;code&gt;delete&lt;/code&gt; would also mess up your indexing.</source>
          <target state="translated">æŠ€è¡“çš„ã«ã¯é…åˆ—ã® &lt;code&gt;delete&lt;/code&gt; ã‚’ä½¿ç”¨ã§ãã¾ã™ãŒã€ã“ã‚Œã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ãŸã¨ãˆã° &lt;code&gt;Hogwarts.staff.length&lt;/code&gt; ã‚’å¾Œã§å‘¼ã³å‡ºã™ã¨ãã«èª¤ã£ãŸçµæœãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚ ã¤ã¾ã‚Šã€ &lt;code&gt;delete&lt;/code&gt; ã¯è¦ç´ ã‚’å‰Šé™¤ã—ã¾ã™ãŒã€ &lt;code&gt;length&lt;/code&gt; ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å€¤ã‚’æ›´æ–°ã—ã¾ã›ã‚“ã€‚ &lt;code&gt;delete&lt;/code&gt; ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒã‚ã¡ã‚ƒãã¡ã‚ƒã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4be2ecd11ba0e212cafbe9f3ed4567f70ea3cc57" translate="yes" xml:space="preserve">
          <source>Yeah, that's definitely not what you wanted.</source>
          <target state="translated">ã‚ã‚ã€ãã‚Œã¯é–“é•ã„ãªãå›ãŒæœ›ã‚“ã§ã„ãŸã‚‚ã®ã§ã¯ãªã„ã€‚</target>
        </trans-unit>
        <trans-unit id="02c5f4541ba087fe996da9eb1271ebfb81156d83" translate="yes" xml:space="preserve">
          <source>You can also use other functions to achieve the same effect - omit, pick, ...</source>
          <target state="translated">ã¾ãŸã€åŒã˜åŠ¹æœã‚’å¾—ã‚‹ãŸã‚ã«ä»–ã®æ©Ÿèƒ½ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™-çœç•¥ã€ãƒ”ãƒƒã‚¯ã€...</target>
        </trans-unit>
        <trans-unit id="95e9a3221d0ebd0cc77f374d7ddfa95d905aef6a" translate="yes" xml:space="preserve">
          <source>You can delete that specific key from your object keys like:</source>
          <target state="translated">ã®ã‚ˆã†ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚­ãƒ¼ã‹ã‚‰ãã®ç‰¹å®šã®ã‚­ãƒ¼ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="df5ae996f80ec18df6459baf979a058b543794dd" translate="yes" xml:space="preserve">
          <source>You can see it in action in the Babel try-out editor.</source>
          <target state="translated">ãƒãƒ™ãƒ«ã®ãƒˆãƒ©ã‚¤ã‚¢ã‚¦ãƒˆã‚¨ãƒ‡ã‚£ã‚¿ã§å®Ÿéš›ã«è¦‹ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ba4ef71e846efa414e359524a525c5bda890d6bb" translate="yes" xml:space="preserve">
          <source>You can simply delete any property of an object using the &lt;code&gt;delete&lt;/code&gt; keyword.</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä»»æ„ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å‰Šé™¤ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6902cdb7c6341debc4ec1b8c5eaf6794e483c684" translate="yes" xml:space="preserve">
          <source>You can use ES6 destructuring with rest operator.</source>
          <target state="translated">restæ¼”ç®—å­ã‚’ä½¿ã£ã¦ES6ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ãƒªãƒ³ã‚°ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="121a5978b1bee631af70ab1aaec00b53de7645b2" translate="yes" xml:space="preserve">
          <source>global scope) can be deleted with delete.</source>
          <target state="translated">ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—)ã¯deleteã§å‰Šé™¤ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5be9ceecc2f03bc42e4d234aec808162f9c2f9d1" translate="yes" xml:space="preserve">
          <source>the result would be:</source>
          <target state="translated">ã¨ã„ã†çµæœã«ãªã‚‹ã®ã§ã¯ãªã„ã§ã—ã‚‡ã†ã‹ã€‚</target>
        </trans-unit>
        <trans-unit id="cc81a06a417041080d93a2378641c20ac0ef4865" translate="yes" xml:space="preserve">
          <source>which is equivalent to:</source>
          <target state="translated">ã«ç›¸å½“ã™ã‚‹ã€‚</target>
        </trans-unit>
        <trans-unit id="b9a0331930f5ae83ac7b458124a7b5021f44ea5d" translate="yes" xml:space="preserve">
          <source>will behave equivalently for both methods.</source>
          <target state="translated">ã¯ã©ã¡ã‚‰ã®æ–¹æ³•ã§ã‚‚åŒç­‰ã®æŒ™å‹•ã‚’ç¤ºã—ã¾ã™ã€‚</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
