<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/208105">
    <body>
      <group id="208105">
        <trans-unit id="d0c785d16c2347fee547f3127b424f77909312a7" translate="yes" xml:space="preserve">
          <source>(Destructuring + Spread operator)</source>
          <target state="translated">(íŒŒê´´ + í™•ì‚° ì—°ì‚°ì)</target>
        </trans-unit>
        <trans-unit id="63d63c34165213cae85c0283076b58a13c886dbf" translate="yes" xml:space="preserve">
          <source>(ES6)</source>
          <target state="translated">(ES6)</target>
        </trans-unit>
        <trans-unit id="7d50cf7543cd430338fe6fd7172b5d7ec7565f89" translate="yes" xml:space="preserve">
          <source>* &lt;em&gt;&lt;code&gt;foo&lt;/code&gt; will be a new variable with the value of &lt;code&gt;a&lt;/code&gt; (which is 1).&lt;/em&gt;</source>
          <target state="translated">* &lt;em&gt; &lt;code&gt;foo&lt;/code&gt; ëŠ” ê°’ì´ 1 ì¸ ìƒˆ ë³€ìˆ˜ì…ë‹ˆë‹¤.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8aa44c32c47930ef0f4bc07bf1b584a5b6b0e2f" translate="yes" xml:space="preserve">
          <source>...It's stupid, I know.</source>
          <target state="translated">... ë©ì²­í•˜ë‹¤.</target>
        </trans-unit>
        <trans-unit id="ff34d7bfb44f74504dbcecb1c791e02877f620e3" translate="yes" xml:space="preserve">
          <source>1.With explicit prop key:</source>
          <target state="translated">1. ëª…ì‹œ ì  ì†Œí’ˆ í‚¤ë¡œ :</target>
        </trans-unit>
        <trans-unit id="145f4a070da96e31a48d8d444babf929a09a782a" translate="yes" xml:space="preserve">
          <source>2.With variable prop key:</source>
          <target state="translated">2. ê°€ë³€ ì†Œí’ˆ í‚¤ :</target>
        </trans-unit>
        <trans-unit id="75c350f4599bd395c8e57950299bcd4efdaca57e" translate="yes" xml:space="preserve">
          <source>3.Cool arrow function ğŸ˜:</source>
          <target state="translated">3. ì¿¨ í™”ì‚´í‘œ ê¸°ëŠ¥ ğŸ˜ :</target>
        </trans-unit>
        <trans-unit id="b31d7d6cbd9fc3e49f4feaeef410e7cee592b5fa" translate="yes" xml:space="preserve">
          <source>4. For multiple properties</source>
          <target state="translated">4. ì—¬ëŸ¬ ì†ì„±</target>
        </trans-unit>
        <trans-unit id="cecf2bde461c486918fed98467ea58414d0dd173" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;Object.freeze()&lt;/a&gt; makes all properties of object not configurable (besides other things). &lt;code&gt;deleteProperty&lt;/code&gt; function (as well as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;delete operator&lt;/a&gt;) returns &lt;code&gt;false&lt;/code&gt; when tries to delete any of it's properties. If property is configurable it returns &lt;code&gt;true&lt;/code&gt;, even if property does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;Object.freeze ()&lt;/a&gt; ëŠ” ê°ì²´ì˜ ëª¨ë“  ì†ì„±ì„ êµ¬ì„± í•  ìˆ˜ ì—†ê²Œ ë§Œë“­ë‹ˆë‹¤ (ë‹¤ë¥¸ ê²ƒ ì™¸ì—ë„). &lt;code&gt;deleteProperty&lt;/code&gt; í•¨ìˆ˜ (ë° &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;delete ì—°ì‚°ì&lt;/a&gt; )ëŠ” í•´ë‹¹ ì†ì„±ì„ ì‚­ì œí•˜ë ¤ê³ í•˜ë©´ &lt;code&gt;false&lt;/code&gt; ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. propertyë¥¼ êµ¬ì„± í•  ìˆ˜ìˆëŠ” ê²½ìš° propertyê°€ ì¡´ì¬í•˜ì§€ ì•Šë”ë¼ë„ &lt;code&gt;true&lt;/code&gt; ë¥¼ ë¦¬í„´í•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="d2f5341f96365af83c99b7c7d47dba6c4b1a96cb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;Spread Syntax&lt;/a&gt; (ES6)</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;ìŠ¤í”„ë ˆë“œ êµ¬ë¬¸&lt;/a&gt; (ES6)</target>
        </trans-unit>
        <trans-unit id="e4d9e924d09e0b750a05547c2f0bf5fa2c195878" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.slice()&lt;/code&gt; is non-destructive and returns a new array containing the indicated indices from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;end&lt;/code&gt;. If &lt;code&gt;end&lt;/code&gt; is left unspecified, the behavior is the same as &lt;code&gt;.splice()&lt;/code&gt; (&lt;code&gt;end = array.length&lt;/code&gt;). The behavior is a bit tricky since, for some reason, &lt;code&gt;end&lt;/code&gt; indexes from 1 instead of 0. I don't know why it does this, but that's how it is. Also, if &lt;code&gt;end &amp;lt;= start&lt;/code&gt;, the result is an empty array.</source>
          <target state="translated">&lt;code&gt;.slice()&lt;/code&gt; ëŠ” ë¹„íŒŒê´´ ì ì´ë©° &lt;code&gt;start&lt;/code&gt; ë¶€í„° &lt;code&gt;end&lt;/code&gt; í‘œì‹œëœ ì¸ë±ìŠ¤ë¥¼ í¬í•¨í•˜ëŠ” ìƒˆ ë°°ì—´ì„ ë°˜í™˜í•©ë‹ˆë‹¤. &lt;code&gt;end&lt;/code&gt; ë¥¼ ì§€ì •í•˜ì§€ ì•Šìœ¼ë©´ ë™ì‘ì€ &lt;code&gt;.splice()&lt;/code&gt; ì™€ ê°™ìŠµë‹ˆë‹¤ ( &lt;code&gt;end = array.length&lt;/code&gt; ). ì–´ë–¤ ì´ìœ ë¡œ ë“  0 ëŒ€ì‹  1ë¶€í„° ì¸ë±ìŠ¤ë¥¼ &lt;code&gt;end&lt;/code&gt; ë•Œë¬¸ì— ë™ì‘ì´ ì•½ê°„ ê¹Œë‹¤ë¡œì›Œì§‘ë‹ˆë‹¤. ì™œ ê·¸ë ‡ê²Œí•˜ëŠ”ì§€ ëª¨ë¥´ê² ì§€ë§Œ ê·¸ ë°©ë²•ì…ë‹ˆë‹¤. ë˜í•œ &lt;code&gt;end &amp;lt;= start&lt;/code&gt; ì¸ ê²½ìš° ê²°ê³¼ëŠ” ë¹ˆ ë°°ì—´ì…ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="da2a0c1e98a822064cc6b913222774a91ac62044" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.splice()&lt;/code&gt; mutates the array, and returns the removed indices. The array is sliced starting from the index, &lt;code&gt;start&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; elements are sliced out. If n is unspecified, the entire array after &lt;code&gt;start&lt;/code&gt; is sliced out (&lt;code&gt;n = array.length - start&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;.splice()&lt;/code&gt; ëŠ” ë°°ì—´ì„ ë³€ê²½í•˜ê³  ì œê±° ëœ ì¸ë±ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. ë°°ì—´ì€ index, &lt;code&gt;start&lt;/code&gt; ì—ì„œ ì‹œì‘í•˜ì—¬ ìŠ¬ë¼ì´ìŠ¤ë˜ê³  &lt;code&gt;n&lt;/code&gt; ê°œì˜ ìš”ì†Œê°€ ìŠ¬ë¼ì´ìŠ¤ë©ë‹ˆë‹¤. nì„ ì§€ì •í•˜ì§€ ì•Šìœ¼ë©´ &lt;code&gt;start&lt;/code&gt; í›„ ì „ì²´ ë°°ì—´ì´ ë¶„ë¦¬ë©ë‹ˆë‹¤ ( &lt;code&gt;n = array.length - start&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="578e0d997316ced94b2f7c292e4269507a0730b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Delete Operator&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;ì—°ì‚°ì ì‚­ì œ&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="10a7b7e3a95023fb9f5d4f97bbeb1e856756bc60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;EXTENDED ANSWER&lt;/em&gt;&lt;/strong&gt; ğŸ˜‡</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;í™•ì¥ ëœ ë‹µë³€&lt;/em&gt;&lt;/strong&gt; ğŸ˜‡</target>
        </trans-unit>
        <trans-unit id="3393b3743a22fd0193ab2fa39735ae2f646b06ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Or&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Or&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="710a4e957cc23ae95eb9aa6e13030731ab1c9d56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Reassignment&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Reassignment&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e590196d99e29b0fb26cc981e8c241732f76e4ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Spread Operator&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;ìŠ¤í”„ë ˆë“œ ì—°ì‚°ì&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="64d050dff57dceee4d758cc0912b8d402b405b10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Usage&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Usage&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b02479449faf2e3a74dc8a9ef6000bfbe7ea1f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In other words, a JavaScript object gets killed as soon as there is no reference left in your code pointed to that object.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ì¦‰, ì½”ë“œì— í•´ë‹¹ ê°ì²´ë¥¼ ê°€ë¦¬í‚¤ëŠ” ì°¸ì¡°ê°€ ë‚¨ì•„ ìˆì§€ ì•Šìœ¼ë©´ JavaScript ê°ì²´ê°€ ì¢…ë£Œë©ë‹ˆë‹¤.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ecc8000feff4d7f65f5786df06cc101796ac4edd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To clone object without property:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ì†ì„±ì—†ì´ ê°ì²´ë¥¼ ë³µì œí•˜ë ¤ë©´ :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ca5c58827bf40e3a97a098228081f1f64d66b7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update 2018-07-21:&lt;/strong&gt; For a long time, I have felt embarrassed about this answer, so I think it's time that I touch it up a little bit. Just a little commentary, clarification, and formatting to help expedite the reading of the needlessly long and convoluted parts of this answer.</source>
          <target state="translated">&lt;strong&gt;2018-07-21 ì—…ë°ì´íŠ¸ :&lt;/strong&gt; ì˜¤ë«ë™ì•ˆì´ ë‹µë³€ì— ëŒ€í•´ ë‹¹í™©í•œ ëŠë‚Œì´ ë“¤ì—ˆìŠµë‹ˆë‹¤. ê·¸ë˜ì„œ ì¡°ê¸ˆ ë§Œì§ˆ ë•Œì…ë‹ˆë‹¤. ì´ ë‹µë³€ì˜ ë¶ˆí•„ìš”í•˜ê²Œ ê¸¸ê³  ë³µì¡í•œ ë¶€ë¶„ì„ ë¹¨ë¦¬ ì½ì„ ìˆ˜ ìˆë„ë¡ ì•½ê°„ì˜ ì£¼ì„, ì„¤ëª… ë° í˜•ì‹ì„ ì§€ì •í•˜ì‹­ì‹œì˜¤.</target>
        </trans-unit>
        <trans-unit id="c099f37767111dc60103bd8696ed4fcf3e7a64d4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;
Thanks to @AgentME:</source>
          <target state="translated">&lt;strong&gt;ì—…ë°ì´íŠ¸ :&lt;/strong&gt; @AgentME ë•ë¶„ì— :</target>
        </trans-unit>
        <trans-unit id="cd7c415e1d4039a5febeafd32c836a75f6b919e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;delete&lt;/code&gt;,&lt;/strong&gt; when you are passing the result object to the code on which you don't have control (or when you are not sure about your team or yourself).</source>
          <target state="translated">ê²°ê³¼ ê°ì²´ë¥¼ ì œì–´ ê¶Œí•œì´ì—†ëŠ” ì½”ë“œë¡œ ì „ë‹¬í•  ë•Œ (ë˜ëŠ” íŒ€ì´ë‚˜ ìì‹ ì— ëŒ€í•´ ì˜ ëª¨ë¥´ëŠ” ê²½ìš°) &lt;strong&gt; &lt;code&gt;delete&lt;/code&gt; ë¥¼ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="0af0c0606dbb967654f58c35fa2988459afb9a19" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use setting to &lt;code&gt;undefined&lt;/code&gt;,&lt;/strong&gt; when you care about performance. It can give a serious boost to your code.</source>
          <target state="translated">ì„±ëŠ¥ì— ê´€ì‹¬ì´ìˆì„ ë•Œ &lt;strong&gt;ì„¤ì •ì„ &lt;code&gt;undefined&lt;/code&gt; ë¡œ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤&lt;/strong&gt; . ì½”ë“œë¥¼ í¬ê²Œ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="9dfe20a67d61ae6b75beddf80cff0434cb3f7a9f" translate="yes" xml:space="preserve">
          <source>A live example to show:</source>
          <target state="translated">ë³´ì—¬ì£¼ëŠ” ì‹¤ì œ ì˜ˆ :</target>
        </trans-unit>
        <trans-unit id="aabd2b7839024463c3c18626551d6893b70879bd" translate="yes" xml:space="preserve">
          <source>About now, you're at your wit's end. This guy has been complaining non-stop about your app, and you want to tell him to shut up and go get a better computer.</source>
          <target state="translated">ì§€ê¸ˆ, ë‹¹ì‹ ì€ ë‹¹ì‹ ì˜ ì¬ì¹˜ ëì— ìˆìŠµë‹ˆë‹¤. ì´ ì‚¬ëŒì€ ë‹¹ì‹ ì˜ ì•±ì— ëŒ€í•´ ë…¼ë€ì„ ê³„ì†í•˜ê³  ìˆìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³  ë‹¹ì‹ ì€ ê·¸ ì‚¬ëŒì—ê²Œ ë‹¥ì¹˜ê³  ë” ë‚˜ì€ ì»´í“¨í„°ë¥¼ ê°€ì§€ë¼ê³  ë§í•˜ê³  ì‹¶ìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="692f82b2a7574a467099a421e634c28a19087f50" translate="yes" xml:space="preserve">
          <source>Alternatively, you could also do this:</source>
          <target state="translated">ë˜ëŠ” ë‹¤ìŒì„ ìˆ˜í–‰ í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="8dd6b6a5cb398077b2e61b33860df5233162a369" translate="yes" xml:space="preserve">
          <source>An object may be seen as a set of key-value pairs. What I call a 'value' is a primitive or a reference to other object, connected to that 'key'.</source>
          <target state="translated">ê°ì²´ëŠ” ì¼ë ¨ì˜ í‚¤-ê°’ ìŒìœ¼ë¡œ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‚´ê°€ 'ê°’'ì´ë¼ê³  ë¶€ë¥´ëŠ” ê²ƒì€ í•´ë‹¹ 'í‚¤'ì— ì—°ê²°ëœ ê¸°ë³¸ ë˜ëŠ” ë‹¤ë¥¸ ê°ì²´ì— ëŒ€í•œ ì°¸ì¡°ì…ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="97f362e729192c077ada3f5241fec0dea0e6f9ad" translate="yes" xml:space="preserve">
          <source>And just like that, you've pleased Mr. PDP-11. Hooray! &lt;sub&gt;(I'd still tell him off, though...)&lt;/sub&gt;</source>
          <target state="translated">PDP-11 ì”¨ë„ ê¸°ë»í–ˆìŠµë‹ˆë‹¤. ë§Œì„¸! &lt;sub&gt;(í•˜ì§€ë§Œ ì—¬ì „íˆ ê·¸ì—ê²Œ ë§ì„ ê±¸ì—ˆìŠµë‹ˆë‹¤ ...)&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="38fedc2f5a59cd30ac658c92ac34226c9870e485" translate="yes" xml:space="preserve">
          <source>And we need to delete 'a'.</source>
          <target state="translated">ê·¸ë¦¬ê³  'a'ë¥¼ ì‚­ì œí•´ì•¼í•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="15728408349a51726fa4d7a495f586b8e25e36f1" translate="yes" xml:space="preserve">
          <source>Another alternative is to use the &lt;a href=&quot;https://underscorejs.org&quot;&gt;Underscore.js&lt;/a&gt; library.</source>
          <target state="translated">ë˜ ë‹¤ë¥¸ ëŒ€ì•ˆì€ &lt;a href=&quot;https://underscorejs.org&quot;&gt;Underscore.js&lt;/a&gt; ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="130c3bce337f7ed92461a0af093bf0dd8b4d970c" translate="yes" xml:space="preserve">
          <source>Another solution, using &lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;&lt;code&gt;Array#reduce&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt; &lt;code&gt;Array#reduce&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt; ì‚¬ìš©í•˜ëŠ” ë‹¤ë¥¸ ì†”ë£¨ì…˜.</target>
        </trans-unit>
        <trans-unit id="75aa366398b31b18c07d678c84ff7223a1b76dbe" translate="yes" xml:space="preserve">
          <source>Any property declared with let or const cannot be deleted from the scope  within which they were defined. Non-configurable properties cannot be removed. This includes properties of built-in objects like Math, Array, Object and properties that are created as non-configurable with methods like Object.defineProperty().</source>
          <target state="translated">let ë˜ëŠ” constë¡œ ì„ ì–¸ ëœ ì†ì„±ì€ ì •ì˜ ëœ ë²”ìœ„ì—ì„œ ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. êµ¬ì„± í•  ìˆ˜ì—†ëŠ” ì†ì„±ì€ ì œê±° í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì—¬ê¸°ì—ëŠ” Math, Array, Objectì™€ ê°™ì€ ë‚´ì¥ ê°ì²´ì˜ ì†ì„±ê³¼ Object.defineProperty ()ì™€ ê°™ì€ ë©”ì„œë“œë¡œ êµ¬ì„± í•  ìˆ˜ì—†ëŠ” ì†ì„±ì´ í¬í•¨ë©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="b2ecb35283325b0622c879acc81ba757d7accad0" translate="yes" xml:space="preserve">
          <source>Any property declared with var cannot be deleted from the global scope
  or from a function's scope.</source>
          <target state="translated">varë¡œ ì„ ì–¸ ëœ ì†ì„±ì€ ì „ì—­ ë²”ìœ„ ë‚˜ í•¨ìˆ˜ ë²”ìœ„ì—ì„œ ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="6c333dd9449a548b822691fcab373abce8f8f850" translate="yes" xml:space="preserve">
          <source>Are you looking to achieve this in pure JavaScript or are you willing &amp;amp; able to use a 3rd-party library?</source>
          <target state="translated">ìˆœìˆ˜í•œ JavaScriptë¡œ ì´ê²ƒì„ ë‹¬ì„±í•˜ë ¤ê³ í•©ë‹ˆê¹Œ? ì•„ë‹ˆë©´ íƒ€ì‚¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆê¹Œ?</target>
        </trans-unit>
        <trans-unit id="1fea0155471c15e540c5b31c3594a45754e6cc6c" translate="yes" xml:space="preserve">
          <source>Array equivalent</source>
          <target state="translated">ë™ë“±í•œ ë°°ì—´</target>
        </trans-unit>
        <trans-unit id="10f82eff0fb408011ffeabc374c6234764312dea" translate="yes" xml:space="preserve">
          <source>Array.prototype.slice(start, end)</source>
          <target state="translated">Array.prototype.slice (ì‹œì‘, ë)</target>
        </trans-unit>
        <trans-unit id="dfe829210c0c25d8779de7fe65fb3158cefd4290" translate="yes" xml:space="preserve">
          <source>Array.prototype.splice vs Array.prototype.slice</source>
          <target state="translated">Array.prototype.splice ëŒ€ Array.prototype.slice</target>
        </trans-unit>
        <trans-unit id="99ba4898ce91c3e3945c33ecd292283940427b38" translate="yes" xml:space="preserve">
          <source>Array.prototype.splice(start, n)</source>
          <target state="translated">Array.prototype.splice (ì‹œì‘, n)</target>
        </trans-unit>
        <trans-unit id="bc85e8ead32cd6185d2f6ca2b34c7fbc94aadd58" translate="yes" xml:space="preserve">
          <source>As others have said, you can use &lt;code&gt;delete&lt;/code&gt;.</source>
          <target state="translated">ë‹¤ë¥¸ ì‚¬ëŒë“¤ì´ ë§í–ˆë“¯ì´ &lt;code&gt;delete&lt;/code&gt; ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="fc6de88f57fe2bcbd39aa2ddf8ca667c26f222a3" translate="yes" xml:space="preserve">
          <source>As seen in the above code snippet, there are some rare appropriate use cases for the &lt;code&gt;delete&lt;/code&gt; operator. However, do not worry about this problem too much. This will only become a problem with long-lifespan objects that get new keys constantly added to them. In any other case (which is almost every case in real-world programming), it is most appropriate to use &lt;code&gt;obj[prop] = undefined&lt;/code&gt;. The main purpose of this section is just to bring this to your attention so that in the rare chance that this does become a problem in your code, then you can more easily understand the problem and thus not have to waste hours dissecting your code to locate and understand this problem.</source>
          <target state="translated">ìœ„ì˜ ì½”ë“œ ìŠ¤ ë‹ˆí«ì—ì„œ ë³¼ ìˆ˜ ìˆë“¯ì´ &lt;code&gt;delete&lt;/code&gt; ì—°ì‚°ìì— ëŒ€í•œ ì ì ˆí•œ ì‚¬ìš© ì‚¬ë¡€ê°€ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ì´ ë¬¸ì œì— ëŒ€í•´ ë„ˆë¬´ ê±±ì •í•˜ì§€ ë§ˆì‹­ì‹œì˜¤. ì´ê²ƒì€ ìƒˆë¡œìš´ í‚¤ë¥¼ ì§€ì†ì ìœ¼ë¡œ ì¶”ê°€í•˜ëŠ” ìˆ˜ëª…ì´ ê¸´ ê°ì²´ì—ë§Œ ë¬¸ì œê°€ë©ë‹ˆë‹¤. ë‹¤ë¥¸ ê²½ìš° (ì‹¤ì œ í”„ë¡œê·¸ë˜ë°ì—ì„œëŠ” ê±°ì˜ ëª¨ë“  ê²½ìš°ì— í•´ë‹¹), &lt;code&gt;obj[prop] = undefined&lt;/code&gt; ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ê°€ì¥ ì í•©í•©ë‹ˆë‹¤. ì´ ì„¹ì…˜ì˜ ì£¼ìš” ëª©ì ì€ ì½”ë“œì— ë¬¸ì œê°€ ë  ê°€ëŠ¥ì„±ì´ ê±°ì˜ì—†ëŠ” ê²½ìš°ê°€ ë§ìœ¼ë¯€ë¡œ ë¬¸ì œë¥¼ë³´ë‹¤ ì‰½ê²Œ â€‹â€‹ì´í•´í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì½”ë“œë¥¼ ì°¾ëŠ” ë° ì‹œê°„ì„ ë‚­ë¹„í•˜ì§€ ì•Šì•„ë„ë©ë‹ˆë‹¤. ì´ ë¬¸ì œë¥¼ ì´í•´í•˜ì‹­ì‹œì˜¤.</target>
        </trans-unit>
        <trans-unit id="0a1a7281b5e3e0adcbcee6c0378231475ce1d077" translate="yes" xml:space="preserve">
          <source>As such, delete cannot delete any functions in the global scope (whether this is part from a function definition or a function  (expression).</source>
          <target state="translated">ë”°ë¼ì„œ deleteëŠ” ì „ì—­ ë²”ìœ„ì—ì„œ í•¨ìˆ˜ë¥¼ ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤ (ì´ê²ƒì´ í•¨ìˆ˜ ì •ì˜ ë˜ëŠ” í•¨ìˆ˜ (í‘œí˜„)ì˜ ì¼ë¶€ì¸ì§€ ì—¬ë¶€).</target>
        </trans-unit>
        <trans-unit id="19292906404cfee69ce728ffea847a3cb5d23580" translate="yes" xml:space="preserve">
          <source>As you can see, &lt;code&gt;delete&lt;/code&gt; doesn't always work as one might expect. The value is overwritten, but the memory is not reallocated. That is to say, &lt;code&gt;array[4]&lt;/code&gt; isn't relocated to &lt;code&gt;array[3]&lt;/code&gt;. Which is in contrast to &lt;code&gt;Array.prototype.unshift&lt;/code&gt;, which inserts an element at the beginning of the array and shifts everything up (&lt;code&gt;array[0]&lt;/code&gt; becomes &lt;code&gt;array[1]&lt;/code&gt;, etc.)</source>
          <target state="translated">ë³´ì‹œë‹¤ì‹œí”¼ &lt;code&gt;delete&lt;/code&gt; ê°€ í•­ìƒ ì˜ˆìƒëŒ€ë¡œ ì‘ë™í•˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤. ê°’ì„ ë®ì–´ ì“°ì§€ë§Œ ë©”ëª¨ë¦¬ê°€ ì¬ í• ë‹¹ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì¦‰, &lt;code&gt;array[4]&lt;/code&gt; ëŠ” &lt;code&gt;array[3]&lt;/code&gt; ë¡œ ì¬ë°°ì¹˜ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. &lt;code&gt;Array.prototype.unshift&lt;/code&gt; ì™€ ëŒ€ì¡°ì ìœ¼ë¡œ ë°°ì—´ì˜ ì‹œì‘ ë¶€ë¶„ì— ìš”ì†Œë¥¼ ì‚½ì…í•˜ê³  ëª¨ë“  ê²ƒì„ ìœ„ë¡œ ì´ë™í•©ë‹ˆë‹¤ ( &lt;code&gt;array[0]&lt;/code&gt; ì€ &lt;code&gt;array[1]&lt;/code&gt; ë“±ì´ ë¨)</target>
        </trans-unit>
        <trans-unit id="2c856c5e5c5be4265462b9644119ace1784d98d0" translate="yes" xml:space="preserve">
          <source>Beware Of Memory Leaks!</source>
          <target state="translated">ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¥¼ ì¡°ì‹¬í•˜ì‹­ì‹œì˜¤!</target>
        </trans-unit>
        <trans-unit id="76829795257d4b98172b51f389192e4a9f633cf6" translate="yes" xml:space="preserve">
          <source>But if the property of the object is not configurable it cannot be deleted neither with deleteProperty function nor delete operator:</source>
          <target state="translated">ê·¸ëŸ¬ë‚˜ ê°ì²´ì˜ ì†ì„±ì„ êµ¬ì„± í•  ìˆ˜ ì—†ìœ¼ë©´ deleteProperty í•¨ìˆ˜ ë‚˜ delete ì—°ì‚°ìë¥¼ ì‚¬ìš©í•˜ì—¬ ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="5d2ae2c0c3d231052d20df4bc0d378c5068295e8" translate="yes" xml:space="preserve">
          <source>But the point is if you care about memory and you want to whole the object gets removed from the memory, it is recommended to set it to null before you delete the key:</source>
          <target state="translated">ê·¸ëŸ¬ë‚˜ ìš”ì ì€ ë©”ëª¨ë¦¬ì— ê´€ì‹¬ì´ ìˆê³  ê°ì²´ê°€ ë©”ëª¨ë¦¬ì—ì„œ ì™„ì „íˆ ì œê±°ë˜ë„ë¡í•˜ë ¤ë©´ í‚¤ë¥¼ ì‚­ì œí•˜ê¸° ì „ì— nullë¡œ ì„¤ì •í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="083882684bcd539a61f754c832b4192934d833e3" translate="yes" xml:space="preserve">
          <source>But, how does a drug trip analogy relate to the &lt;code&gt;delete&lt;/code&gt; operation? The answer inheres the last line of code in the snippet above. Thus let it be reexamined, this time with a twist.</source>
          <target state="translated">ê·¸ëŸ¬ë‚˜, ì•½ë¬¼ íŠ¸ë¦½ ë¹„ìœ ëŠ” &lt;code&gt;delete&lt;/code&gt; ì‘ì—…ê³¼ ì–´ë–¤ ê´€ë ¨ì´ ìˆìŠµë‹ˆê¹Œ? ëŒ€ë‹µì€ ìœ„ì˜ ì½”ë“œ ì¡°ê°ì—ì„œ ë§ˆì§€ë§‰ ì½”ë“œ ì¤„ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ë”°ë¼ì„œ ì´ë²ˆì—ëŠ” ë¹„í‹€ì–´ ë‹¤ì‹œ ê²€í† í•˜ì.</target>
        </trans-unit>
        <trans-unit id="0eb16d4b50dbacc8475f57ed2dfb88409bd56da6" translate="yes" xml:space="preserve">
          <source>Consider creating a new object without the &lt;code&gt;&quot;regex&quot;&lt;/code&gt; property because the original object could always be referenced by other parts of your program. Thus you should avoid manipulating it.</source>
          <target state="translated">ì›ë˜ ê°ì²´ëŠ” í•­ìƒ í”„ë¡œê·¸ë¨ì˜ ë‹¤ë¥¸ ë¶€ë¶„ì—ì„œ ì°¸ì¡° í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ &lt;code&gt;&quot;regex&quot;&lt;/code&gt; ì†ì„±ì—†ì´ ìƒˆ ê°ì²´ë¥¼ ë§Œë“œëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ì¡°ì‘í•˜ì§€ ë§ˆì‹­ì‹œì˜¤.</target>
        </trans-unit>
        <trans-unit id="1b8bae88ce3f716fc88f086ba5df71aa742b0ee5" translate="yes" xml:space="preserve">
          <source>Dan's assertion that 'delete' is very slow and the benchmark he posted were doubted. So I carried out the test myself in Chrome 59. It does seem that 'delete' is about 30 times slower:</source>
          <target state="translated">Danì˜ 'ì‚­ì œ'ëŠ” ë§¤ìš° ëŠë¦¬ë©° ìì‹ ì´ ê²Œì‹œ í•œ ë²¤ì¹˜ ë§ˆí¬ì— ëŒ€í•´ì„œëŠ” ì˜ë¬¸ì˜ ì—¬ì§€ê°€ ìˆìŠµë‹ˆë‹¤. ê·¸ë˜ì„œ Chrome 59ì—ì„œ ì§ì ‘ í…ŒìŠ¤íŠ¸ë¥¼ ìˆ˜í–‰í–ˆìŠµë‹ˆë‹¤. 'ì‚­ì œ'ê°€ ì•½ 30 ë°° ëŠë¦¬ê²Œ ë³´ì…ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="d8b13a816456ec85d6f3ace2de0c50288edaa6ea" translate="yes" xml:space="preserve">
          <source>Delete is the only true way to remove object's properties without any leftovers, but it works &lt;strong&gt;~ 100 times slower&lt;/strong&gt;, 
compared to its &quot;alternative&quot;, setting &lt;code&gt;object[key] = undefined&lt;/code&gt;.</source>
          <target state="translated">ì‚­ì œëŠ” ë‚¨ì€ ë¶€ë¶„ì—†ì´ ê°ì²´ì˜ ì†ì„±ì„ ì œê±° í•  ìˆ˜ìˆëŠ” ìœ ì¼í•œ ë°©ë²•ì´ì§€ë§Œ, &quot;alternative&quot;ì™€ ë¹„êµí•˜ì—¬ &lt;strong&gt;~ 100 ë°° ëŠë¦¬ê²Œ&lt;/strong&gt; ì‘ë™í•©ë‹ˆë‹¤. setting &lt;code&gt;object[key] = undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45dc7ea9ea6f9f47fa401db4115a5eee26a4be14" translate="yes" xml:space="preserve">
          <source>Deleting an array index</source>
          <target state="translated">ë°°ì—´ ì¸ë±ìŠ¤ ì‚­ì œ</target>
        </trans-unit>
        <trans-unit id="42034d05fb5ec8b92965ea89f328c840dc4a3ac4" translate="yes" xml:space="preserve">
          <source>Deleting an object property</source>
          <target state="translated">ê°ì²´ ì†ì„± ì‚­ì œ</target>
        </trans-unit>
        <trans-unit id="e52c854d5631eec7468ba4727b4c77eb745f2965" translate="yes" xml:space="preserve">
          <source>Demo</source>
          <target state="translated">Demo</target>
        </trans-unit>
        <trans-unit id="0298196b206bc7b4a96725653dbc77fafc2e7815" translate="yes" xml:space="preserve">
          <source>Do Not Always Set To &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">í•­ìƒ &lt;code&gt;undefined&lt;/code&gt; ì„¤ì •í•˜ì§€ ë§ˆì‹­ì‹œì˜¤</target>
        </trans-unit>
        <trans-unit id="e813a63a91f53696f818ac595a5fddc09cb30338" translate="yes" xml:space="preserve">
          <source>Don't &lt;code&gt;delete&lt;/code&gt; from an array. Use &lt;code&gt;Array.prototype.splice&lt;/code&gt; instead.</source>
          <target state="translated">ë°°ì—´ì—ì„œ &lt;code&gt;delete&lt;/code&gt; í•˜ì§€ ë§ˆì‹­ì‹œì˜¤. ëŒ€ì‹  &lt;code&gt;Array.prototype.splice&lt;/code&gt; ë¥¼ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤.</target>
        </trans-unit>
        <trans-unit id="9cff8f35d333fc23fef816a20f879c35c001ee7e" translate="yes" xml:space="preserve">
          <source>Due to the dynamic nature of JavaScript there are often cases where you simply don't know if the property exists or not. Checking if obj exists before the &amp;amp;&amp;amp; also makes sure you don't throw an error due to calling the hasOwnProperty() function on an undefined object.</source>
          <target state="translated">JavaScriptì˜ ë™ì  íŠ¹ì„±ìœ¼ë¡œ ì¸í•´ ì†ì„±ì˜ ì¡´ì¬ ì—¬ë¶€ë¥¼ ëª¨ë¥´ëŠ” ê²½ìš°ê°€ ì¢…ì¢… ìˆìŠµë‹ˆë‹¤. &amp;amp;&amp;amp; ì•ì— objê°€ ìˆëŠ”ì§€ í™•ì¸í•˜ë©´ ì •ì˜ë˜ì§€ ì•Šì€ ê°ì²´ì—ì„œ hasOwnProperty () í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="f30ca853155d96f4ff4a7523ad41da4989438529" translate="yes" xml:space="preserve">
          <source>E.g</source>
          <target state="translated">E.g</target>
        </trans-unit>
        <trans-unit id="48886c6e98adf5c4a9c9282a2441dfe3015faacb" translate="yes" xml:space="preserve">
          <source>ECMAScript 2015 (or ES6) came with built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect&quot;&gt;Reflect&lt;/a&gt; object. It is possible to delete object property by calling &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty&quot;&gt;Reflect.deleteProperty()&lt;/a&gt; function with target object and property key as parameters:</source>
          <target state="translated">ECMAScript 2015 (ë˜ëŠ” ES6)ëŠ” ë‚´ì¥ &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect&quot;&gt;Reflect&lt;/a&gt; ê°ì²´ì™€ í•¨ê»˜ ì œê³µë©ë‹ˆë‹¤. ëŒ€ìƒ ê°ì²´ì™€ ì†ì„± í‚¤ë¥¼ ë§¤ê°œ ë³€ìˆ˜ë¡œ ì‚¬ìš©í•˜ì—¬ &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty&quot;&gt;Reflect.deleteProperty ()&lt;/a&gt; í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ ê°ì²´ ì†ì„±ì„ ì‚­ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="4c2dbb36a3a214bec101207bfb72cd18b86e453e" translate="yes" xml:space="preserve">
          <source>Each one has it's own pros and cons (&lt;a href=&quot;https://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;check this performance comparison&lt;/a&gt;):</source>
          <target state="translated">ê°ê°ì—ëŠ” ìì²´ ì¥ë‹¨ì  &lt;a href=&quot;https://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;ì´&lt;/a&gt; ìˆìŠµë‹ˆë‹¤ ( ì´ ì„±ëŠ¥ ë¹„êµë¥¼ í™•ì¸í•˜ì‹­ì‹œì˜¤ ).</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">ìŠ¤ ë‹ˆí« í™•ì¥</target>
        </trans-unit>
        <trans-unit id="5cb7b7c35055238b90a33971ff368cff01dd0bbb" translate="yes" xml:space="preserve">
          <source>For anyone interested in reading more about it, Stack Overflow user &lt;a href=&quot;https://stackoverflow.com/users/130652/kangax&quot;&gt;kangax&lt;/a&gt; has written an incredibly in-depth blog post about the &lt;code&gt;delete&lt;/code&gt; statement on their blog, &lt;em&gt;&lt;a href=&quot;http://perfectionkills.com/understanding-delete/&quot;&gt;Understanding delete&lt;/a&gt;&lt;/em&gt;. It is highly recommended.</source>
          <target state="translated">ê·¸ê²ƒì— ëŒ€í•´ ë” ìì„¸íˆ &lt;a href=&quot;https://stackoverflow.com/users/130652/kangax&quot;&gt;ì•Œê³  ì‹¶ì€ ì‚¬ëŒ&lt;/a&gt; ì€ Stack Overflow ì‚¬ìš©ì kangax ê°€ ë¸”ë¡œê·¸ì˜ &lt;code&gt;delete&lt;/code&gt; ë¬¸ì— ëŒ€í•œ ë¯¿ì„ ìˆ˜ ì—†ì„ ì •ë„ë¡œ ì‹¬ë„ ê¹Šì€ ë¸”ë¡œê·¸ ê²Œì‹œë¬¼ì„ ì‘ì„±í–ˆìŠµë‹ˆë‹¤. ì ê·¹ ê¶Œì¥í•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="7de0c8678ad3582ef48a786c2a12849c95f613d2" translate="yes" xml:space="preserve">
          <source>For arrays, &lt;code&gt;_.filter()&lt;/code&gt; and &lt;code&gt;_.reject()&lt;/code&gt; can be used in a similar manner.</source>
          <target state="translated">ë°°ì—´ì˜ ê²½ìš° &lt;code&gt;_.filter()&lt;/code&gt; ë° &lt;code&gt;_.reject()&lt;/code&gt; ë¥¼ ë¹„ìŠ·í•œ ë°©ì‹ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="ae20664549d9e3ccd77991be79f76a86f10d159f" translate="yes" xml:space="preserve">
          <source>For example, say you are creating a webapp that uses JSON-serialization to store an array used for 'tabs' in a string (in this case, &lt;code&gt;localStorage&lt;/code&gt;). Let's also say that the code uses the numerical indices of the array's members to &quot;title&quot; them when drawing to the screen. Why are you doing this rather than just storing the &quot;title&quot; as well? Because... &lt;em&gt;reasons&lt;/em&gt;.</source>
          <target state="translated">ì˜ˆë¥¼ ë“¤ì–´ JSON ì§ë ¬í™”ë¥¼ ì‚¬ìš©í•˜ì—¬ 'íƒ­'ì— ì‚¬ìš©ë˜ëŠ” ë°°ì—´ì„ ë¬¸ìì—´ (ì´ ê²½ìš° &lt;code&gt;localStorage&lt;/code&gt; )ë¡œ ì €ì¥í•˜ëŠ” ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ì‘ì„±í•œë‹¤ê³  ê°€ì •í•˜ì‹­ì‹œì˜¤. ë˜í•œ ì½”ë“œì—ì„œ ë°°ì—´ ë©¤ë²„ì˜ ìˆ«ì ì¸ë±ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ í™”ë©´ì— ê·¸ë¦´ ë•Œ &quot;ì œëª©&quot;ì„ ì§€ì •í•œë‹¤ê³  ê°€ì •í•˜ê² ìŠµë‹ˆë‹¤. ì™œ &quot;ì œëª©&quot;ì„ ì €ì¥í•˜ì§€ ì•Šê³  ì™œì´ ì‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆê¹Œ? ì™œëƒë©´ ... &lt;em&gt;ì´ìœ &lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">ì˜ˆë¥¼ ë“¤ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="cdad74d0486512dc3bc4f850907cd467e5fc5e3c" translate="yes" xml:space="preserve">
          <source>For more info about and seeing more example, visit the link below:</source>
          <target state="translated">ë” ë§ì€ ì •ë³´ë¥¼ë³´ê³  ë” ë§ì€ ì˜ˆë¥¼ ë³´ë ¤ë©´ ì•„ë˜ ë§í¬ë¥¼ ë°©ë¬¸í•˜ì‹­ì‹œì˜¤.</target>
        </trans-unit>
        <trans-unit id="3053a4eaab6ecc9daa630f23887af0a663b64dcc" translate="yes" xml:space="preserve">
          <source>Functions which are part of an object (apart from the</source>
          <target state="translated">ê°ì²´ì˜ ì¼ë¶€ì¸ ê¸°ëŠ¥ (</target>
        </trans-unit>
        <trans-unit id="a355b0b1f78d396cf69cf859538e8172e1e8345c" translate="yes" xml:space="preserve">
          <source>Hello You Can try this simple an sort</source>
          <target state="translated">ì•ˆë…•í•˜ì„¸ìš” ë‹¹ì‹ ì€ì´ ê°„ë‹¨í•œ ì¢…ë¥˜ë¥¼ ì‹œë„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</target>
        </trans-unit>
        <trans-unit id="ca27c0a83d24961b91d263af64d922d82a55909c" translate="yes" xml:space="preserve">
          <source>Honestly, aside from setting to &lt;code&gt;null&lt;/code&gt; rather than &lt;code&gt;undefined&lt;/code&gt;--which is legitimately weird--this behavior &lt;em&gt;shouldn't&lt;/em&gt; be surprising, since &lt;code&gt;delete&lt;/code&gt; is a unary operator, like &lt;code&gt;typeof&lt;/code&gt;, that is hard-boiled into the language and is not supposed to care about the &lt;em&gt;type&lt;/em&gt; of object it's being used on, whereas &lt;code&gt;Array&lt;/code&gt; is a subclass of &lt;code&gt;Object&lt;/code&gt; with methods &lt;em&gt;specifically designed for&lt;/em&gt; working with arrays. So there's no good reason for &lt;code&gt;delete&lt;/code&gt; to have a special case cooked in for re-shifting the array, as that would just slow things down with unnecessary work. In retrospect, my expectations were unrealistic.</source>
          <target state="translated">ì†”ì§íˆ &lt;code&gt;undefined&lt;/code&gt; ê²ƒì´ ì•„ë‹Œ &lt;code&gt;null&lt;/code&gt; ë¡œ ì„¤ì •í•˜ëŠ” ê²ƒ ì™¸ì—ë„ í•©ë²•ì ìœ¼ë¡œ ì´ìƒ &lt;em&gt;í•©ë‹ˆë‹¤.&lt;/em&gt; &lt;code&gt;delete&lt;/code&gt; ëŠ” &lt;code&gt;typeof&lt;/code&gt; ì™€ ê°™ì€ ë‹¨í•­ ì—°ì‚°ìì´ë¯€ë¡œ ì–¸ì–´ì— ë“ì—¬ì„œ ì‹ ê²½ ì“°ì§€ ì•Šì•„ì•¼í•©ë‹ˆë‹¤. &lt;code&gt;Array&lt;/code&gt; ëŠ” ë°°ì—´ ì‘ì—…ì„ &lt;em&gt;ìœ„í•´ íŠ¹ë³„íˆ ì„¤ê³„ëœ&lt;/em&gt; ë©”ì†Œë“œê°€ìˆëŠ” &lt;code&gt;Object&lt;/code&gt; ì˜ í•˜ìœ„ í´ë˜ìŠ¤ ì¸ ë°˜ë©´ Array ëŠ” ì‚¬ìš©ì¤‘ì¸ ê°ì²´ì˜ &lt;em&gt;ìœ í˜•&lt;/em&gt; ì— ê´€í•œ ê²ƒì…ë‹ˆë‹¤. ë”°ë¼ì„œ &lt;code&gt;delete&lt;/code&gt; ë¡œ ì¸í•´ ì–´ë ˆì´ë¥¼ ë‹¤ì‹œ ì´ë™ì‹œí‚¤ëŠ” ë° íŠ¹ë³„í•œ ê²½ìš°ê°€ í•„ìš”í•œ ì´ìœ ëŠ” ì—†ìŠµë‹ˆë‹¤. ë¶ˆí•„ìš”í•œ ì‘ì—…ìœ¼ë¡œ ì¸í•´ ì†ë„ê°€ ëŠë ¤ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ëŒì´ì¼œ ë³´ë©´ ì œ ê¸°ëŒ€ëŠ” ë¹„í˜„ì‹¤ì ì´ì—ˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="dc3989e98834042a9457a0de8b90b5c9f3024f13" translate="yes" xml:space="preserve">
          <source>How do I remove a property from a JavaScript object</source>
          <target state="translated">JavaScript ê°ì²´ì—ì„œ ì†ì„±ì„ ì œê±°í•˜ëŠ” ë°©ë²•</target>
        </trans-unit>
        <trans-unit id="b47475af69db5ae110b477abd31ec35a3c7d497a" translate="yes" xml:space="preserve">
          <source>However, be mindful! Do not suddenly start doing this with all your preexisting code now as it would likely break such preexisting code and/or introduce strange bugs. Rather, such an efficient practice needs to be implemented from the start, and when converting preexisting code, it is recommended that you double, triple, quadruple check all the lines relating to that as trying to upgrade old code to this new practice can be as risky as it is rewarding.</source>
          <target state="translated">ê·¸ëŸ¬ë‚˜ì£¼ì˜í•˜ì‹­ì‹œì˜¤! ê¸°ì¡´ ì½”ë“œë¥¼ ëª¨ë‘ ê¹¨ëœ¨ ë¦¬ê±°ë‚˜ ì´ìƒí•œ ë²„ê·¸ë¥¼ ìœ ë°œí•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ê¸°ì¡´ ì½”ë“œë¥¼ ëª¨ë‘ ì‚¬ìš©í•˜ì—¬ ê°‘ìê¸°ì´ ì‘ì—…ì„ ì‹œì‘í•˜ì§€ ë§ˆì‹­ì‹œì˜¤. ì˜¤íˆë ¤ ì´ëŸ¬í•œ íš¨ìœ¨ì ì¸ ì—°ìŠµì€ ì²˜ìŒë¶€í„° êµ¬í˜„í•´ì•¼í•˜ë©° ê¸°ì¡´ ì½”ë“œë¥¼ ë³€í™˜ í•  ë•Œ ì´ì „ ì½”ë“œë¥¼ì´ ìƒˆë¡œìš´ ì—°ìŠµìœ¼ë¡œ ì—…ê·¸ë ˆì´ë“œí•˜ë ¤ê³  í•  ë•Œì™€ ê´€ë ¨ëœ ëª¨ë“  í–‰ì„ ë‘ ë°°, ì„¸ ë°°, ë„¤ ë°°ë¡œ í™•ì¸í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤. ë³´ëŒìˆëŠ” ê²ƒì²˜ëŸ¼ ìœ„í—˜í•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="491f0bae14ec381e286ea282ba5b10bae8f240b9" translate="yes" xml:space="preserve">
          <source>However, it will &lt;strong&gt;mutate&lt;/strong&gt; the original object. If you want to create a new object &lt;strong&gt;without&lt;/strong&gt; the specified key, just assign the reduce function to a new variable, e.g.:</source>
          <target state="translated">ê·¸ëŸ¬ë‚˜ ì›ë³¸ ê°ì²´ëŠ” &lt;strong&gt;ë³€ê²½&lt;/strong&gt; ë©ë‹ˆë‹¤. ì§€ì •ëœ í‚¤ &lt;strong&gt;ì—†ì´&lt;/strong&gt; ìƒˆ ê°ì²´ë¥¼ ë§Œë“¤ë ¤ë©´ ë‹¤ìŒê³¼ ê°™ì´ reduce í•¨ìˆ˜ë¥¼ ìƒˆ ë³€ìˆ˜ì— í• ë‹¹í•˜ì‹­ì‹œì˜¤.</target>
        </trans-unit>
        <trans-unit id="b18c3a88c501a6c91766f406a1e129e6aaa98cea" translate="yes" xml:space="preserve">
          <source>However, there are two major unfixable problems with polymorphic arrays:</source>
          <target state="translated">ê·¸ëŸ¬ë‚˜ ë‹¤í˜•ì„± ë°°ì—´ì—ëŠ” ë‘ ê°€ì§€ ì£¼ìš” ìˆ˜ì • ë¶ˆê°€ëŠ¥í•œ ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="3486394d0c7c983de3c5268328e537d9b15cb8f7" translate="yes" xml:space="preserve">
          <source>However, this code:</source>
          <target state="translated">ê·¸ëŸ¬ë‚˜ì´ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="4a71f7845929b0f0df07acdfaf7d379b182e9259" translate="yes" xml:space="preserve">
          <source>I feel it's important to point out the difference between these two similarly-named functions, as they are both very useful.</source>
          <target state="translated">ë¹„ìŠ·í•œ ì´ë¦„ì„ ê°€ì§„ì´ ë‘ í•¨ìˆ˜ì˜ ì°¨ì´ì ì´ ë§¤ìš° ìœ ìš©í•˜ë‹¤ëŠ” ì ì„ ì§€ì í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•˜ë‹¤ê³  ìƒê°í•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="459a68f17b246b077cb24b6614e54636e1f0783c" translate="yes" xml:space="preserve">
          <source>I personally use &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; or &lt;a href=&quot;https://lodash.com&quot;&gt;Lodash&lt;/a&gt; for object and array manipulation:</source>
          <target state="translated">ê°œì¸ì ìœ¼ë¡œ &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; ë˜ëŠ” &lt;a href=&quot;https://lodash.com&quot;&gt;Lodash&lt;/a&gt; ë¥¼ ì‚¬ìš©í•˜ì—¬ ê°ì²´ ë° ë°°ì—´ ì¡°ì‘ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="a8613a5b1880d971e632b3352e4bfe554f971c46" translate="yes" xml:space="preserve">
          <source>If a property with the same name exists on the object's prototype
  chain, then, after deletion, the object will use the property from the
  prototype chain (in other words, delete only has an effect on own
  properties).</source>
          <target state="translated">ë™ì¼í•œ ì´ë¦„ì˜ ì†ì„±ì´ ê°ì²´ì˜ í”„ë¡œí†  íƒ€ì… ì²´ì¸ì— ì¡´ì¬í•˜ë©´ ì‚­ì œ í›„ ê°ì²´ëŠ” í”„ë¡œí†  íƒ€ì… ì²´ì¸ì˜ ì†ì„±ì„ ì‚¬ìš©í•©ë‹ˆë‹¤ (ì¦‰, ì‚­ì œëŠ” ìì‹ ì˜ ì†ì„±ì—ë§Œ ì˜í–¥ì„ ë¯¸ì¹©ë‹ˆë‹¤).</target>
        </trans-unit>
        <trans-unit id="1e20c9e61654d816a6093dde8b64312b7bd4779b" translate="yes" xml:space="preserve">
          <source>If the property which you are trying to delete does not exist, delete
  will not have any effect and will return true</source>
          <target state="translated">ì‚­ì œí•˜ë ¤ëŠ” ì†ì„±ì´ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ ì‚­ì œëŠ” ì•„ë¬´ëŸ° ì˜í–¥ì„ ë¯¸ì¹˜ì§€ ì•Šìœ¼ë©° trueë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="28ec183a3184d93a675028a4e725a85c94f1f649" translate="yes" xml:space="preserve">
          <source>If you do not know the index, you'll also have to do an index search:</source>
          <target state="translated">ìƒ‰ì¸ì„ ëª¨ë¥´ëŠ” ê²½ìš° ìƒ‰ì¸ ê²€ìƒ‰ë„ ìˆ˜í–‰í•´ì•¼í•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="3204a3a58282102b99263134aa04e4bbd9031c97" translate="yes" xml:space="preserve">
          <source>If you do:</source>
          <target state="translated">ë‹¹ì‹ ì´ í•  ê²½ìš° :</target>
        </trans-unit>
        <trans-unit id="3204f4d5aa25757c4ed3063f2b869d5fde0626d5" translate="yes" xml:space="preserve">
          <source>If you know the index of your staff member, you could simply do this:</source>
          <target state="translated">ì§ì›ì˜ ìƒ‰ì¸ì„ ì•Œê³  ìˆë‹¤ë©´ ê°„ë‹¨íˆ ë‹¤ìŒê³¼ ê°™ì´ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="9b546f76f9301b299e7ed78305baf0ef1addfe1c" translate="yes" xml:space="preserve">
          <source>If you want to delete a property deeply nested in the object then you can use the following recursive function with path to the property as the second argument:</source>
          <target state="translated">ê°ì²´ì— ê¹Šê²Œ ì¤‘ì²© ëœ ì†ì„±ì„ ì‚­ì œí•˜ë ¤ë©´ ì†ì„±ì— ëŒ€í•œ ê²½ë¡œì™€ í•¨ê»˜ ë‘ ë²ˆì§¸ ì¸ìˆ˜ë¡œ ë‹¤ìŒê³¼ ê°™ì€ ì¬ê·€ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="506bf20b873a7a4cd476c438c371ecd4bcca65fc" translate="yes" xml:space="preserve">
          <source>If you want to experiment with this, you can use &lt;a href=&quot;http://jsfiddle.net/cb57dusv/46/&quot;&gt;&lt;strong&gt;this Fiddle&lt;/strong&gt;&lt;/a&gt; as a starting point.</source>
          <target state="translated">ì´ê²ƒì„ ì‹¤í—˜í•˜ê³  ì‹¶ë‹¤ë©´ &lt;a href=&quot;http://jsfiddle.net/cb57dusv/46/&quot;&gt;&lt;strong&gt;ì´ ë°”ì´ì˜¬ë¦°&lt;/strong&gt;&lt;/a&gt; ì„ ì¶œë°œì ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="a4e72696da1b895cd7644dbb4f08034ae76c1836" translate="yes" xml:space="preserve">
          <source>If you want to use the entire &lt;code&gt;staff&lt;/code&gt; array, the proper way to do this, would be to do this:</source>
          <target state="translated">ì „ì²´ &lt;code&gt;staff&lt;/code&gt; ë°°ì—´ì„ ì‚¬ìš©í•˜ë ¤ëŠ” ê²½ìš°ì´ë¥¼ ìˆ˜í–‰í•˜ëŠ” ì˜¬ë°”ë¥¸ ë°©ë²•ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="43cf8d099321d601790e8b3431ad74fdf17809c0" translate="yes" xml:space="preserve">
          <source>Ignoring the dangers and problems inherent in &lt;code&gt;null&lt;/code&gt;, and the space wasted, this can be problematic if the array needs to be precise.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; ì— ë‚´ì¬ ëœ ìœ„í—˜ê³¼ ë¬¸ì œë¥¼ ë¬´ì‹œí•˜ê³  ê³µê°„ì„ ë‚­ë¹„í•˜ë©´ ë°°ì—´ì´ ì •í™•í•´ì•¼í•˜ëŠ” ê²½ìš° ë¬¸ì œê°€ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="c138b726889b4f8045cc8db17ba22f8faa709ac8" translate="yes" xml:space="preserve">
          <source>In addition, while mutating objects in-place isn't stateless, you can use the functional nature of &lt;code&gt;Reflect.deleteProperty&lt;/code&gt; to do partial application and other functional techniques that aren't possible with &lt;code&gt;delete&lt;/code&gt; statements.</source>
          <target state="translated">ë˜í•œ, ë‚´ë¶€ì—ì„œ ê°ì²´ë¥¼ ë³€ê²½í•˜ëŠ” ê²ƒì€ ìƒíƒœ ë¹„ ì €ì¥ì´ ì•„ë‹ˆì§€ë§Œ &lt;code&gt;Reflect.deleteProperty&lt;/code&gt; ì˜ ê¸°ëŠ¥ì  íŠ¹ì„±ì„ ì‚¬ìš©í•˜ì—¬ &lt;code&gt;delete&lt;/code&gt; ë¬¸ìœ¼ë¡œëŠ” ë¶ˆê°€ëŠ¥í•œ ë¶€ë¶„ì  ì‘ìš© í”„ë¡œê·¸ë¨ ë° ê¸°íƒ€ ê¸°ëŠ¥ ê¸°ìˆ ì„ ìˆ˜í–‰ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="5b114aff6680bfc75db078ff75477b94c1c576aa" translate="yes" xml:space="preserve">
          <source>In arrays, unlike plain old objects, using &lt;code&gt;delete&lt;/code&gt; leaves behind garbage in the form of &lt;code&gt;null&lt;/code&gt;, creating a &quot;hole&quot; in the array.</source>
          <target state="translated">ì¼ë°˜ ì˜¤ë˜ëœ ê°ì²´ì™€ ë‹¬ë¦¬ ë°°ì—´ì—ì„œëŠ” ê°€ë¹„ì§€ ë’¤ì— &lt;code&gt;delete&lt;/code&gt; leavesì„ &lt;code&gt;null&lt;/code&gt; í˜•ì‹ìœ¼ë¡œ ì‚¬ìš©í•˜ì—¬ ë°°ì—´ì— &quot;êµ¬ë©&quot;ì„ ë§Œë“­ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="acf20d554a4832d04b9fb4c2dfc6cc9d34eda721" translate="yes" xml:space="preserve">
          <source>In the code above, simply doing &lt;code&gt;nodeRecords[i][lastTime] = undefined;&lt;/code&gt; will cause a massive memory leak because each animation frame. Each frame, all 65536 DOM elements will take up another 65536 individual slots, but the previous 65536 slots will only be set to undefined which leaves them hanging in the memory. Go ahead, try to run the above code in the console and see for yourself. After forcing an out-of-memory error, attempt to run it again except with the following version of the code that uses the &lt;code&gt;delete&lt;/code&gt; operator instead.</source>
          <target state="translated">ìœ„ ì½”ë“œì—ì„œ ê°„ë‹¨íˆ &lt;code&gt;nodeRecords[i][lastTime] = undefined;&lt;/code&gt; ê° ì• ë‹ˆë©”ì´ì…˜ í”„ë ˆì„ìœ¼ë¡œ ì¸í•´ ì—„ì²­ë‚œ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ê°€ ë°œìƒí•©ë‹ˆë‹¤. ê° í”„ë ˆì„, ëª¨ë“  65536 DOM ìš”ì†ŒëŠ” ë‹¤ë¥¸ 65536 ê°œë³„ ìŠ¬ë¡¯ì„ ì°¨ì§€í•˜ì§€ë§Œ ì´ì „ 65536 ìŠ¬ë¡¯ì€ ì •ì˜ë˜ì§€ ì•Šì€ ìƒíƒœë¡œ ì„¤ì •ë˜ì–´ ë©”ëª¨ë¦¬ì— ê±¸ë ¤ ìˆìŠµë‹ˆë‹¤. ì½˜ì†”ì—ì„œ ìœ„ì˜ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ê³  ì§ì ‘ í™•ì¸í•˜ì‹­ì‹œì˜¤. ë©”ëª¨ë¦¬ ë¶€ì¡± ì˜¤ë¥˜ê°€ ë°œìƒí•˜ë©´ &lt;code&gt;delete&lt;/code&gt; ì—°ì‚°ìë¥¼ ëŒ€ì‹  ì‚¬ìš©í•˜ëŠ” ë‹¤ìŒ ë²„ì „ì˜ ì½”ë“œë¥¼ ì œì™¸í•˜ê³  ë‹¤ì‹œ ì‹¤í–‰ í•´ë³´ì‹­ì‹œì˜¤.</target>
        </trans-unit>
        <trans-unit id="271f117734d63131f8d6a45f399a766357be7419" translate="yes" xml:space="preserve">
          <source>Increasingly stupid edge-case scenario aside, using &lt;code&gt;delete&lt;/code&gt; on said array will result in &lt;code&gt;null&lt;/code&gt; polluting the array, and probably causing bugs in the app later on. And if you check for &lt;code&gt;null&lt;/code&gt;, it would straight up skip the numbers resulting in the tabs being rendered like &lt;code&gt;[1] [2] [4] [5] ...&lt;/code&gt;.</source>
          <target state="translated">ì–´ë¦¬ì„ì€ ëŒ€ì†Œ ë¬¸ì ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ì œì™¸í•˜ê³ , ìƒê¸° ë°°ì—´ì—ì„œ &lt;code&gt;delete&lt;/code&gt; ë¥¼ ì‚¬ìš©í•˜ë©´ ë°°ì—´ì„ &lt;code&gt;null&lt;/code&gt; ë¡œ ì˜¤ì—¼ì‹œí‚¤ê³  ë‚˜ì¤‘ì— ì•±ì— ë²„ê·¸ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³  &lt;code&gt;null&lt;/code&gt; ì„ í™•ì¸í•˜ë©´ &lt;code&gt;[1] [2] [4] [5] ...&lt;/code&gt; ì™€ ê°™ì´ íƒ­ì´ ë Œë”ë§ë˜ëŠ” ìˆ«ìë¥¼ ê±´ë„ˆ ëœë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="67a2e0451ade99e58384dc55f1327e29e5977c70" translate="yes" xml:space="preserve">
          <source>It &lt;strong&gt;deletes the key from the hashmap&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;í•´ì‹œ ë§µì—ì„œ í‚¤ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="593fba807066e533a5fe4a2443019f46d7ca31da" translate="yes" xml:space="preserve">
          <source>JavaScript is an OOP Language, so everything is an object, including &lt;em&gt;arrays&lt;/em&gt;. Thus, I feel it necessary to point out a particular caveat.</source>
          <target state="translated">JavaScriptëŠ” OOP ì–¸ì–´ì´ë¯€ë¡œ &lt;em&gt;arraysë¥¼&lt;/em&gt; í¬í•¨í•œ ëª¨ë“  ê²ƒì´ ê°ì²´ì…ë‹ˆë‹¤. ë”°ë¼ì„œ íŠ¹ì • ê²½ê³  ì‚¬í•­ì„ ì§€ì í•´ì•¼í•œë‹¤ê³  ìƒê°í•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="b86b332c3f3aa1433f370f7189813a6381eb2178" translate="yes" xml:space="preserve">
          <source>Library-based property omission</source>
          <target state="translated">ë„ì„œê´€ ê¸°ë°˜ ë¶€ë™ì‚° ëˆ„ë½</target>
        </trans-unit>
        <trans-unit id="59b86486aed4edafd59a372a9da15c32460385f0" translate="yes" xml:space="preserve">
          <source>Like this:</source>
          <target state="translated">ì´ì²˜ëŸ¼ :</target>
        </trans-unit>
        <trans-unit id="23ee237b458378f4f66052abb7c903c28cbb18e4" translate="yes" xml:space="preserve">
          <source>Look at the &lt;strong&gt;&lt;a href=&quot;http://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;benchmark&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://jsperf.com/delete-vs-undefined-vs-null/16&quot;&gt;ë²¤ì¹˜ ë§ˆí¬ë¥¼ë³´ì‹­ì‹œì˜¤&lt;/a&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d0447456284f7feabbe03be15bd344b6f319890b" translate="yes" xml:space="preserve">
          <source>Luckily, arrays &lt;em&gt;do&lt;/em&gt; have a specialized method for deleting indices and reallocating memory: &lt;code&gt;Array.prototype.splice()&lt;/code&gt;. You could write something like this:</source>
          <target state="translated">ìš´ ì¢‹ê²Œë„, ë°°ì—´ì—ëŠ” ì¸ë±ìŠ¤ë¥¼ ì‚­ì œí•˜ê³  ë©”ëª¨ë¦¬ë¥¼ ì¬ í• ë‹¹í•˜ëŠ” íŠ¹ìˆ˜í•œ ë©”ì†Œë“œ ì¸ &lt;code&gt;Array.prototype.splice()&lt;/code&gt; ìˆìŠµë‹ˆë‹¤. ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="098d9f24825c866c84675902efcb46bcadb54327" translate="yes" xml:space="preserve">
          <source>More than 2X faster than &lt;code&gt;delete&lt;/code&gt;, however the property is &lt;strong&gt;not&lt;/strong&gt; deleted and can be iterated.</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; ë³´ë‹¤ 2 ë°° ì´ìƒ ë¹ ë¥´ì§€ ë§Œ ì†ì„±ì€ ì‚­ì œ &lt;strong&gt;ë˜ì§€ ì•Šê³ &lt;/strong&gt; ë°˜ë³µ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="ccc762c5d3373bf8a3cde8b635c9825605d01c63" translate="yes" xml:space="preserve">
          <source>Mutative object property deletion, safe</source>
          <target state="translated">ì•ˆì „í•œ ëŒì—°ë³€ì´ ê°ì²´ ì†ì„± ì‚­ì œ</target>
        </trans-unit>
        <trans-unit id="9ce68ac5a3111b339ada2a12dd8cc6eea0e45ffa" translate="yes" xml:space="preserve">
          <source>Mutative object property deletion, unsafe</source>
          <target state="translated">ì•ˆì „í•˜ì§€ ì•Šì€ ëŒì—°ë³€ì´ ê°ì²´ ì†ì„± ì‚­ì œ</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="089de7283699cfb1ed6d519cb14e7b0cf6326b5b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;_.pick()&lt;/code&gt; and &lt;code&gt;_.omit()&lt;/code&gt; both return a copy of the object and don't directly modify the original object. Assigning the result to the original object should do the trick (not shown).</source>
          <target state="translated">&lt;code&gt;_.pick()&lt;/code&gt; ë° &lt;code&gt;_.omit()&lt;/code&gt; ëª¨ë‘ ê°ì²´ì˜ ë³µì‚¬ë³¸ì„ ë°˜í™˜í•˜ë©° ì›ë˜ ê°ì²´ë¥¼ ì§ì ‘ ìˆ˜ì •í•˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤. ì›ë˜ ê°ì²´ì— ê²°ê³¼ë¥¼ í• ë‹¹í•˜ë©´ íŠ¸ë¦­ì„ ìˆ˜í–‰í•´ì•¼í•©ë‹ˆë‹¤ (í‘œì‹œë˜ì§€ ì•ŠìŒ).</target>
        </trans-unit>
        <trans-unit id="74d18dd16f1da3ac16685fb7e2b20e82dd3d4708" translate="yes" xml:space="preserve">
          <source>Note that I purposedly carried out more than one 'delete' operations in one loop cycle to minimize the effect caused by the other operations.</source>
          <target state="translated">ë‹¤ë¥¸ ì‘ì—…ìœ¼ë¡œ ì¸í•œ ì˜í–¥ì„ ìµœì†Œí™”í•˜ê¸° ìœ„í•´ í•œ ë£¨í”„ì£¼ê¸°ì—ì„œ ì—¬ëŸ¬ ê°œì˜ 'ì‚­ì œ'ì‘ì—…ì„ ì˜ë„ì ìœ¼ë¡œ ìˆ˜í–‰í–ˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="cbc78d0538f8d0b1ea57d6e615c0173c54cc2f85" translate="yes" xml:space="preserve">
          <source>Note that the wrapper function is designed to be very strict about types, and will return &lt;code&gt;null&lt;/code&gt; if anything is off. That includes putting in a string like &lt;code&gt;&quot;3&quot;&lt;/code&gt;. It is left up to the programmer to be diligent about his types. This is to encourage good programming practice.</source>
          <target state="translated">ë©í¼ í•¨ìˆ˜ëŠ” ìœ í˜•ì— ëŒ€í•´ ë§¤ìš° ì—„ê²©í•˜ê²Œ ì„¤ê³„ë˜ì—ˆìœ¼ë©°, êº¼ì ¸ìˆëŠ” ê²½ìš° &lt;code&gt;null&lt;/code&gt; ì„ ë¦¬í„´í•©ë‹ˆë‹¤. ì—¬ê¸°ì—ëŠ” &lt;code&gt;&quot;3&quot;&lt;/code&gt; ê³¼ ê°™ì€ ë¬¸ìì—´ì„ ë„£ëŠ” ê²ƒì´ í¬í•¨ë©ë‹ˆë‹¤. ê·¸ì˜ íƒ€ì…ì— ëŒ€í•´ ë¶€ì§€ëŸ°íˆí•˜ëŠ” ê²ƒì€ í”„ë¡œê·¸ë˜ë¨¸ì—ê²Œ ë‹¬ë ¤ ìˆìŠµë‹ˆë‹¤. ì´ê²ƒì€ ì¢‹ì€ í”„ë¡œê·¸ë˜ë° ì—°ìŠµì„ ì¥ë ¤í•˜ê¸°ìœ„í•œ ê²ƒì…ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="0cd1e1c286ff1b960d2aa87f0e85fe9bd6a35fdd" translate="yes" xml:space="preserve">
          <source>Now, if you want to remove a single staff member or student, the procedure is a bit different, because both properties are arrays themselves.</source>
          <target state="translated">ì´ì œ ë‹¨ì¼ ì§ì›ì´ë‚˜ í•™ìƒì„ ì œê±°í•˜ë ¤ëŠ” ê²½ìš° ë‘ ì†ì„±ì´ ëª¨ë‘ ë°°ì—´ì´ë¯€ë¡œ ì ˆì°¨ê°€ ì•½ê°„ ë‹¤ë¦…ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="e14273e8bb73415bec8db17e1b9d548211a7aed0" translate="yes" xml:space="preserve">
          <source>Now, you &lt;em&gt;could&lt;/em&gt; keep a second iterator, like &lt;code&gt;j&lt;/code&gt;, to increment only when valid values are read from the array. But that wouldn't exactly solve the &lt;code&gt;null&lt;/code&gt; issue, and you still have to please that &lt;s&gt;troll&lt;/s&gt; PDP-11 user. Alas, his computer just &lt;em&gt;doesn't&lt;/em&gt; have enough memory to hold that last integer &lt;sub&gt;(don't ask how he manages to handle a variable-width array...)&lt;/sub&gt;.</source>
          <target state="translated">ì´ì œ ë°°ì—´ì—ì„œ ìœ íš¨í•œ ê°’ì„ ì½ì„ ë•Œë§Œ ì¦ê°€í•˜ë„ë¡ &lt;code&gt;j&lt;/code&gt; ì™€ ê°™ì€ ë‘ ë²ˆì§¸ ë°˜ë³µìë¥¼ ìœ ì§€í•  &lt;em&gt;ìˆ˜&lt;/em&gt; ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì´ê²ƒì´ &lt;code&gt;null&lt;/code&gt; ë¬¸ì œë¥¼ ì •í™•í•˜ê²Œ í•´ê²°í•˜ì§€ëŠ” &lt;s&gt;ëª»í•˜ì§€ë§Œ&lt;/s&gt; ì—¬ì „íˆ &lt;s&gt;íŠ¸ë¡¤&lt;/s&gt; PDP-11 ì‚¬ìš©ìë¥¼ ê¸°ì˜ê²Œí•´ì•¼í•©ë‹ˆë‹¤. ì•„ì•„, ê·¸ì˜ ì»´í“¨í„°ì—ëŠ” ë§ˆì§€ë§‰ ì •ìˆ˜ë¥¼ ë‹´ì„ ìˆ˜ìˆëŠ” ë©”ëª¨ë¦¬ê°€ ì¶©ë¶„ &lt;em&gt;í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤&lt;/em&gt; &lt;sub&gt;(ë³€ìˆ˜ ë„ˆë¹„ ë°°ì—´ì„ ì²˜ë¦¬í•˜ëŠ” ë°©ë²•ì„ ë¬»ì§€ ë§ˆì‹­ì‹œì˜¤ ...)&lt;/sub&gt; .</target>
        </trans-unit>
        <trans-unit id="e28b55f542be9cce84f1cc3f1bdb29e2a2eb72e0" translate="yes" xml:space="preserve">
          <source>Object.assign() &amp;amp; Object.keys() &amp;amp; Array.map()</source>
          <target state="translated">Object.assign () ë° Object.keys () ë° Array.map ()</target>
        </trans-unit>
        <trans-unit id="c643fe374f1dfb8aa281ee046c5ea254b1b7b942" translate="yes" xml:space="preserve">
          <source>Observe. &lt;code&gt;bar[1] = &quot;&quot;&lt;/code&gt; does not coerce polymorphism whereas &lt;code&gt;bar[1] = undefined&lt;/code&gt; does. Therefore, one should always, whenever possible use the corresponding type for their objects so as to not accidentally cause polymorphism. One such person may use the following list as a general reference to get them going. However, please do not explicitly use the below ideas. Instead, use whatever works well for your code.</source>
          <target state="translated">ê´€ì°°í•˜ì‹­ì‹œì˜¤. &lt;code&gt;bar[1] = &quot;&quot;&lt;/code&gt; ëŠ” ë‹¤í˜•ì„±ì„ ê°•ì œí•˜ì§€ ì•Šì§€ë§Œ &lt;code&gt;bar[1] = undefined&lt;/code&gt; ëŠ” ê·¸ë ‡ì§€ ì•ŠìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ìš°ì—°íˆ ë‹¤í˜•ì„±ì„ ì¼ìœ¼í‚¤ì§€ ì•Šë„ë¡ ê°€ëŠ¥í•œ í•œ í•­ìƒ ê°ì²´ì— í•´ë‹¹ ìœ í˜•ì„ ì‚¬ìš©í•´ì•¼í•©ë‹ˆë‹¤. ê·¸ëŸ¬í•œ ì‚¬ëŒ ì¤‘ í•œ ëª…ì´ ë‹¤ìŒ ëª©ë¡ì„ ì¼ë°˜ì ì¸ ì°¸ì¡°ë¡œ ì‚¬ìš©í•˜ì—¬ ì§„í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì•„ë˜ ì•„ì´ë””ì–´ë¥¼ ëª…ì‹œ ì ìœ¼ë¡œ ì‚¬ìš©í•˜ì§€ ë§ˆì‹­ì‹œì˜¤. ëŒ€ì‹  ì½”ë“œì— ì˜ ë§ëŠ” ê²ƒì„ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤.</target>
        </trans-unit>
        <trans-unit id="e583eed26b5bb4eb2fe3ea98e3d4481f60fbfae9" translate="yes" xml:space="preserve">
          <source>Of course, it &lt;em&gt;did&lt;/em&gt; surprise me. Because I wrote this to justify my crusade against &quot;null garbage&quot;:</source>
          <target state="translated">ë¬¼ë¡  ë†€ëìŠµë‹ˆë‹¤. ë‚˜ëŠ” &quot;ë„ ì“°ë ˆê¸°&quot;ì— ëŒ€í•œ ë‚´ ì„±ì „ì„ ì •ë‹¹í™”í•˜ê¸° ìœ„í•´ ì´ê²ƒì„ ì¼ê¸° ë•Œë¬¸ì— :</target>
        </trans-unit>
        <trans-unit id="9d008b07517f4d9dbae6df29270e3dfc66dcea5d" translate="yes" xml:space="preserve">
          <source>Okay, let's just say that you're trying to save memory at the request of this &lt;em&gt;one&lt;/em&gt; user who runs a PDP-11 minicomputer from the 1960's running UNIX and wrote his own Elinks-based, JavaScript-compliant, line-printer-friendly browser because X11 is &lt;em&gt;out of the question&lt;/em&gt;.</source>
          <target state="translated">ì, 1960 ë…„ëŒ€ UNIXë¥¼ ì‹¤í–‰í•˜ëŠ” PDP-11 ë¯¸ë‹ˆ ì»´í“¨í„°ë¥¼ ì‹¤í–‰í•˜ê³  ìì²´ Elinks ê¸°ë°˜ì˜ JavaScript í˜¸í™˜ ë¼ì¸ í”„ë¦°í„° ì¹œí™”ì  ë¸Œë¼ìš°ì €ë¥¼ ì‘ì„±í•œì´ ì‚¬ìš©ìì˜ ìš”ì²­ì— ë”°ë¼ ë©”ëª¨ë¦¬ë¥¼ ì ˆì•½í•˜ë ¤ê³ í•œë‹¤ê³  ê°€ì • í•´ ë´…ì‹œë‹¤. X11ì´ &lt;em&gt;ë¬¸ì œ&lt;/em&gt; ê°€ ì•„ë‹ˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="0746b7ec72e10adab007597141d3dddd2450c60e" translate="yes" xml:space="preserve">
          <source>Old question, modern answer. Using object destructuring, an &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015&quot;&gt;ECMAScript&amp;nbsp;6&lt;/a&gt; feature, it's as simple as:</source>
          <target state="translated">ì˜¤ë˜ëœ ì§ˆë¬¸, í˜„ëŒ€ì ì¸ ë‹µë³€. &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015&quot;&gt;ECMAScript 6&lt;/a&gt; ê¸°ëŠ¥ì¸ ê°ì²´ ë””ìŠ¤íŠ¸ ëŸ­ì²˜ë§ì„ ì‚¬ìš©í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì´ ê°„ë‹¨í•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="88891f47a253aa57bb1cb91937b9715b281db53b" translate="yes" xml:space="preserve">
          <source>Once polymorphic, always polymorphic. When an array is made polymorphic, the polymorphism cannot be undone in Webkit browsers. So, even if you restore a polymorphic array to being non-polymorphic, it will still be stored by the browser as a polymorphic array.</source>
          <target state="translated">ë‹¤í˜•ì„±ì´ë˜ë©´ í•­ìƒ ë‹¤í˜•ì„±ì´ë©ë‹ˆë‹¤. ë°°ì—´ì„ ë‹¤í˜•ì„±ìœ¼ë¡œ ë§Œë“¤ë©´ ì›¹í‚· ë¸Œë¼ìš°ì €ì—ì„œ ë‹¤í˜•ì„±ì„ ì·¨ì†Œ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ë‹¤í˜•ì„± ë°°ì—´ì„ ë‹¤í˜•ì„±ì´ ì•„ë‹Œ ê²ƒìœ¼ë¡œ ë³µì›í•˜ë”ë¼ë„ ë¸Œë¼ìš°ì €ì—ì„œëŠ” ì—¬ì „íˆ ë‹¤í˜•ì„± ë°°ì—´ë¡œ ì €ì¥í•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="b248f1b8652c2d4ab474434fceed81458cb94383" translate="yes" xml:space="preserve">
          <source>Once those four queries have been answered, there are essentially four categories of &quot;property removal&quot; in JavaScript to chose from in order to meet your goals. They are:</source>
          <target state="translated">ì´ ë„¤ ê°€ì§€ ì§ˆë¬¸ì— ëŒ€í•œ ë‹µë³€ì´ ë‚˜ì˜¤ë©´, ëª©í‘œë¥¼ ë‹¬ì„±í•˜ê¸° ìœ„í•´ JavaScriptì—ì„œ ì„ íƒí•  ìˆ˜ìˆëŠ” ë„¤ ê°€ì§€ ë²”ì£¼ì˜ &quot;ì†ì„± ì œê±°&quot;ê°€ ìˆìŠµë‹ˆë‹¤. ê·¸ë“¤ì€:</target>
        </trans-unit>
        <trans-unit id="547c95266578e4dba22f41101c7fbe880f75e156" translate="yes" xml:space="preserve">
          <source>One aspect of Javascript that is important to consider is polymorphism. Polymorphism is when assigning the same variable/slot-in-an-object different types as seen below.</source>
          <target state="translated">ê³ ë ¤í•´ì•¼ í•  Javascriptì˜ í•œ ê°€ì§€ ì¸¡ë©´ì€ ë‹¤í˜•ì„±ì…ë‹ˆë‹¤. ë‹¤í˜•ì„±ì€ ì•„ë˜ì™€ ê°™ì´ ë™ì¼í•œ ë³€ìˆ˜ / ìŠ¬ë¡¯-ì¸-ì˜¤ë¸Œì íŠ¸ ë‹¤ë¥¸ ìœ í˜•ì„ ì§€ì •í•  ë•Œì…ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="d59804a9108998189135354633d8b85aa6ac9872" translate="yes" xml:space="preserve">
          <source>One may liken polymorphism to a drug addiction. At first glance, it seems awesomely lucrative: nice pretty fluffy code. Then, the coder introduces their array to the drug of polymorphism. Instantly, the polymorphic array becomes less efficient, and it can never become as efficient as it was before since it is drugged. To correlate such circumstance to real life, someone on cocaine might not even be capable of operating a simple door handle, much less be able to calculate digits of PI. Likewise, an array on the drug of polymorphism cannot ever be as efficient as a monomorphic array.</source>
          <target state="translated">ë‹¤í˜•ì„±ì„ ì•½ë¬¼ ì¤‘ë…ì— ë¹„ìœ  í•  ìˆ˜ìˆë‹¤. ì–¸ëœ»ë³´ê¸°ì—ëŠ” ë©‹ì§„ ìˆ˜ìµì„±ì´ìˆëŠ” ê²ƒì²˜ëŸ¼ ë³´ì…ë‹ˆë‹¤. ê·¸ëŸ° ë‹¤ìŒ ì½”ë”ëŠ” ë‹¤í˜•ì„± ì•½ë¬¼ì— ë°°ì—´ì„ ë„ì…í•©ë‹ˆë‹¤. ì¦‰ì‹œ, ë‹¤í˜•ì„± ì–´ë ˆì´ëŠ” ëœ íš¨ìœ¨ì ì´ë˜ê³ , ì•½ë¬¼ íˆ¬ì—¬ ëœ ì´í›„ë¡œ ì˜ˆì „ë§Œí¼ íš¨ìœ¨ì ì´ ë  ìˆ˜ ì—†ë‹¤. ì´ëŸ¬í•œ ìƒí™©ì„ ì‹¤ì œ ìƒí™œê³¼ ì—°ê´€ì‹œí‚¤ê¸° ìœ„í•´ ì½”ì¹´ì¸ì„ ì‚¬ìš©í•˜ëŠ” ì‚¬ëŒì€ ê°„ë‹¨í•œ ë¬¸ ì†ì¡ì´ë¥¼ ì¡°ì‘ í•  ìˆ˜ì—†ê³  PIì˜ ìë¦¿ìˆ˜ë¥¼ ê³„ì‚°í•  ìˆ˜ìˆëŠ” ëŠ¥ë ¥ì´ í›¨ì”¬ ë–¨ì–´ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë§ˆì°¬ê°€ì§€ë¡œ, ë‹¤í˜•ì„± ì•½ë¬¼ì˜ ì–´ë ˆì´ëŠ” ë‹¨ì¼ ì–´ë ˆì´ë§Œí¼ íš¨ìœ¨ì ì¼ ìˆ˜ ì—†ë‹¤.</target>
        </trans-unit>
        <trans-unit id="81ec1a879d1bcac8eaeb3bcd6cca8f51d459b6e9" translate="yes" xml:space="preserve">
          <source>Operator &lt;code&gt;delete&lt;/code&gt; is unexpectedly slow!</source>
          <target state="translated">ìš´ì˜ì &lt;code&gt;delete&lt;/code&gt; ê°€ ì˜ˆê¸°ì¹˜ ì•Šê²Œ ëŠë¦½ë‹ˆë‹¤!</target>
        </trans-unit>
        <trans-unit id="b0213d049275e53829195e4fb176386bc570f98e" translate="yes" xml:space="preserve">
          <source>Or add it as a new pointer to another object like:</source>
          <target state="translated">ë˜ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë‹¤ë¥¸ ê°ì²´ì— ëŒ€í•œ ìƒˆ í¬ì¸í„°ë¡œ ì¶”ê°€í•˜ì‹­ì‹œì˜¤.</target>
        </trans-unit>
        <trans-unit id="b02fc9813af3fdbb140c9b950f4bb96861bf726a" translate="yes" xml:space="preserve">
          <source>Or with the questions sample:</source>
          <target state="translated">ë˜ëŠ” ì§ˆë¬¸ ìƒ˜í”Œì˜ ê²½ìš° :</target>
        </trans-unit>
        <trans-unit id="e9b0d0e32654faf6fc06ca2ce8663172c501d507" translate="yes" xml:space="preserve">
          <source>Or you can also use array-like notation:</source>
          <target state="translated">ë˜ëŠ” ë°°ì—´ê³¼ ê°™ì€ í‘œê¸°ë²•ì„ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="040435ad5191a6323d4b61a949b35014d90fb332" translate="yes" xml:space="preserve">
          <source>Or you can dynamically exclude properties like this,</source>
          <target state="translated">ë˜ëŠ” ì´ì™€ ê°™ì€ ì†ì„±ì„ ë™ì ìœ¼ë¡œ ì œì™¸ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="a7ca816fcb165b225c5a6969cca6cd3afa101c70" translate="yes" xml:space="preserve">
          <source>Properties can be removed using &lt;strong&gt;destructuring&lt;/strong&gt; in combination with the &lt;strong&gt;rest operator&lt;/strong&gt;. In your example regex is destructured out (ignored) and the rest of the properties are returned as rest.</source>
          <target state="translated">&lt;strong&gt;ë‚˜ë¨¸ì§€ ì—°ì‚°ì&lt;/strong&gt; ì™€ í•¨ê»˜ êµ¬ì¡°ë¥¼ ì œê±°í•˜ì—¬ ì†ì„±ì„ ì œê±° í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·€í•˜ì˜ ì˜ˆì—ì„œ ì •ê·œ í‘œí˜„ì‹ì€ êµ¬ì¡°í™”ë˜ì§€ ì•Šê³  (ë¬´ì‹œ) â€‹â€‹ë‚˜ë¨¸ì§€ ì†ì„±ì€ ë‚˜ë¨¸ì§€ë¡œ ë°˜í™˜ë©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="257bb222f1c06e8c1d8edf559d64e06deb75f2f0" translate="yes" xml:space="preserve">
          <source>Property Removal in JavaScript</source>
          <target state="translated">JavaScriptì—ì„œ ì†ì„± ì œê±°</target>
        </trans-unit>
        <trans-unit id="83a4727bcff27e1d95598a97b2a871336f59a8c8" translate="yes" xml:space="preserve">
          <source>Readable and short, however, it might not be the best choice if you are operating on a large number of objects as its performance is not optimized.</source>
          <target state="translated">ê·¸ëŸ¬ë‚˜ ì½ê¸° ì‰½ê³  ì§§ì§€ ë§Œ ì„±ëŠ¥ì´ ìµœì í™”ë˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì— ë§ì€ ìˆ˜ì˜ ê°ì²´ì—ì„œ ì‘ì—…í•˜ëŠ” ê²½ìš° ìµœì„ ì˜ ì„ íƒì´ ì•„ë‹ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="ce7827682ca4a098e50c7905bb13aa7c7e60006c" translate="yes" xml:space="preserve">
          <source>Ref: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;MDN&lt;/a&gt;.</source>
          <target state="translated">ì°¸ì¡° : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;MDN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f02218cedd8e4fd7e585302dc05d8d0a5833d5f0" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://underscorejs.org/#omit&quot;&gt;link&lt;/a&gt;&lt;strong&gt;_.omit(object, *keys)&lt;/strong&gt;</source>
          <target state="translated">ì°¸ì¡° : &lt;a href=&quot;http://underscorejs.org/#omit&quot;&gt;link&lt;/a&gt; &lt;strong&gt;_.omit (object, * keys)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a3c1aeff97f5a6d2ba0a975a623e96c949b36be" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://underscorejs.org/#pick&quot;&gt;link&lt;/a&gt;&lt;strong&gt;_.pick(object, *keys)&lt;/strong&gt;</source>
          <target state="translated">ì°¸ì¡° : &lt;a href=&quot;http://underscorejs.org/#pick&quot;&gt;link&lt;/a&gt; &lt;strong&gt;_.pick (object, * keys)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5817e749619edf322d60f85b86cab9c7f83094af" translate="yes" xml:space="preserve">
          <source>Rest-based string property omission</source>
          <target state="translated">ë‚˜ë¨¸ì§€ ê¸°ë°˜ ë¬¸ìì—´ ì†ì„± ìƒëµ</target>
        </trans-unit>
        <trans-unit id="ab303515578a450fdf614933afe415b6528c01d1" translate="yes" xml:space="preserve">
          <source>Return a copy of the object, filtered to omit the 
blacklisted keys (or array of keys).</source>
          <target state="translated">ì°¨ë‹¨ ëœ í‚¤ (ë˜ëŠ” í‚¤ ë°°ì—´)ë¥¼ ìƒëµí•˜ë„ë¡ í•„í„°ë§ ëœ ê°ì²´ì˜ ë³µì‚¬ë³¸ì„ ë°˜í™˜í•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="011a1cad4539d30348ba24adcd37dceade1f93c1" translate="yes" xml:space="preserve">
          <source>Return a copy of the object, filtered to only have values for the 
whitelisted keys (or array of valid keys).</source>
          <target state="translated">í—ˆìš© ëœ í‚¤ (ë˜ëŠ” ìœ íš¨í•œ í‚¤ ë°°ì—´)ì˜ ê°’ë§Œ ê°–ë„ë¡ í•„í„°ë§ ëœ ê°ì²´ì˜ ë³µì‚¬ë³¸ì„ ë°˜í™˜í•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="650045349baef87a1fa74815eb1e6653f73e4e45" translate="yes" xml:space="preserve">
          <source>Say I create an object as follows:</source>
          <target state="translated">ë‹¤ìŒê³¼ ê°™ì´ ê°ì²´ë¥¼ ìƒì„±í•œë‹¤ê³  ê°€ì • í•´ë³´ì‹­ì‹œì˜¤.</target>
        </trans-unit>
        <trans-unit id="f5d2829fcf8f71f8331358342fe9021d00422606" translate="yes" xml:space="preserve">
          <source>Setting a property to null before deleting it doesn't accomplish
  anything (unless the object has been sealed by Object.seal and the
  delete fails. That's not usually the case unless you specifically
  try).</source>
          <target state="translated">ì†ì„±ì„ ì‚­ì œí•˜ê¸° ì „ì— nullë¡œ ì„¤ì •í•˜ë©´ ì•„ë¬´ê²ƒë„ ë‹¬ì„±ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤ (ê°ì²´ê°€ Object.sealì— ì˜í•´ ë´‰ì¸ë˜ì–´ ìˆê³  ì‚­ì œê°€ ì‹¤íŒ¨í•˜ì§€ ì•ŠëŠ” í•œ, íŠ¹ë³„íˆ ì‹œë„í•˜ì§€ ì•ŠëŠ” í•œ ì¼ë°˜ì ìœ¼ë¡œ ê·¸ë ‡ì§€ ì•ŠìŠµë‹ˆë‹¤).</target>
        </trans-unit>
        <trans-unit id="a1aeff6040cbaf4a052232c94541c2b536b4a1f3" translate="yes" xml:space="preserve">
          <source>Similarly, removing the entire students array would be done by calling &lt;code&gt;delete Hogwarts.students;&lt;/code&gt; or &lt;code&gt;delete Hogwarts['students'];&lt;/code&gt;.</source>
          <target state="translated">ë§ˆì°¬ê°€ì§€ë¡œ ì „ì²´ í•™ìƒ ë°°ì—´ì„ ì œê±°í•˜ëŠ” ê²ƒì€ &lt;code&gt;delete Hogwarts.students;&lt;/code&gt; ë˜ëŠ” &lt;code&gt;delete Hogwarts['students'];&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd410e78d809f27ec1e3bdad4ee5576324a4212e" translate="yes" xml:space="preserve">
          <source>So as it turns out, there actually IS a built-in way to tell if an array is truly an array, and that is &lt;code&gt;Array.isArray()&lt;/code&gt;, introduced in ECMAScript 5 (December 2009). I found this while looking to see if there was a question asking about telling arrays from objects, to see if there was either a better solution than mine, or to add mine if there were none. So, if you're using a version of JavaScript that is earlier than ECMA 5, there's your polyfill. However, I strongly recommend against using my &lt;code&gt;is_array()&lt;/code&gt; function, as continuing to support old versions of JavaScript means continuing to support the old browsers that implement them, which means encouraging the use of insecure software and putting users at risk for malware. So please, use &lt;code&gt;Array.isArray()&lt;/code&gt;. Use &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. Use the new features that get added to the language. &lt;em&gt;Don't&lt;/em&gt; use vendor prefixes. &lt;em&gt;Delete&lt;/em&gt; that IE polyfill crap from your website. Delete that XHTML &lt;code&gt;&amp;lt;!CDATA[[...&lt;/code&gt; crap, too--we moved to HTML5 back in 2014. The sooner everybody withdraws support for those old/esoteric browsers, the sooner the browser vendors will actually follow the web standard and embrace the new technology, and the sooner we can move on to a more secure web.</source>
          <target state="translated">&lt;code&gt;Array.isArray()&lt;/code&gt; ìœ¼ë¡œ ë°°ì—´ì´ ì‹¤ì œë¡œ ë°°ì—´ì¸ì§€ ECMAScript 5 (2009 ë…„ 12 ì›” ) ì— ë„ì… ëœ Array.isArray () ì¸ì§€ ì•Œ ìˆ˜ìˆëŠ” ê¸°ë³¸ ì œê³µ ë°©ë²•ì´ ìˆìŠµë‹ˆë‹¤. ê°ì²´ì—ì„œ ë°°ì—´ì„ ì•Œë ¤ì£¼ëŠ” ê²ƒì— ëŒ€í•œ ì§ˆë¬¸ì´ ìˆëŠ”ì§€, ë‚´ ê²ƒë³´ë‹¤ ë” ë‚˜ì€ ì†”ë£¨ì…˜ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ê±°ë‚˜ì—†ëŠ” ê²½ìš° ê´‘ì‚°ì„ ì¶”ê°€í•˜ëŠ” ê²ƒì— ëŒ€í•´ ì§ˆë¬¸í•˜ëŠ” ë™ì•ˆ ì´ê²ƒì„ ë°œê²¬í–ˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ECMA 5 ì´ì „ì˜ JavaScript ë²„ì „ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš° í´ë¦¬ í•„ì´ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì´ì „ ë²„ì „ì˜ JavaScriptë¥¼ ê³„ì† ì§€ì›í•œë‹¤ëŠ” ê²ƒì€ JavaScriptë¥¼ êµ¬í˜„í•˜ëŠ” ì´ì „ ë¸Œë¼ìš°ì €ë¥¼ ê³„ì† ì§€ì›í•œë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•˜ë¯€ë¡œ ì•ˆì „í•˜ì§€ ì•Šì€ ì†Œí”„íŠ¸ì›¨ì–´ì˜ ì‚¬ìš©ì„ ì¥ë ¤í•˜ê³  ì‚¬ìš©ìì—ê²Œ ë§¬ì›¨ì–´ ìœ„í—˜ì„ ì´ˆë˜í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ &lt;code&gt;is_array()&lt;/code&gt; í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤. ë”°ë¼ì„œ &lt;code&gt;Array.isArray()&lt;/code&gt; ì‚¬ìš©í•˜ì‹­ì‹œì˜¤. &lt;code&gt;let&lt;/code&gt; ê³¼ &lt;code&gt;const&lt;/code&gt; ë¥¼ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤. ì–¸ì–´ì— ì¶”ê°€ ëœ ìƒˆë¡œìš´ ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤. ê³µê¸‰ ì—…ì²´ ì ‘ë‘ì‚¬ë¥¼ ì‚¬ìš© &lt;em&gt;í•˜ì§€ ë§ˆì‹­ì‹œì˜¤&lt;/em&gt; . ì›¹ ì‚¬ì´íŠ¸ì—ì„œ í•´ë‹¹ IE í´ë¦¬ í•„ í¬ë©ì„ &lt;em&gt;ì‚­ì œ&lt;/em&gt; í•˜ì‹­ì‹œì˜¤. XHTML &lt;code&gt;&amp;lt;!CDATA[[...&lt;/code&gt; crapë„ ë§ˆì°¬ê°€ì§€ì…ë‹ˆë‹¤ .-- 2014 ë…„ì— HTML5ë¡œ ì´ì „í–ˆìŠµë‹ˆë‹¤. ëª¨ë‘ê°€ ì´ì „ / ë¹„ë°€ ë¸Œë¼ìš°ì €ì— ëŒ€í•œ ì§€ì›ì„ ì² íšŒí• ìˆ˜ë¡ ë¸Œë¼ìš°ì € ê³µê¸‰ ì—…ì²´ëŠ” ì‹¤ì œë¡œ ì›¹ í‘œì¤€ì„ ë” ë¹¨ë¦¬ ë”°ë¥´ê³  ë³´ë‹¤ ì•ˆì „í•œ ì›¹ìœ¼ë¡œ ì´ì „ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="c1074a68b7264ece395e8476f70ae784fc36b406" translate="yes" xml:space="preserve">
          <source>So, he sends you an email in anger:</source>
          <target state="translated">ê·¸ë˜ì„œ ê·¸ëŠ” ë¶„ë…¸í•œ ì´ë©”ì¼ì„ ë‹¹ì‹ ì—ê²Œ ë³´ëƒ…ë‹ˆë‹¤ :</target>
        </trans-unit>
        <trans-unit id="1c63c8fdc7a32a45814f6f70f31838cecabdb16b" translate="yes" xml:space="preserve">
          <source>So, when deleting values from an object, always first consider whether you're dealing with object properties or whether you're dealing with array values, and choose the appropriate strategy based on that.</source>
          <target state="translated">ë”°ë¼ì„œ ê°ì²´ì—ì„œ ê°’ì„ ì‚­ì œí•  ë•ŒëŠ” í•­ìƒ ê°ì²´ ì†ì„±ì„ ì²˜ë¦¬í•˜ëŠ”ì§€ ë˜ëŠ” ë°°ì—´ ê°’ì„ ì²˜ë¦¬í•˜ëŠ”ì§€ ì—¬ë¶€ë¥¼ ê³ ë ¤í•˜ê³ ì´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì ì ˆí•œ ì „ëµì„ ì„ íƒí•˜ì‹­ì‹œì˜¤.</target>
        </trans-unit>
        <trans-unit id="da5db28dd16264310f46eacb87a0cb2b9ceef675" translate="yes" xml:space="preserve">
          <source>Sorry if this didn't add to your specific use case but I believe this to be a good design to adapt when managing objects and their properties.</source>
          <target state="translated">ì´ê²ƒì´ íŠ¹ì • ì‚¬ìš© ì‚¬ë¡€ì— ì¶”ê°€ë˜ì§€ ì•Šì€ ê²½ìš° ì£„ì†¡í•˜ì§€ë§Œ ê°ì²´ ë° í•´ë‹¹ ì†ì„±ì„ ê´€ë¦¬ í•  ë•Œì´ ë””ìì¸ì´ ì í•©í•˜ë‹¤ê³  ìƒê°í•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="ace92799b8ad9dc2af653b95d2a4f16910423d4b" translate="yes" xml:space="preserve">
          <source>Suppose you have an object that looks like this:</source>
          <target state="translated">ë‹¤ìŒê³¼ ê°™ì€ ê°ì²´ê°€ ìˆë‹¤ê³  ê°€ì •í•˜ì‹­ì‹œì˜¤.</target>
        </trans-unit>
        <trans-unit id="c5229642bf5961f2b277471727e88e647035ac9e" translate="yes" xml:space="preserve">
          <source>Syntax-based string property omission</source>
          <target state="translated">êµ¬ë¬¸ ê¸°ë°˜ ë¬¸ìì—´ ì†ì„± ìƒëµ</target>
        </trans-unit>
        <trans-unit id="07c468c127104c88b077c6e07b9d9ec7d4fdbf7d" translate="yes" xml:space="preserve">
          <source>THE LONG VERSION</source>
          <target state="translated">ê¸´ ë²„ì „</target>
        </trans-unit>
        <trans-unit id="11405ca028271229b8731c4ce6c20d04dc54cc92" translate="yes" xml:space="preserve">
          <source>THE SHORT VERSION</source>
          <target state="translated">ì§§ì€ ë²„ì „</target>
        </trans-unit>
        <trans-unit id="39fdec1194d94212b871a28b2aa04a73cd40fce1" translate="yes" xml:space="preserve">
          <source>Tests</source>
          <target state="translated">Tests</target>
        </trans-unit>
        <trans-unit id="748beb2ad7204d2997b5d2a12f2e0bc89bcc8e5e" translate="yes" xml:space="preserve">
          <source>That actually isn't what's happening, but it's easier to think of that way. According to MDN, here's what's actually happening:</source>
          <target state="translated">ì‹¤ì œë¡œëŠ” ì¼ì–´ë‚˜ì§€ ì•Šì§€ë§Œ ê·¸ë ‡ê²Œ ìƒê°í•˜ëŠ” ê²ƒì´ ë” ì‰½ìŠµë‹ˆë‹¤. MDNì— ë”°ë¥´ë©´ ì‹¤ì œë¡œ ë‹¤ìŒê³¼ ê°™ì€ ìƒí™©ì´ ë°œìƒí•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="cf85fec62dde51f1637af10a625442c3baea4c48" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;delete operator&lt;/a&gt; is the best way to do so.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;ì‚­ì œ ì—°ì‚°ì&lt;/a&gt; ê°€ ê°€ì¥ ì¢‹ì€ ë°©ë²•ì…ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="881ea24ac20b3a2b7bbbd8208c871ee412db982f" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;key remains on its place in the hashmap&lt;/strong&gt;, only the value is replaced with &lt;code&gt;undefined&lt;/code&gt;. Understand, that &lt;code&gt;for..in&lt;/code&gt; loop will still iterate over that key.</source>
          <target state="translated">&lt;strong&gt;í‚¤ëŠ” í•´ì‹œ ë§µì—ì„œ ê·¸ëŒ€ë¡œ ìœ ì§€ë˜ë©°&lt;/strong&gt; ê°’ë§Œ &lt;code&gt;undefined&lt;/code&gt; ë¡œ ë°”ë€ë‹ˆë‹¤. &lt;code&gt;for..in&lt;/code&gt; ë£¨í”„ëŠ” ì—¬ì „íˆ í•´ë‹¹ í‚¤ë¥¼ ë°˜ë³µí•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="edc38116420d64a21ebfee30ed9c7476267110df" translate="yes" xml:space="preserve">
          <source>The Solution: &lt;code&gt;Array.prototype.splice&lt;/code&gt;</source>
          <target state="translated">í•´ê²°ì±… : &lt;code&gt;Array.prototype.splice&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="071cbdf7a24a78eb243d7c493b80aadba4657908" translate="yes" xml:space="preserve">
          <source>The actual answer to the question</source>
          <target state="translated">ì§ˆë¬¸ì— ëŒ€í•œ ì‹¤ì œ ë‹µë³€</target>
        </trans-unit>
        <trans-unit id="c0ec14910cf4674ceea7f9ad991e964445d6c9ac" translate="yes" xml:space="preserve">
          <source>The answer would be to &lt;strong&gt;delete all the references you have in your code, pointed to that very object&lt;/strong&gt; and also &lt;strong&gt;not use &lt;code&gt;var&lt;/code&gt; statements to create new references to that object&lt;/strong&gt;. This last point regarding &lt;code&gt;var&lt;/code&gt; statements, is one of the most crucial issues that we are usually faced with, because using &lt;code&gt;var&lt;/code&gt; statements would prevent the created object from getting removed.</source>
          <target state="translated">ëŒ€ë‹µì€ &lt;strong&gt;ì½”ë“œì—ì„œ ê°€ì§€ê³ ìˆëŠ” ëª¨ë“  ì°¸ì¡°&lt;/strong&gt; ë¥¼ &lt;strong&gt;ì‚­ì œí•˜ê³  í•´ë‹¹ ê°ì²´ë¥¼ ê°€ë¦¬í‚¤ê³ &lt;/strong&gt; &lt;strong&gt; &lt;code&gt;var&lt;/code&gt; ë¬¸ì„ ì‚¬ìš©í•˜ì—¬ í•´ë‹¹ ê°ì²´ì— ëŒ€í•œ ìƒˆë¡œìš´ ì°¸ì¡°ë¥¼ ì‘ì„±í•˜ì§€ ì•ŠëŠ” ê²ƒ&lt;/strong&gt; ì…ë‹ˆë‹¤. &lt;code&gt;var&lt;/code&gt; ë¬¸ì— ê´€í•œ ë§ˆì§€ë§‰ ìš”ì ì€ var ë¬¸ì„ ì‚¬ìš©í•˜ë©´ ìƒì„± ëœ ê°ì²´ê°€ ì œê±°ë˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ì¼ë°˜ì ìœ¼ë¡œ ì§ë©´í•˜ëŠ” ê°€ì¥ ì¤‘ìš”í•œ ë¬¸ì œ ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="c25007fa1063a6b669074a068e8e0d9c200dbaad" translate="yes" xml:space="preserve">
          <source>The contrived and long-winded PDP-11 scenario</source>
          <target state="translated">ìˆ™ê³ ë˜ê³  ì˜¤ë˜ ì§€ì† ëœ PDP-11 ì‹œë‚˜ë¦¬ì˜¤</target>
        </trans-unit>
        <trans-unit id="f621835acbbff87822c037f614ae8feebd84f7e5" translate="yes" xml:space="preserve">
          <source>The delete operator removes a given property from an object. On
  successful deletion, it will return true, else false will be returned.
  However, it is important to consider the following scenarios:</source>
          <target state="translated">delete ì—°ì‚°ìëŠ” ê°ì²´ì—ì„œ ì§€ì •ëœ ì†ì„±ì„ ì œê±°í•©ë‹ˆë‹¤. ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ë©´ trueë¥¼ ë°˜í™˜í•˜ê³  ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ falseë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ë‹¤ìŒ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ê³ ë ¤í•´ì•¼í•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="88d438bbfeb05c4266f6e27b90dcb851c6f60ce6" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;deleteProperty&lt;/code&gt; is when using strict mode:</source>
          <target state="translated">ì—„ê²© ëª¨ë“œë¥¼ ì‚¬ìš©í•  ë•Œ &lt;code&gt;delete&lt;/code&gt; ì™€ &lt;code&gt;deleteProperty&lt;/code&gt; ì˜ ì°¨ì´ì ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="efccd6cd704a79d07bccddefc3adbae94e968c39" translate="yes" xml:space="preserve">
          <source>The following snippet gives another simple example:</source>
          <target state="translated">ë‹¤ìŒ ìŠ¤ ë‹ˆí«ì€ ë˜ ë‹¤ë¥¸ ê°„ë‹¨í•œ ì˜ˆë¥¼ ì œê³µí•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="bf8a2a946389853c6d0799bf61400c9d604dd48d" translate="yes" xml:space="preserve">
          <source>The index specified by &lt;code&gt;end&lt;/code&gt; is simply excluded from the slice. The parenthesized indices indicate what gets sliced. Either way, the behavior is not intuitive and it's bound to cause its fair share of off-by-one errors, so you might find it useful to make a wrapper function to more closely emulate the behavior of &lt;code&gt;.splice()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;end&lt;/code&gt; ì— ì˜í•´ ì§€ì •ëœ ì¸ë±ìŠ¤ëŠ” ë‹¨ìˆœíˆ ìŠ¬ë¼ì´ìŠ¤ì—ì„œ ì œì™¸ë©ë‹ˆë‹¤. ê´„í˜¸ ì•ˆì˜ ì¸ë±ìŠ¤ëŠ” ì–‡ê²Œ ì¬ ê²ƒì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ì–´ëŠ ìª½ì´ë“ , ë™ì‘ì€ ì§ê´€ì ì´ì§€ ì•Šìœ¼ë©° ì¼ëŒ€ì¼ ì˜¤ë¥˜ë¥¼ ê³µí‰í•˜ê²Œ ë¶„ë°°í•´ì•¼í•˜ë¯€ë¡œ ë˜í¼ í•¨ìˆ˜ë¥¼ â€‹â€‹ì‚¬ìš©í•˜ì—¬ &lt;code&gt;.splice()&lt;/code&gt; ì˜ ë™ì‘ì„ ë” ê°€ê¹ê²Œ ì—ë®¬ë ˆì´íŠ¸í•˜ëŠ” ê²ƒì´ ìœ ìš© í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="367c08658a0eaac4d7f551272d9531077bdd6a38" translate="yes" xml:space="preserve">
          <source>The other important point here is to be careful about your other references to the same object. For instance, if you create a variable like:</source>
          <target state="translated">ì—¬ê¸°ì„œ ë˜ ë‹¤ë¥¸ ì¤‘ìš”í•œ ì ì€ ë™ì¼í•œ ê°ì²´ì— ëŒ€í•œ ë‹¤ë¥¸ ì°¸ì¡°ì—ì£¼ì˜í•´ì•¼í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ë‹¤ìŒê³¼ ê°™ì€ ë³€ìˆ˜ë¥¼ ë§Œë“œëŠ” ê²½ìš°</target>
        </trans-unit>
        <trans-unit id="556ff37bb94e5cbb3dd116d5ddf709d4c4f7ed56" translate="yes" xml:space="preserve">
          <source>The programming ethos/patterns you and your team use. Do you favor functional approaches and mutation is verboten on your team, or do you employ wild west mutative object-oriented techniques?</source>
          <target state="translated">í”„ë¡œê·¸ë˜ë° ì •ì‹  ë° íŒ¨í„´ì€ ë‹¹ì‹ ê³¼ ë‹¹ì‹ ì˜ íŒ€ì´ ì‚¬ìš©í•©ë‹ˆë‹¤. ê¸°ëŠ¥ì  ì ‘ê·¼ ë°©ì‹ì„ ì„ í˜¸í•˜ê³  íŒ€ì—ì„œ ëŒì—°ë³€ì´ê°€ ë°œìƒí•˜ê±°ë‚˜ ì™€ì¼ë“œ ì›¨ìŠ¤íŠ¸ ëŒì—°ë³€ì´ ì²´ ê°ì²´ ì§€í–¥ ê¸°ìˆ ì„ ì‚¬ìš©í•©ë‹ˆê¹Œ?</target>
        </trans-unit>
        <trans-unit id="6357292b24fba94284af6389041f255b8a00f04f" translate="yes" xml:space="preserve">
          <source>The range of object types you want to remove properties on and the type of property names you need to be able to omit (Strings only? Symbols? Weak references mapped from arbitrary objects? These have all been types of property pointers in JavaScript for years now)</source>
          <target state="translated">ì†ì„±ì„ ì œê±°í•˜ë ¤ëŠ” ê°ì²´ ìœ í˜•ì˜ ë²”ìœ„ì™€ ìƒëµ í•  ìˆ˜ìˆëŠ” ì†ì„± ì´ë¦„ ìœ í˜• (ë¬¸ìì—´ ë§Œ? ê¸°í˜¸? ì„ì˜ì˜ ê°ì²´ì—ì„œ ì•½í•œ ì°¸ì¡°ê°€ ë§¤í•‘ ë˜ì—ˆìŠµë‹ˆê¹Œ?) ì´ì œ ëª‡ ë…„ ë™ì•ˆ JavaScriptì—ì„œ ì†ì„± í¬ì¸í„° ìœ í˜•ì´ë˜ì—ˆìŠµë‹ˆë‹¤. )</target>
        </trans-unit>
        <trans-unit id="3fea2fb86e2276224dff32e33243b1e22287ed2d" translate="yes" xml:space="preserve">
          <source>The reason for writing this new &lt;code&gt;unset&lt;/code&gt; function, is to keep the index of all other variables in this hash_map. Look at the following example, and see how the index of &quot;test2&quot; did not change after removing a value from the hash_map.</source>
          <target state="translated">ì´ ìƒˆë¡œìš´ &lt;code&gt;unset&lt;/code&gt; í•¨ìˆ˜ë¥¼ ì‘ì„±í•˜ëŠ” ì´ìœ ëŠ”ì´ hash_mapì— ë‹¤ë¥¸ ëª¨ë“  ë³€ìˆ˜ì˜ ì¸ë±ìŠ¤ë¥¼ ìœ ì§€í•˜ê¸° ìœ„í•´ì„œì…ë‹ˆë‹¤. ë‹¤ìŒ ì˜ˆì œë¥¼ë³´ê³  hash_mapì—ì„œ ê°’ì„ ì œê±°í•œ í›„ &quot;test2&quot;ì˜ ìƒ‰ì¸ì´ ì–´ë–»ê²Œ ë³€ê²½ë˜ì§€ ì•Šì•˜ëŠ”ì§€ë³´ì‹­ì‹œì˜¤.</target>
        </trans-unit>
        <trans-unit id="e16825f749b4e5fb7d1fecf43d4e6b653061e2e8" translate="yes" xml:space="preserve">
          <source>The result would be &lt;code&gt;false&lt;/code&gt;, which means that your delete statement haven't been executed as you expected. But if you had not created that variable before, and you only had &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; as your last existing reference, you could have done this just by removing it like:</source>
          <target state="translated">ê²°ê³¼ëŠ” &lt;code&gt;false&lt;/code&gt; ì´ë©°, ì˜ˆìƒëŒ€ë¡œ delete ë¬¸ì´ ì‹¤í–‰ë˜ì§€ ì•Šì•˜ ìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì´ì „ì— í•´ë‹¹ ë³€ìˆ˜ë¥¼ ì‘ì„±í•˜ì§€ ì•Šì•˜ê³  ë§ˆì§€ë§‰ ê¸°ì¡´ ì°¸ì¡°ë¡œ &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; ë§ŒìˆëŠ” ê²½ìš° ë‹¤ìŒê³¼ ê°™ì´ ì œê±°í•˜ë©´ë©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="f6481accf44872d4ef8745c055193c2829ccd3cb" translate="yes" xml:space="preserve">
          <source>The term you have used in your question title &lt;code&gt;Remove a property from a JavaScript object&lt;/code&gt;, can be interpreted in some different ways. The one is to remove it for whole the memory and the list of object keys or the other is just to remove it from your object. As it has been mentioned in some other answers, the &lt;code&gt;delete&lt;/code&gt; keyword is the main part. Let's say you have your object like:</source>
          <target state="translated">ì§ˆë¬¸ ì œëª©ì— ì‚¬ìš©í•œ ìš©ì–´ &lt;code&gt;Remove a property from a JavaScript object&lt;/code&gt; ëª‡ ê°€ì§€ ë‹¤ë¥¸ ë°©ì‹ìœ¼ë¡œ í•´ì„ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ë‚˜ëŠ” ë©”ëª¨ë¦¬ ì „ì²´ë¥¼ ì œê±°í•˜ê³  ê°ì²´ í‚¤ ëª©ë¡ì„ ì œê±°í•˜ê±°ë‚˜ ë‹¤ë¥¸ ê²ƒì€ ê°ì²´ì—ì„œ ì œê±°í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ë‹¤ë¥¸ ë‹µë³€ì—ì„œ ì–¸ê¸‰í–ˆë“¯ì´ &lt;code&gt;delete&lt;/code&gt; í‚¤ì›Œë“œê°€ ì£¼ìš” ë¶€ë¶„ì…ë‹ˆë‹¤. ë‹¤ìŒê³¼ ê°™ì€ ê°ì²´ê°€ ìˆë‹¤ê³  ê°€ì • í•´ ë´…ì‹œë‹¤.</target>
        </trans-unit>
        <trans-unit id="d7c42d645c208dfd4e3c38a50db94ab5a07bdf03" translate="yes" xml:space="preserve">
          <source>The version of ECMAScript you're targeting</source>
          <target state="translated">ëŒ€ìƒìœ¼ë¡œí•˜ëŠ” ECMAScriptì˜ ë²„ì „</target>
        </trans-unit>
        <trans-unit id="2d17e745883099706ab5b904d19b87cebce1764f" translate="yes" xml:space="preserve">
          <source>Then even if you remove it from your object &lt;code&gt;myJSONObject&lt;/code&gt;, that specific object won't get deleted from the memory, since the &lt;code&gt;regex&lt;/code&gt; variable and &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; still have their values. Then how could we remove the object from the memory for sure?</source>
          <target state="translated">ê·¸ëŸ° ë‹¤ìŒ ê°ì²´ &lt;code&gt;myJSONObject&lt;/code&gt; ì—ì„œ ê°ì²´ë¥¼ ì œê±°í•˜ë”ë¼ë„ &lt;code&gt;regex&lt;/code&gt; ë³€ìˆ˜ ë° &lt;code&gt;myOtherObject[&quot;regex&quot;]&lt;/code&gt; ì— ì—¬ì „íˆ ê°’ì´ ìˆìœ¼ë¯€ë¡œ í•´ë‹¹ ê°ì²´ëŠ” ë©”ëª¨ë¦¬ì—ì„œ ì‚­ì œë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ê·¸ë ‡ë‹¤ë©´ ì–´ë–»ê²Œ ë©”ëª¨ë¦¬ì—ì„œ ê°ì²´ë¥¼ ì œê±° í•  ìˆ˜ ìˆì„ê¹Œìš”?</target>
        </trans-unit>
        <trans-unit id="9f315ff9ba259ec4af4aad477da9caf99c783595" translate="yes" xml:space="preserve">
          <source>Then your objects key using &lt;code&gt;Object.keys(myJSONObject)&lt;/code&gt; would be:</source>
          <target state="translated">ê·¸ëŸ° ë‹¤ìŒ &lt;code&gt;Object.keys(myJSONObject)&lt;/code&gt; ì‚¬ìš©í•˜ëŠ” ê°ì²´ í‚¤ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="950ba1d1f6aad6e3258d15bc7f08a5e034f6a816" translate="yes" xml:space="preserve">
          <source>There are a lot of good answers here but I just want to chime in that when using delete to remove a property in JavaScript, it is often wise to first check if that property exists to prevent errors.</source>
          <target state="translated">ì—¬ê¸°ì—ëŠ” ì¢‹ì€ ëŒ€ë‹µì´ ë§ì´ ìˆì§€ë§Œ deleteë¥¼ ì‚¬ìš©í•˜ì—¬ JavaScriptì—ì„œ ì†ì„±ì„ ì œê±° í•  ë•Œ ì˜¤ë¥˜ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ í•´ë‹¹ ì†ì„±ì´ ìˆëŠ”ì§€ ë¨¼ì € í™•ì¸í•˜ëŠ” ê²ƒì´ í˜„ëª…í•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="57100a7adc73f2ac8fb1259dcb31d2cae8056822" translate="yes" xml:space="preserve">
          <source>There are few common ways to remove a property from an object.</source>
          <target state="translated">ê°ì²´ì—ì„œ ì†ì„±ì„ ì œê±°í•˜ëŠ” ì¼ë°˜ì ì¸ ë°©ë²•ì€ ê±°ì˜ ì—†ìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="8604def9bd3e30573031d5be629fb2bb0c18ca39" translate="yes" xml:space="preserve">
          <source>There are many different options presented on this page, not because most of the options are wrong&amp;mdash;or because the answers are duplicates&amp;mdash;but because the appropriate technique depends on the situation you're in and the goals of the tasks you and/or you team are trying to fulfill. To answer you question unequivocally, one needs to know:</source>
          <target state="translated">ì´ í˜ì´ì§€ì—ëŠ” ì—¬ëŸ¬ ê°€ì§€ ì˜µì…˜ì´ ìˆìŠµë‹ˆë‹¤. ëŒ€ë¶€ë¶„ì˜ ì˜µì…˜ì´ ì˜ëª»ë˜ì—ˆê±°ë‚˜ ë‹µë³€ì´ ì¤‘ë³µ ë˜ì—ˆê¸° ë•Œë¬¸ì´ ì•„ë‹ˆë¼ ì ì ˆí•œ ê¸°ìˆ ì´ í˜„ì¬ ìƒí™©ê³¼ ê·€í•˜ ë° / ë˜ëŠ” ê·€í•˜ì˜ ì‘ì—… ëª©í‘œì— ë”°ë¼ ë‹¬ë¼ì§€ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. íŒ€ì€ ì„±ì·¨í•˜ë ¤ê³ í•©ë‹ˆë‹¤. í™•ì‹¤í•˜ê²Œ ì§ˆë¬¸ì— ëŒ€ë‹µí•˜ë ¤ë©´ ë‹¤ìŒì„ ì•Œì•„ì•¼í•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="5f1efa2f9fb405d638f74fe5349dbabb89e0514a" translate="yes" xml:space="preserve">
          <source>They are slow &amp;amp; memory inefficient. When accessing a specific index, instead of just getting the global type for the array, the browser instead has to get the type on a per-index basis whereby each index stores the additional metadata of its type.</source>
          <target state="translated">ê·¸ë“¤ì€ ëŠë¦¬ê³  ë©”ëª¨ë¦¬ ë¹„íš¨ìœ¨ì ì…ë‹ˆë‹¤. íŠ¹ì • ì¸ë±ìŠ¤ì— ì•¡ì„¸ìŠ¤ í•  ë•Œ ë°°ì—´ì˜ ì „ì—­ ìœ í˜•ì„ ê°€ì ¸ ì˜¤ëŠ” ëŒ€ì‹  ë¸Œë¼ìš°ì €ëŠ” ì¸ë±ìŠ¤ë³„ë¡œ ìœ í˜•ì„ ê°€ì ¸ì™€ ê° ì¸ë±ìŠ¤ê°€ í•´ë‹¹ ìœ í˜•ì˜ ì¶”ê°€ ë©”íƒ€ ë°ì´í„°ë¥¼ ì €ì¥í•´ì•¼í•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="afa3b2f30890db447e4cf00d9f2dcec7b332b01b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;ES6&lt;/code&gt; operator allows us to return a brand new object, excluding any properties, without mutating the existing object. The downside is that it has the worse performance out of the above and not suggested to be used when you need to remove many properties at a time.</source>
          <target state="translated">ì´ &lt;code&gt;ES6&lt;/code&gt; ì—°ì‚°ìë¥¼ ì‚¬ìš©í•˜ë©´ ê¸°ì¡´ ê°ì²´ë¥¼ ë³€ê²½í•˜ì§€ ì•Šê³  ì†ì„±ì„ ì œì™¸í•œ ì™„ì „íˆ ìƒˆë¡œìš´ ê°ì²´ë¥¼ ë°˜í™˜ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¨ì ì€ ìœ„ì˜ ì„±ëŠ¥ì´ ì €í•˜ë˜ì–´ í•œ ë²ˆì— ë§ì€ ì†ì„±ì„ ì œê±°í•´ì•¼ í•  ë•Œ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ê²ƒì…ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="9e7248bc6c7cf17aeb43a8906d8cc8e3b531512b" translate="yes" xml:space="preserve">
          <source>This alternative is not the correct answer to this question! But, if you use it with care, you can dramatically speed up some algorithms. If you are using &lt;code&gt;delete&lt;/code&gt; in loops and you have problems with performance, read the verbose explanation.</source>
          <target state="translated">ì´ ëŒ€ì•ˆì€ì´ ì§ˆë¬¸ì— ëŒ€í•œ ì •ë‹µì´ ì•„ë‹™ë‹ˆë‹¤! ê·¸ëŸ¬ë‚˜ì£¼ì˜í•´ì„œ ì‚¬ìš©í•˜ë©´ ì¼ë¶€ ì•Œê³ ë¦¬ì¦˜ì˜ ì†ë„ë¥¼ í¬ê²Œ ë†’ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë£¨í”„ì—ì„œ &lt;code&gt;delete&lt;/code&gt; ë¥¼ ì‚¬ìš©í•˜ê³  ì„±ëŠ¥ì— ë¬¸ì œê°€ìˆëŠ” ê²½ìš° ìì„¸í•œ ì„¤ëª…ì„ ì½ìœ¼ì‹­ì‹œì˜¤.</target>
        </trans-unit>
        <trans-unit id="d2696a11c056f55fc8c70ea4ff94e4f5922248e1" translate="yes" xml:space="preserve">
          <source>This category is for operating on object literals or object instances when you want to retain/continue to use the original reference and aren't using stateless functional principles in your code. An example piece of syntax in this category:</source>
          <target state="translated">ì´ ë²”ì£¼ëŠ” ì›ë˜ ì°¸ì¡°ë¥¼ ìœ ì§€ / ê³„ì† ì‚¬ìš©í•˜ë ¤ê³ í•˜ê³  ì½”ë“œì—ì„œ ìƒíƒœ ë¹„ ì €ì¥ ê¸°ëŠ¥ ì›ë¦¬ë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ê²½ìš° ê°ì²´ ë¦¬í„°ëŸ´ ë˜ëŠ” ê°ì²´ ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ì‘ë™í•©ë‹ˆë‹¤. ì´ ì¹´í…Œê³ ë¦¬ì˜ êµ¬ë¬¸ ì˜ˆì œ :</target>
        </trans-unit>
        <trans-unit id="1f8c0c20dd501470cb117b73c855e583ae2e0193" translate="yes" xml:space="preserve">
          <source>This category is for operating on object literals or object instances when you want to retain/continue to use the original reference while guarding against exceptions being thrown on unconfigurable properties:</source>
          <target state="translated">ì´ ë²”ì£¼ëŠ” êµ¬ì„± í•  ìˆ˜ì—†ëŠ” ì†ì„±ì—ì„œ ë°œìƒí•˜ëŠ” ì˜ˆì™¸ë¥¼ ë°©ì§€í•˜ë©´ì„œ ì›ë˜ ì°¸ì¡°ë¥¼ ìœ ì§€ / ê³„ì† ì‚¬ìš©í•˜ë ¤ëŠ” ê²½ìš° ê°ì²´ ë¦¬í„°ëŸ´ ë˜ëŠ” ê°ì²´ ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ì‘ë™í•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="94bdb987c00caa2e598854f97ea3c6de4e30eedf" translate="yes" xml:space="preserve">
          <source>This category is for operating on plain object or array instances in newer ECMAScript flavors when a non-mutative approach is desired and you don't need to account for Symbol keys:</source>
          <target state="translated">ì´ ë²”ì£¼ëŠ” ë¹„ë³€ ì´ì  ì ‘ê·¼ ë°©ì‹ì´ í•„ìš”í•˜ê³  ê¸°í˜¸ í‚¤ë¥¼ ê³ ë ¤í•  í•„ìš”ê°€ì—†ëŠ” ê²½ìš° ìµœì‹  ECMAScript ë²„ì „ì˜ ì¼ë°˜ ê°ì²´ ë˜ëŠ” ë°°ì—´ ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ì‘ë™í•˜ê¸°ìœ„í•œ ê²ƒì…ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="aba34382b27aca74b69be04c741119ab744a49b9" translate="yes" xml:space="preserve">
          <source>This category is generally allows for greater functional flexibility, including accounting for Symbols &amp;amp; omitting more than one property in one statement:</source>
          <target state="translated">ì´ ë²”ì£¼ëŠ” ì¼ë°˜ì ìœ¼ë¡œ ê¸°í˜¸ ì„¤ëª… ë° í•˜ë‚˜ì˜ ëª…ë ¹ë¬¸ì—ì„œ ë‘˜ ì´ìƒì˜ íŠ¹ì„± ìƒëµì„ í¬í•¨í•˜ì—¬ ë” í° ê¸°ëŠ¥ì  ìœ ì—°ì„±ì„ í—ˆìš©í•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="17ff7f9c0c298023ffef1288d23c2efc74ebdf5c" translate="yes" xml:space="preserve">
          <source>This category is the oldest, most straightforward &amp;amp; most widely supported category of property removal. It supports &lt;code&gt;Symbol&lt;/code&gt; &amp;amp; array indexes in addition to strings and works in every version of JavaScript except for the very first release. However, it's mutative which violates some programming principles and has performance implications. It also can result in uncaught exceptions when used on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;non-configurable properties in strict mode&lt;/a&gt;.</source>
          <target state="translated">ì´ ì¹´í…Œê³ ë¦¬ëŠ” ê°€ì¥ ì˜¤ë˜ë˜ê³  ê°€ì¥ ê°„ë‹¨í•˜ë©° ê°€ì¥ ê´‘ë²”ìœ„í•˜ê²Œ ì§€ì›ë˜ëŠ” ë¶€ë™ì‚° ì œê±° ì¹´í…Œê³ ë¦¬ì…ë‹ˆë‹¤. ë¬¸ìì—´ë¿ë§Œ ì•„ë‹ˆë¼ &lt;code&gt;Symbol&lt;/code&gt; ë° ë°°ì—´ ì¸ë±ìŠ¤ë¥¼ ì§€ì›í•˜ë©° ì²« ë²ˆì§¸ ë¦´ë¦¬ìŠ¤ë¥¼ ì œì™¸í•œ ëª¨ë“  ë²„ì „ì˜ JavaScriptì—ì„œ ì‘ë™í•©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì¼ë¶€ í”„ë¡œê·¸ë˜ë° ì›ì¹™ì„ ìœ„ë°˜í•˜ê³  ì„±ëŠ¥ì— ì˜í–¥ì„ ë¯¸ì¹˜ëŠ” ê²ƒì€ ëŒì—°ë³€ì´ì…ë‹ˆë‹¤. ë˜í•œ &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;ì—„ê²© ëª¨ë“œì—ì„œ êµ¬ì„± í•  ìˆ˜ì—†ëŠ” íŠ¹ì„±ì—&lt;/a&gt; ì‚¬ìš©ë  ë•Œ ì˜ˆì™¸ê°€ ë°œìƒí•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="4ad77472ac7767c23050851eada92d065c2bd943" translate="yes" xml:space="preserve">
          <source>This is in regard to this (now-removed) snippet:</source>
          <target state="translated">ì´ê²ƒì€ (ì´ì œ ì œê±° ëœ) ìŠ¤ ë‹ˆí«ê³¼ ê´€ë ¨ì´ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="21292c660408d1ff92d4a1c2c4eafdd76c276e51" translate="yes" xml:space="preserve">
          <source>This post is very old and I find it very helpful so I decided to share the unset function I wrote in case someone else see this post and think why it's not so simple as it in PHP unset function.</source>
          <target state="translated">ì´ ê²Œì‹œë¬¼ì€ ë§¤ìš° ì˜¤ë˜ë˜ì–´ ë§¤ìš° ìœ ìš©í•˜ë¯€ë¡œ ë‹¤ë¥¸ ì‚¬ëŒ ì´ì´ ê²Œì‹œë¬¼ì„ë³´ê³  PHP unset í•¨ìˆ˜ì—ì„œ ê·¸ë ‡ê²Œ ê°„ë‹¨í•˜ì§€ ì•Šì€ ì´ìœ ë¥¼ ìƒê°í•œ ê²½ìš° ì‘ì„±í•œ unset í•¨ìˆ˜ë¥¼ ê³µìœ í•˜ê¸°ë¡œ ê²°ì •í–ˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="9603916ceb02f62ecad35613c65fb5ceed83b60d" translate="yes" xml:space="preserve">
          <source>This works in Firefox and Internet&amp;nbsp;Explorer, and I think it works in all others.</source>
          <target state="translated">ì´ê²ƒì€ Firefox ë° Internet Explorerì—ì„œ ì‘ë™í•˜ë©° ë‹¤ë¥¸ ëª¨ë“ ì—ì„œë„ ì‘ë™í•œë‹¤ê³  ìƒê°í•©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="c685cc94e2b05416a2b9215116753bb12c7af729" translate="yes" xml:space="preserve">
          <source>To complete @Koen answer in this thread, in case you want to remove dynamic variable using the spread syntax, you can do it like so:</source>
          <target state="translated">ì´ ìŠ¤ë ˆë“œì—ì„œ @Koen ë‹µë³€ì„ ì™„ë£Œí•˜ë ¤ë©´ ìŠ¤í”„ë ˆë“œ êµ¬ë¬¸ì„ ì‚¬ìš©í•˜ì—¬ ë™ì  ë³€ìˆ˜ë¥¼ ì œê±°í•˜ë ¤ë©´ ë‹¤ìŒê³¼ ê°™ì´í•˜ì‹­ì‹œì˜¤.</target>
        </trans-unit>
        <trans-unit id="a792292997434d58f8b1d7da4af78863ac5e4684" translate="yes" xml:space="preserve">
          <source>To get more info on &lt;code&gt;Object.seal&lt;/code&gt;: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal&quot;&gt;Object.seal()&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;Object.seal&lt;/code&gt; ì— ëŒ€í•œ ìì„¸í•œ ì •ë³´ë¥¼ ì–»ìœ¼ë ¤ë©´ : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal&quot;&gt;Object.seal ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96589c0ac9acf3a6b58f6928336639e582088ee3" translate="yes" xml:space="preserve">
          <source>To reassign to the same variable, use a &lt;code&gt;let&lt;/code&gt;:</source>
          <target state="translated">ë™ì¼í•œ ë³€ìˆ˜ì— ë‹¤ì‹œ í• ë‹¹í•˜ë ¤ë©´ &lt;code&gt;let&lt;/code&gt; ì„ ì‚¬ìš© í•˜ì‹­ì‹œì˜¤ .</target>
        </trans-unit>
        <trans-unit id="21af806df3feb60911002a77c4380b2b484f7bbf" translate="yes" xml:space="preserve">
          <source>To remove any property, say &lt;code&gt;key1&lt;/code&gt;, use the &lt;code&gt;delete&lt;/code&gt; keyword like this:</source>
          <target state="translated">&lt;code&gt;key1&lt;/code&gt; ê³¼ ê°™ì€ ì†ì„±ì„ ì œê±°í•˜ë ¤ë©´ ë‹¤ìŒê³¼ ê°™ì´ &lt;code&gt;delete&lt;/code&gt; í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤.</target>
        </trans-unit>
        <trans-unit id="fa15c129befde7656ac754122a25210685ef2188" translate="yes" xml:space="preserve">
          <source>To summarize, differences are all about ways of determining the property existence, and about &lt;code&gt;for..in&lt;/code&gt; loop.</source>
          <target state="translated">ìš”ì•½í•˜ë©´, ì°¨ì´ì ì€ ì†ì„± ì¡´ì¬ë¥¼ ê²°ì •í•˜ëŠ” ë°©ë²•ê³¼ &lt;code&gt;for..in&lt;/code&gt; ë£¨í”„ì— ê´€í•œ ê²ƒì…ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="87501fb0e92ec552bdf306c07f48852286e9c8c8" translate="yes" xml:space="preserve">
          <source>To whoever needs it...</source>
          <target state="translated">ê·¸ê²ƒì„ í•„ìš”ë¡œí•˜ëŠ” ì‚¬ëŒì—ê²ŒëŠ” ...</target>
        </trans-unit>
        <trans-unit id="b7ff74710b25d787ff3d518b1667a655a5936c78" translate="yes" xml:space="preserve">
          <source>Try the following method. Assign the &lt;code&gt;Object&lt;/code&gt; property value to &lt;code&gt;undefined&lt;/code&gt;. Then &lt;code&gt;stringify&lt;/code&gt; the object and &lt;code&gt;parse&lt;/code&gt;.</source>
          <target state="translated">ë‹¤ìŒ ë°©ë²•ì„ ì‹œë„í•˜ì‹­ì‹œì˜¤. &lt;code&gt;Object&lt;/code&gt; ì†ì„± ê°’ì„ &lt;code&gt;undefined&lt;/code&gt; ì— í• ë‹¹í•˜ì‹­ì‹œì˜¤. ê·¸ëŸ° ë‹¤ìŒ ê°ì²´ë¥¼ &lt;code&gt;stringify&lt;/code&gt; í•˜ê³  &lt;code&gt;parse&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d82a9f15156c36519fc72f9af221c32d7422e29" translate="yes" xml:space="preserve">
          <source>Try this</source>
          <target state="translated">ì´ ì‹œë„</target>
        </trans-unit>
        <trans-unit id="828f97e6c91f157ecd45fc8183a07ca7b4e95e6f" translate="yes" xml:space="preserve">
          <source>Update regarding &lt;code&gt;is_array()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;is_array()&lt;/code&gt; ê´€ë ¨ ì—…ë°ì´íŠ¸</target>
        </trans-unit>
        <trans-unit id="d45aa1f9d8100f951a216d7ce715ec8d99477eb3" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://ramdajs.com/docs/#dissoc&quot;&gt;ramda#dissoc&lt;/a&gt; you will get a new object without the attribute &lt;code&gt;regex&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://ramdajs.com/docs/#dissoc&quot;&gt;ramda # dissoc&lt;/a&gt; ì„ ì‚¬ìš©í•˜ë©´ ì†ì„± &lt;code&gt;regex&lt;/code&gt; ì—†ì´ ìƒˆë¡œìš´ ê°ì²´ë¥¼ ì–»ê²Œë©ë‹ˆë‹¤ :</target>
        </trans-unit>
        <trans-unit id="930151a2e26bf074e4b81d244de5799b750be707" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;delete&lt;/strong&gt; method is the best way to do that, as per MDN description, the delete operator removes a property from an object. So you can simply write:</source>
          <target state="translated">MDN ì„¤ëª…ì— ë”°ë¼ delete ì—°ì‚°ìë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ê°€ì¥ ì¢‹ì€ ë°©ë²•ì…ë‹ˆë‹¤. delete ì—°ì‚°ìëŠ” ê°ì²´ì—ì„œ ì†ì„±ì„ ì œê±°í•©ë‹ˆë‹¤. ë”°ë¼ì„œ ê°„ë‹¨í•˜ê²Œ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="855d634ee489e4e0a2c811671f665628a0a0df6f" translate="yes" xml:space="preserve">
          <source>Using ES6:</source>
          <target state="translated">ES6 ì‚¬ìš© :</target>
        </trans-unit>
        <trans-unit id="9fb406e463a70799e2a3db3cb0956dde6058516c" translate="yes" xml:space="preserve">
          <source>Using this method, not all &lt;a href=&quot;https://stackoverflow.com/questions/1894792/determining-if-a-javascript-object-has-a-given-property&quot;&gt;ways of determining property existence&lt;/a&gt; will work as expected.</source>
          <target state="translated">ì´ ë°©ë²•ì„ ì‚¬ìš©í•˜ë©´ &lt;a href=&quot;https://stackoverflow.com/questions/1894792/determining-if-a-javascript-object-has-a-given-property&quot;&gt;ì†ì„± ì¡´ì¬ë¥¼ ê²°ì •í•˜ëŠ”&lt;/a&gt; ëª¨ë“  ë°©ë²•ì´ ì˜ˆìƒëŒ€ë¡œ ì‘ë™í•˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="7d56ccd01dc2c25715aa91cc5c3b3239162d1db4" translate="yes" xml:space="preserve">
          <source>What follows is a contrived scenario that gets pretty long-winded, so you can skip to the section, &lt;strong&gt;The Solution&lt;/strong&gt;, if you want. The only reason I leave this section it is that I think some people probably think it's funny, and I don't want to be &quot;that guy&quot; who posts a &quot;funny&quot; answer and then deletes all the &quot;funny&quot; from it later on.</source>
          <target state="translated">ë‹¤ìŒì€ ê½¤ ì˜¤ë˜ ê±¸ë¦¬ëŠ” ì‹œë‚˜ë¦¬ì˜¤ì´ë¯€ë¡œ, ì›í•˜ëŠ” ê²½ìš° &lt;strong&gt;ì†”ë£¨ì…˜&lt;/strong&gt; ì„¹ì…˜ìœ¼ë¡œ ê±´ë„ˆ ë›¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‚´ê°€ì´ ì„¹ì…˜ì„ ë– ë‚˜ëŠ” ìœ ì¼í•œ ì´ìœ ëŠ” ì•„ë§ˆ ì–´ë–¤ ì‚¬ëŒë“¤ì€ ê·¸ê²ƒì´ ì¬ë¯¸ ìˆë‹¤ê³  ìƒê°í•˜ê³  &quot;ì¬ë¯¸ìˆëŠ”&quot;ë‹µë³€ì„ ê²Œì‹œ í•œ í›„ &quot;ì¬ë¯¸ìˆëŠ”&quot;ëª¨ë“  ì‚¬ëŒì„ ì‚­ì œí•˜ëŠ” &quot;ê·¸ ì‚¬ëŒ&quot;ì´ë˜ê³  ì‹¶ì§€ ì•Šê¸° ë•Œë¬¸ì…ë‹ˆë‹¤ .</target>
        </trans-unit>
        <trans-unit id="e8a0f3d5fef79ddff6c740f20faf1841e9c8a913" translate="yes" xml:space="preserve">
          <source>What is the best way to remove the property &lt;code&gt;regex&lt;/code&gt; to end up with new &lt;code&gt;myObject&lt;/code&gt; as follows?</source>
          <target state="translated">ë‹¤ìŒê³¼ ê°™ì´ ìƒˆ &lt;code&gt;myObject&lt;/code&gt; ë¡œ ëë‚˜ê¸° ìœ„í•´ &lt;code&gt;regex&lt;/code&gt; ì†ì„±ì„ ì œê±°í•˜ëŠ” ê°€ì¥ ì¢‹ì€ ë°©ë²•ì€ ë¬´ì—‡ì…ë‹ˆê¹Œ?</target>
        </trans-unit>
        <trans-unit id="269ad8f4ba0c959d755966ae84263f7c06ef0a98" translate="yes" xml:space="preserve">
          <source>When should one use &lt;code&gt;delete&lt;/code&gt; and when set value to &lt;code&gt;undefined&lt;/code&gt; ?</source>
          <target state="translated">ì–¸ì œ &lt;code&gt;delete&lt;/code&gt; ë¥¼ ì‚¬ìš©í•´ì•¼í•˜ê³  valueë¥¼ &lt;code&gt;undefined&lt;/code&gt; ë¡œ ì„¤ì •í•´ì•¼í•©ë‹ˆê¹Œ?</target>
        </trans-unit>
        <trans-unit id="f73054e5169db0bc5c2ed5932270c4a709d901aa" translate="yes" xml:space="preserve">
          <source>When using a Symbol, wait, why are you using a Symbol?!?! Symbols are bad  juju for performance. Everything programmed to use Symbols can be reprogrammed to not use Symbols, resulting in a faster code without Symbols. Symbols are really just super inefficient meta-sugar.</source>
          <target state="translated">Symbolì„ ì‚¬ìš©í•  ë•Œ ê¸°ë‹¤ë¦¬ì‹­ì‹œì˜¤. ì™œ Symbolì„ ì‚¬ìš©í•˜ê³  ìˆìŠµë‹ˆê¹Œ?!?! ê¸°í˜¸ëŠ” ì„±ëŠ¥ë©´ì—ì„œ ì¢‹ì§€ ì•ŠìŠµë‹ˆë‹¤. Symbolì„ ì‚¬ìš©í•˜ë„ë¡ í”„ë¡œê·¸ë˜ë° ëœ ëª¨ë“  ê²ƒì„ Symbolì„ ì‚¬ìš©í•˜ì§€ ì•Šë„ë¡ ì¬ í”„ë¡œê·¸ë˜ë° í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ Symbolì´ì—†ëŠ” ë” ë¹ ë¥¸ ì½”ë“œê°€ ìƒì„±ë©ë‹ˆë‹¤. ê¸°í˜¸ëŠ” ì‹¤ì œë¡œ ë§¤ìš° ë¹„íš¨ìœ¨ì  ì¸ ë©”íƒ€ ì„¤íƒ•ì…ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="602ae3083b5ceb94cfa5bb3b6f0e1f19f1f16418" translate="yes" xml:space="preserve">
          <source>When using an array/variable typed to the boolean primitive, use either &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; as the empty value. While avoiding unnecessary polymorphism is good, rewriting all your code to explicitly forbid it will likely actually result in a decrease in performance. Use common judgement!</source>
          <target state="translated">ë¶€ìš¸ í”„ë¦¬ë¯¸í‹°ë¸Œì— ìœ í˜•ì´ ì§€ì •ëœ ë°°ì—´ / ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš° ë¹ˆ ê°’ìœ¼ë¡œ &lt;code&gt;false&lt;/code&gt; ë˜ëŠ” &lt;code&gt;undefined&lt;/code&gt; ë¥¼ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤. ë¶ˆí•„ìš”í•œ ë‹¤í˜•ì„±ì„ í”¼í•˜ëŠ” ê²ƒì´ ì¢‹ì§€ë§Œ ëª…ì‹œ ì ìœ¼ë¡œ ê¸ˆì§€í•˜ë„ë¡ ëª¨ë“  ì½”ë“œë¥¼ ë‹¤ì‹œ ì‘ì„±í•˜ë©´ ì‹¤ì œë¡œ ì„±ëŠ¥ì´ ì €í•˜ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¼ë°˜ì ì¸ íŒë‹¨ì„ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤!</target>
        </trans-unit>
        <trans-unit id="97e2c329b633d1758a70203709d67ea5a41bbc86" translate="yes" xml:space="preserve">
          <source>When using an array/variable typed to the number primitive, use &lt;code&gt;0&lt;/code&gt; as the empty value. Note that internally, there are two types of numbers: fast integers (2147483647 to -2147483648 inclusive) and slow floating point doubles (anything other than that including &lt;code&gt;NaN&lt;/code&gt; and &lt;code&gt;Infinity&lt;/code&gt;). When an integer is demoted to a double, it cannot be promoted back to an integer.</source>
          <target state="translated">ìˆ«ì í”„ë¦¬ë¯¸í‹°ë¸Œë¡œ ìœ í˜•ì´ ì§€ì •ëœ ë°°ì—´ / ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš° &lt;code&gt;0&lt;/code&gt; ì„ ë¹ˆ ê°’ìœ¼ë¡œ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤. ë‚´ë¶€ì—ëŠ” ë¹ ë¥¸ ì •ìˆ˜ (2147483647 ~ -2147483648 í¬í•¨)ì™€ ëŠë¦° ë¶€ë™ ì†Œìˆ˜ì  ë‘ ë°° ( &lt;code&gt;NaN&lt;/code&gt; ë° &lt;code&gt;Infinity&lt;/code&gt; í¬í•¨ ì´ì™¸ì˜ ìˆ«ì)ë¼ëŠ” ë‘ ê°€ì§€ ìœ í˜•ì˜ ìˆ«ìê°€ ìˆìŠµë‹ˆë‹¤. ì •ìˆ˜ê°€ ë‘ ë°°ë¡œ ê°•ë“±ë˜ë©´ ì •ìˆ˜ë¡œ ë‹¤ì‹œ ìŠ¹ê²© ë  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="363e06ebcbb46e5d020be755b34062c111648564" translate="yes" xml:space="preserve">
          <source>When using an array/variable typed to the string primitive, use &lt;code&gt;&quot;&quot;&lt;/code&gt; as the empty value.</source>
          <target state="translated">ë¬¸ìì—´ ê¸°ë³¸ í˜•ì‹ìœ¼ë¡œ ì…ë ¥ ëœ ë°°ì—´ / ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš° &lt;code&gt;&quot;&quot;&lt;/code&gt; ë¥¼ ë¹ˆ ê°’ìœ¼ë¡œ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤.</target>
        </trans-unit>
        <trans-unit id="2daf2d7377c143fd1982ce05f553ab2ba4bd19a7" translate="yes" xml:space="preserve">
          <source>When using anything else, use &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">ë‹¤ë¥¸ ê²ƒì„ ì‚¬ìš©í•  ë•ŒëŠ” &lt;code&gt;null&lt;/code&gt; ì„ ì‚¬ìš©í•˜ì‹­ì‹œì˜¤.</target>
        </trans-unit>
        <trans-unit id="99129be375514e4d040c762996086e2002e66f2e" translate="yes" xml:space="preserve">
          <source>Which is a terrible justification for getting rid of the &lt;code&gt;null&lt;/code&gt;s--&lt;code&gt;null&lt;/code&gt; is only dangerous if used improperly, and it has nothing to do with &quot;precision&quot;. The real reason you shouldn't &lt;code&gt;delete&lt;/code&gt; from an array is that leaving garbage-filled and messy data structures around is sloppy and bug-prone.</source>
          <target state="translated">ì´ê²ƒì€ &lt;code&gt;null&lt;/code&gt; ì„ ì œê±°í•˜ëŠ” ë°ìˆì–´ ë”ì°í•œ ì •ë‹¹í™”ì…ë‹ˆë‹¤. &lt;code&gt;null&lt;/code&gt; ì€ ë¶€ì ì ˆí•˜ê²Œ ì‚¬ìš©ë  ê²½ìš°ì—ë§Œ ìœ„í—˜í•˜ë©° &quot;ì •ë°€ë„&quot;ì™€ëŠ” ì•„ë¬´ ê´€ë ¨ì´ ì—†ìŠµë‹ˆë‹¤. ë°°ì—´ì—ì„œ &lt;code&gt;delete&lt;/code&gt; í•´ì„œëŠ” ì•ˆë˜ëŠ” ì‹¤ì œ ì´ìœ ëŠ” ê°€ë¹„ì§€ ê°€ë“í•˜ê³  ì§€ì €ë¶„í•œ ë°ì´í„° êµ¬ì¡°ë¥¼ ë‚¨ê²¨ ë‘ëŠ” ê²ƒì´ ëŠìŠ¨í•˜ê³  ë²„ê·¸ê°€ ë°œìƒí•˜ê¸° ì‰½ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="1f5947457b95655f5329f1cfd08d1b56c64dd6e7" translate="yes" xml:space="preserve">
          <source>Which means in this case you won't be able to remove that object because you have created the &lt;code&gt;regex&lt;/code&gt; variable via a &lt;code&gt;var&lt;/code&gt; statement, and if you do:</source>
          <target state="translated">ì´ ê²½ìš° &lt;code&gt;var&lt;/code&gt; ë¬¸ì„ í†µí•´ &lt;code&gt;regex&lt;/code&gt; ë³€ìˆ˜ë¥¼ ë§Œë“¤ì—ˆìœ¼ë¯€ë¡œ ë‹¤ìŒê³¼ ê°™ì€ ê²½ìš° í•´ë‹¹ ê°œì²´ë¥¼ ì œê±° í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="4f17f120087f0ca40e417b064249125802d82ec5" translate="yes" xml:space="preserve">
          <source>While using &lt;code&gt;obj[prop] = undefined&lt;/code&gt; is faster than doing &lt;code&gt;delete obj[prop]&lt;/code&gt;, another important consideration is that &lt;code&gt;obj[prop] = undefined&lt;/code&gt; may not always be appropriate. &lt;code&gt;delete obj[prop]&lt;/code&gt; removes &lt;code&gt;prop&lt;/code&gt; from &lt;code&gt;obj&lt;/code&gt; and erases it from memory whereas &lt;code&gt;obj[prop] = undefined&lt;/code&gt; simply sets the value of &lt;code&gt;prop&lt;/code&gt; to &lt;code&gt;undefined&lt;/code&gt; which leaves &lt;code&gt;prop&lt;/code&gt; still in memory. Therefore, in circumstances where there are many keys being created and deleted, using &lt;code&gt;obj[prop] = undefined&lt;/code&gt; can force expensive memory reconciliation (causing the page to freeze up) and potentially an out-of-memory error. Examine the following code.</source>
          <target state="translated">&lt;code&gt;obj[prop] = undefined&lt;/code&gt; ê²ƒì´ &lt;code&gt;delete obj[prop]&lt;/code&gt; ìˆ˜í–‰í•˜ëŠ” ê²ƒë³´ë‹¤ ë¹ ë¥´ì§€ ë§Œ, ë˜ ë‹¤ë¥¸ ì¤‘ìš”í•œ ê³ ë ¤ ì‚¬í•­ì€ &lt;code&gt;obj[prop] = undefined&lt;/code&gt; ê°€ í•­ìƒ ì ì ˆí•˜ì§€ ì•Šì„ ìˆ˜ë„ ìˆë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. &lt;code&gt;delete obj[prop]&lt;/code&gt; ëŠ” &lt;code&gt;obj&lt;/code&gt; ì—ì„œ &lt;code&gt;prop&lt;/code&gt; ì„ ì œê±°í•˜ê³  ë©”ëª¨ë¦¬ì—ì„œ ì§€ ì›ë‹ˆë‹¤. ë°˜ë©´ &lt;code&gt;obj[prop] = undefined&lt;/code&gt; ëŠ” &lt;code&gt;prop&lt;/code&gt; ì˜ ê°’ì„ undefined ë¡œ ì„¤ì •í•˜ì—¬ prop ì„ ë©”ëª¨ë¦¬ì— ê·¸ëŒ€ë¡œ ë‘¡ë‹ˆë‹¤. ë”°ë¼ì„œ ë§ì€ í‚¤ê°€ ìƒì„± ë° ì‚­ì œë˜ëŠ” ìƒí™©ì—ì„œ &lt;code&gt;obj[prop] = undefined&lt;/code&gt; í•˜ë©´ ê°’ ë¹„ì‹¼ ë©”ëª¨ë¦¬ ì¡°ì • (í˜ì´ì§€ ì¤‘ì§€ë¡œ ì¸í•œ) ë° ë©”ëª¨ë¦¬ ë¶€ì¡± ì˜¤ë¥˜ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ì½”ë“œë¥¼ ê²€ì‚¬í•˜ì‹­ì‹œì˜¤.</target>
        </trans-unit>
        <trans-unit id="9fc668854fffc36979144c2d4415e9f9721712c0" translate="yes" xml:space="preserve">
          <source>While you technically can use &lt;code&gt;delete&lt;/code&gt; for an array, using it would result in getting incorrect results when calling for example &lt;code&gt;Hogwarts.staff.length&lt;/code&gt; later on. In other words, &lt;code&gt;delete&lt;/code&gt; would remove the element, but it wouldn't update the value of &lt;code&gt;length&lt;/code&gt; property. Using &lt;code&gt;delete&lt;/code&gt; would also mess up your indexing.</source>
          <target state="translated">ê¸°ìˆ ì ìœ¼ë¡œ ë°°ì—´ì— &lt;code&gt;delete&lt;/code&gt; ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆì§€ë§Œ ë‚˜ì¤‘ì— ë°°ì—´ì„ ì‚¬ìš©í•˜ë©´ ì˜ˆë¥¼ ë“¤ì–´ &lt;code&gt;Hogwarts.staff.length&lt;/code&gt; ë¥¼ í˜¸ì¶œ í•  ë•Œ ì˜ëª»ëœ ê²°ê³¼ê°€ ë°œìƒí•©ë‹ˆë‹¤. ì¦‰, &lt;code&gt;delete&lt;/code&gt; ëŠ” ìš”ì†Œë¥¼ ì œê±°í•˜ì§€ë§Œ &lt;code&gt;length&lt;/code&gt; ì†ì„± ê°’ì€ ì—…ë°ì´íŠ¸í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. &lt;code&gt;delete&lt;/code&gt; ë¥¼ ì‚¬ìš©í•˜ë©´ ì¸ë±ì‹±ì´ ì—‰ë§ì´ë©ë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="4be2ecd11ba0e212cafbe9f3ed4567f70ea3cc57" translate="yes" xml:space="preserve">
          <source>Yeah, that's definitely not what you wanted.</source>
          <target state="translated">ê·¸ë˜, ê·¸ê±´ ë„¤ê°€ ì›í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆì•¼.</target>
        </trans-unit>
        <trans-unit id="02c5f4541ba087fe996da9eb1271ebfb81156d83" translate="yes" xml:space="preserve">
          <source>You can also use other functions to achieve the same effect - omit, pick, ...</source>
          <target state="translated">ë‹¤ë¥¸ ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ì—¬ ë™ì¼í•œ íš¨ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤-ìƒëµ, ì„ íƒ, ...</target>
        </trans-unit>
        <trans-unit id="95e9a3221d0ebd0cc77f374d7ddfa95d905aef6a" translate="yes" xml:space="preserve">
          <source>You can delete that specific key from your object keys like:</source>
          <target state="translated">ë‹¤ìŒê³¼ ê°™ì´ ê°ì²´ í‚¤ì—ì„œ í•´ë‹¹ í‚¤ë¥¼ ì‚­ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="df5ae996f80ec18df6459baf979a058b543794dd" translate="yes" xml:space="preserve">
          <source>You can see it in action in the Babel try-out editor.</source>
          <target state="translated">Babel ì‹œí—˜íŒ í¸ì§‘ê¸°ì—ì„œ ì‘ë™ì¤‘ì¸ ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="ba4ef71e846efa414e359524a525c5bda890d6bb" translate="yes" xml:space="preserve">
          <source>You can simply delete any property of an object using the &lt;code&gt;delete&lt;/code&gt; keyword.</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ê°ì²´ì˜ ì†ì„±ì„ ê°„ë‹¨íˆ ì‚­ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="6902cdb7c6341debc4ec1b8c5eaf6794e483c684" translate="yes" xml:space="preserve">
          <source>You can use ES6 destructuring with rest operator.</source>
          <target state="translated">rest ì—°ì‚°ìì™€ í•¨ê»˜ ES6 íŒŒê´´ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="121a5978b1bee631af70ab1aaec00b53de7645b2" translate="yes" xml:space="preserve">
          <source>global scope) can be deleted with delete.</source>
          <target state="translated">ì „ì—­ ë²”ìœ„)ë¥¼ ì‚­ì œí•˜ì—¬ ì‚­ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="5be9ceecc2f03bc42e4d234aec808162f9c2f9d1" translate="yes" xml:space="preserve">
          <source>the result would be:</source>
          <target state="translated">ê²°ê³¼ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="cc81a06a417041080d93a2378641c20ac0ef4865" translate="yes" xml:space="preserve">
          <source>which is equivalent to:</source>
          <target state="translated">ì´ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.</target>
        </trans-unit>
        <trans-unit id="b9a0331930f5ae83ac7b458124a7b5021f44ea5d" translate="yes" xml:space="preserve">
          <source>will behave equivalently for both methods.</source>
          <target state="translated">ë‘ ë°©ë²• ëª¨ë‘ ë™ì¼í•˜ê²Œ ì‘ë™í•©ë‹ˆë‹¤.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
